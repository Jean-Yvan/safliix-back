
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SharedAccount
 * 
 */
export type SharedAccount = $Result.DefaultSelection<Prisma.$SharedAccountPayload>
/**
 * Model SharedAccountUser
 * 
 */
export type SharedAccountUser = $Result.DefaultSelection<Prisma.$SharedAccountUserPayload>
/**
 * Model VideoMetadata
 * 
 */
export type VideoMetadata = $Result.DefaultSelection<Prisma.$VideoMetadataPayload>
/**
 * Model VideoFile
 * 
 */
export type VideoFile = $Result.DefaultSelection<Prisma.$VideoFilePayload>
/**
 * Model VideoGenre
 * 
 */
export type VideoGenre = $Result.DefaultSelection<Prisma.$VideoGenrePayload>
/**
 * Model Actor
 * 
 */
export type Actor = $Result.DefaultSelection<Prisma.$ActorPayload>
/**
 * Model VideoActor
 * 
 */
export type VideoActor = $Result.DefaultSelection<Prisma.$VideoActorPayload>
/**
 * Model VideoLanguage
 * 
 */
export type VideoLanguage = $Result.DefaultSelection<Prisma.$VideoLanguagePayload>
/**
 * Model VideoFormat
 * 
 */
export type VideoFormat = $Result.DefaultSelection<Prisma.$VideoFormatPayload>
/**
 * Model VideoCategory
 * 
 */
export type VideoCategory = $Result.DefaultSelection<Prisma.$VideoCategoryPayload>
/**
 * Model Movie
 * 
 */
export type Movie = $Result.DefaultSelection<Prisma.$MoviePayload>
/**
 * Model Series
 * 
 */
export type Series = $Result.DefaultSelection<Prisma.$SeriesPayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model Episode
 * 
 */
export type Episode = $Result.DefaultSelection<Prisma.$EpisodePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model MovieTag
 * 
 */
export type MovieTag = $Result.DefaultSelection<Prisma.$MovieTagPayload>
/**
 * Model SeriesTag
 * 
 */
export type SeriesTag = $Result.DefaultSelection<Prisma.$SeriesTagPayload>
/**
 * Model Subtitle
 * 
 */
export type Subtitle = $Result.DefaultSelection<Prisma.$SubtitlePayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model View
 * 
 */
export type View = $Result.DefaultSelection<Prisma.$ViewPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Ad
 * 
 */
export type Ad = $Result.DefaultSelection<Prisma.$AdPayload>
/**
 * Model AdView
 * 
 */
export type AdView = $Result.DefaultSelection<Prisma.$AdViewPayload>
/**
 * Model SharedProfileActivity
 * 
 */
export type SharedProfileActivity = $Result.DefaultSelection<Prisma.$SharedProfileActivityPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VideoQuality: {
  SD: 'SD',
  HD: 'HD',
  UHD: 'UHD'
};

export type VideoQuality = (typeof VideoQuality)[keyof typeof VideoQuality]


export const RenewalStatus: {
  AUTO_RENEW: 'AUTO_RENEW',
  MANUAL: 'MANUAL',
  CANCELLED: 'CANCELLED'
};

export type RenewalStatus = (typeof RenewalStatus)[keyof typeof RenewalStatus]


export const SharedAccountStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REVOKED: 'REVOKED'
};

export type SharedAccountStatus = (typeof SharedAccountStatus)[keyof typeof SharedAccountStatus]


export const AgeRating: {
  G: 'G',
  PG: 'PG',
  PG_13: 'PG_13',
  R: 'R',
  NC_17: 'NC_17'
};

export type AgeRating = (typeof AgeRating)[keyof typeof AgeRating]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const ProfileActivityAction: {
  LOGIN: 'LOGIN',
  CONTENT_ACCESS: 'CONTENT_ACCESS',
  SETTINGS_CHANGE: 'SETTINGS_CHANGE'
};

export type ProfileActivityAction = (typeof ProfileActivityAction)[keyof typeof ProfileActivityAction]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VideoQuality = $Enums.VideoQuality

export const VideoQuality: typeof $Enums.VideoQuality

export type RenewalStatus = $Enums.RenewalStatus

export const RenewalStatus: typeof $Enums.RenewalStatus

export type SharedAccountStatus = $Enums.SharedAccountStatus

export const SharedAccountStatus: typeof $Enums.SharedAccountStatus

export type AgeRating = $Enums.AgeRating

export const AgeRating: typeof $Enums.AgeRating

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type ProfileActivityAction = $Enums.ProfileActivityAction

export const ProfileActivityAction: typeof $Enums.ProfileActivityAction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedAccount`: Exposes CRUD operations for the **SharedAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedAccounts
    * const sharedAccounts = await prisma.sharedAccount.findMany()
    * ```
    */
  get sharedAccount(): Prisma.SharedAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedAccountUser`: Exposes CRUD operations for the **SharedAccountUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedAccountUsers
    * const sharedAccountUsers = await prisma.sharedAccountUser.findMany()
    * ```
    */
  get sharedAccountUser(): Prisma.SharedAccountUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoMetadata`: Exposes CRUD operations for the **VideoMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoMetadata
    * const videoMetadata = await prisma.videoMetadata.findMany()
    * ```
    */
  get videoMetadata(): Prisma.VideoMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoFile`: Exposes CRUD operations for the **VideoFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoFiles
    * const videoFiles = await prisma.videoFile.findMany()
    * ```
    */
  get videoFile(): Prisma.VideoFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoGenre`: Exposes CRUD operations for the **VideoGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoGenres
    * const videoGenres = await prisma.videoGenre.findMany()
    * ```
    */
  get videoGenre(): Prisma.VideoGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actor`: Exposes CRUD operations for the **Actor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actors
    * const actors = await prisma.actor.findMany()
    * ```
    */
  get actor(): Prisma.ActorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoActor`: Exposes CRUD operations for the **VideoActor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoActors
    * const videoActors = await prisma.videoActor.findMany()
    * ```
    */
  get videoActor(): Prisma.VideoActorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoLanguage`: Exposes CRUD operations for the **VideoLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoLanguages
    * const videoLanguages = await prisma.videoLanguage.findMany()
    * ```
    */
  get videoLanguage(): Prisma.VideoLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoFormat`: Exposes CRUD operations for the **VideoFormat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoFormats
    * const videoFormats = await prisma.videoFormat.findMany()
    * ```
    */
  get videoFormat(): Prisma.VideoFormatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoCategory`: Exposes CRUD operations for the **VideoCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoCategories
    * const videoCategories = await prisma.videoCategory.findMany()
    * ```
    */
  get videoCategory(): Prisma.VideoCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **Movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.MovieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **Series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Series
    * const series = await prisma.series.findMany()
    * ```
    */
  get series(): Prisma.SeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.episode`: Exposes CRUD operations for the **Episode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Episodes
    * const episodes = await prisma.episode.findMany()
    * ```
    */
  get episode(): Prisma.EpisodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movieTag`: Exposes CRUD operations for the **MovieTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieTags
    * const movieTags = await prisma.movieTag.findMany()
    * ```
    */
  get movieTag(): Prisma.MovieTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seriesTag`: Exposes CRUD operations for the **SeriesTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeriesTags
    * const seriesTags = await prisma.seriesTag.findMany()
    * ```
    */
  get seriesTag(): Prisma.SeriesTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subtitle`: Exposes CRUD operations for the **Subtitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtitles
    * const subtitles = await prisma.subtitle.findMany()
    * ```
    */
  get subtitle(): Prisma.SubtitleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.view`: Exposes CRUD operations for the **View** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Views
    * const views = await prisma.view.findMany()
    * ```
    */
  get view(): Prisma.ViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ad`: Exposes CRUD operations for the **Ad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ads
    * const ads = await prisma.ad.findMany()
    * ```
    */
  get ad(): Prisma.AdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adView`: Exposes CRUD operations for the **AdView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdViews
    * const adViews = await prisma.adView.findMany()
    * ```
    */
  get adView(): Prisma.AdViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedProfileActivity`: Exposes CRUD operations for the **SharedProfileActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedProfileActivities
    * const sharedProfileActivities = await prisma.sharedProfileActivity.findMany()
    * ```
    */
  get sharedProfileActivity(): Prisma.SharedProfileActivityDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    SubscriptionPlan: 'SubscriptionPlan',
    Subscription: 'Subscription',
    SharedAccount: 'SharedAccount',
    SharedAccountUser: 'SharedAccountUser',
    VideoMetadata: 'VideoMetadata',
    VideoFile: 'VideoFile',
    VideoGenre: 'VideoGenre',
    Actor: 'Actor',
    VideoActor: 'VideoActor',
    VideoLanguage: 'VideoLanguage',
    VideoFormat: 'VideoFormat',
    VideoCategory: 'VideoCategory',
    Movie: 'Movie',
    Series: 'Series',
    Season: 'Season',
    Episode: 'Episode',
    Tag: 'Tag',
    MovieTag: 'MovieTag',
    SeriesTag: 'SeriesTag',
    Subtitle: 'Subtitle',
    Purchase: 'Purchase',
    View: 'View',
    Comment: 'Comment',
    Ad: 'Ad',
    AdView: 'AdView',
    SharedProfileActivity: 'SharedProfileActivity'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "subscriptionPlan" | "subscription" | "sharedAccount" | "sharedAccountUser" | "videoMetadata" | "videoFile" | "videoGenre" | "actor" | "videoActor" | "videoLanguage" | "videoFormat" | "videoCategory" | "movie" | "series" | "season" | "episode" | "tag" | "movieTag" | "seriesTag" | "subtitle" | "purchase" | "view" | "comment" | "ad" | "adView" | "sharedProfileActivity"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SharedAccount: {
        payload: Prisma.$SharedAccountPayload<ExtArgs>
        fields: Prisma.SharedAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>
          }
          findFirst: {
            args: Prisma.SharedAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>
          }
          findMany: {
            args: Prisma.SharedAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>[]
          }
          create: {
            args: Prisma.SharedAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>
          }
          createMany: {
            args: Prisma.SharedAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>[]
          }
          delete: {
            args: Prisma.SharedAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>
          }
          update: {
            args: Prisma.SharedAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>
          }
          deleteMany: {
            args: Prisma.SharedAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>[]
          }
          upsert: {
            args: Prisma.SharedAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountPayload>
          }
          aggregate: {
            args: Prisma.SharedAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedAccount>
          }
          groupBy: {
            args: Prisma.SharedAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SharedAccountCountAggregateOutputType> | number
          }
        }
      }
      SharedAccountUser: {
        payload: Prisma.$SharedAccountUserPayload<ExtArgs>
        fields: Prisma.SharedAccountUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedAccountUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedAccountUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>
          }
          findFirst: {
            args: Prisma.SharedAccountUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedAccountUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>
          }
          findMany: {
            args: Prisma.SharedAccountUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>[]
          }
          create: {
            args: Prisma.SharedAccountUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>
          }
          createMany: {
            args: Prisma.SharedAccountUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedAccountUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>[]
          }
          delete: {
            args: Prisma.SharedAccountUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>
          }
          update: {
            args: Prisma.SharedAccountUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>
          }
          deleteMany: {
            args: Prisma.SharedAccountUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedAccountUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedAccountUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>[]
          }
          upsert: {
            args: Prisma.SharedAccountUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAccountUserPayload>
          }
          aggregate: {
            args: Prisma.SharedAccountUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedAccountUser>
          }
          groupBy: {
            args: Prisma.SharedAccountUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedAccountUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedAccountUserCountArgs<ExtArgs>
            result: $Utils.Optional<SharedAccountUserCountAggregateOutputType> | number
          }
        }
      }
      VideoMetadata: {
        payload: Prisma.$VideoMetadataPayload<ExtArgs>
        fields: Prisma.VideoMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>
          }
          findFirst: {
            args: Prisma.VideoMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>
          }
          findMany: {
            args: Prisma.VideoMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>[]
          }
          create: {
            args: Prisma.VideoMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>
          }
          createMany: {
            args: Prisma.VideoMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>[]
          }
          delete: {
            args: Prisma.VideoMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>
          }
          update: {
            args: Prisma.VideoMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>
          }
          deleteMany: {
            args: Prisma.VideoMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>[]
          }
          upsert: {
            args: Prisma.VideoMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMetadataPayload>
          }
          aggregate: {
            args: Prisma.VideoMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoMetadata>
          }
          groupBy: {
            args: Prisma.VideoMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<VideoMetadataCountAggregateOutputType> | number
          }
        }
      }
      VideoFile: {
        payload: Prisma.$VideoFilePayload<ExtArgs>
        fields: Prisma.VideoFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>
          }
          findFirst: {
            args: Prisma.VideoFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>
          }
          findMany: {
            args: Prisma.VideoFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>[]
          }
          create: {
            args: Prisma.VideoFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>
          }
          createMany: {
            args: Prisma.VideoFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>[]
          }
          delete: {
            args: Prisma.VideoFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>
          }
          update: {
            args: Prisma.VideoFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>
          }
          deleteMany: {
            args: Prisma.VideoFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>[]
          }
          upsert: {
            args: Prisma.VideoFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFilePayload>
          }
          aggregate: {
            args: Prisma.VideoFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoFile>
          }
          groupBy: {
            args: Prisma.VideoFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoFileCountArgs<ExtArgs>
            result: $Utils.Optional<VideoFileCountAggregateOutputType> | number
          }
        }
      }
      VideoGenre: {
        payload: Prisma.$VideoGenrePayload<ExtArgs>
        fields: Prisma.VideoGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>
          }
          findFirst: {
            args: Prisma.VideoGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>
          }
          findMany: {
            args: Prisma.VideoGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>[]
          }
          create: {
            args: Prisma.VideoGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>
          }
          createMany: {
            args: Prisma.VideoGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>[]
          }
          delete: {
            args: Prisma.VideoGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>
          }
          update: {
            args: Prisma.VideoGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>
          }
          deleteMany: {
            args: Prisma.VideoGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoGenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>[]
          }
          upsert: {
            args: Prisma.VideoGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoGenrePayload>
          }
          aggregate: {
            args: Prisma.VideoGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoGenre>
          }
          groupBy: {
            args: Prisma.VideoGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoGenreCountArgs<ExtArgs>
            result: $Utils.Optional<VideoGenreCountAggregateOutputType> | number
          }
        }
      }
      Actor: {
        payload: Prisma.$ActorPayload<ExtArgs>
        fields: Prisma.ActorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          findFirst: {
            args: Prisma.ActorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          findMany: {
            args: Prisma.ActorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>[]
          }
          create: {
            args: Prisma.ActorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          createMany: {
            args: Prisma.ActorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>[]
          }
          delete: {
            args: Prisma.ActorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          update: {
            args: Prisma.ActorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          deleteMany: {
            args: Prisma.ActorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>[]
          }
          upsert: {
            args: Prisma.ActorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          aggregate: {
            args: Prisma.ActorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActor>
          }
          groupBy: {
            args: Prisma.ActorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActorCountArgs<ExtArgs>
            result: $Utils.Optional<ActorCountAggregateOutputType> | number
          }
        }
      }
      VideoActor: {
        payload: Prisma.$VideoActorPayload<ExtArgs>
        fields: Prisma.VideoActorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoActorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoActorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>
          }
          findFirst: {
            args: Prisma.VideoActorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoActorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>
          }
          findMany: {
            args: Prisma.VideoActorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>[]
          }
          create: {
            args: Prisma.VideoActorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>
          }
          createMany: {
            args: Prisma.VideoActorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoActorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>[]
          }
          delete: {
            args: Prisma.VideoActorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>
          }
          update: {
            args: Prisma.VideoActorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>
          }
          deleteMany: {
            args: Prisma.VideoActorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoActorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoActorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>[]
          }
          upsert: {
            args: Prisma.VideoActorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoActorPayload>
          }
          aggregate: {
            args: Prisma.VideoActorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoActor>
          }
          groupBy: {
            args: Prisma.VideoActorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoActorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoActorCountArgs<ExtArgs>
            result: $Utils.Optional<VideoActorCountAggregateOutputType> | number
          }
        }
      }
      VideoLanguage: {
        payload: Prisma.$VideoLanguagePayload<ExtArgs>
        fields: Prisma.VideoLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>
          }
          findFirst: {
            args: Prisma.VideoLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>
          }
          findMany: {
            args: Prisma.VideoLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>[]
          }
          create: {
            args: Prisma.VideoLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>
          }
          createMany: {
            args: Prisma.VideoLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>[]
          }
          delete: {
            args: Prisma.VideoLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>
          }
          update: {
            args: Prisma.VideoLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>
          }
          deleteMany: {
            args: Prisma.VideoLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>[]
          }
          upsert: {
            args: Prisma.VideoLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoLanguagePayload>
          }
          aggregate: {
            args: Prisma.VideoLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoLanguage>
          }
          groupBy: {
            args: Prisma.VideoLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<VideoLanguageCountAggregateOutputType> | number
          }
        }
      }
      VideoFormat: {
        payload: Prisma.$VideoFormatPayload<ExtArgs>
        fields: Prisma.VideoFormatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFormatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFormatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>
          }
          findFirst: {
            args: Prisma.VideoFormatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFormatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>
          }
          findMany: {
            args: Prisma.VideoFormatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>[]
          }
          create: {
            args: Prisma.VideoFormatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>
          }
          createMany: {
            args: Prisma.VideoFormatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoFormatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>[]
          }
          delete: {
            args: Prisma.VideoFormatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>
          }
          update: {
            args: Prisma.VideoFormatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>
          }
          deleteMany: {
            args: Prisma.VideoFormatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoFormatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoFormatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>[]
          }
          upsert: {
            args: Prisma.VideoFormatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoFormatPayload>
          }
          aggregate: {
            args: Prisma.VideoFormatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoFormat>
          }
          groupBy: {
            args: Prisma.VideoFormatGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoFormatGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoFormatCountArgs<ExtArgs>
            result: $Utils.Optional<VideoFormatCountAggregateOutputType> | number
          }
        }
      }
      VideoCategory: {
        payload: Prisma.$VideoCategoryPayload<ExtArgs>
        fields: Prisma.VideoCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>
          }
          findFirst: {
            args: Prisma.VideoCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>
          }
          findMany: {
            args: Prisma.VideoCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>[]
          }
          create: {
            args: Prisma.VideoCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>
          }
          createMany: {
            args: Prisma.VideoCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>[]
          }
          delete: {
            args: Prisma.VideoCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>
          }
          update: {
            args: Prisma.VideoCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>
          }
          deleteMany: {
            args: Prisma.VideoCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>[]
          }
          upsert: {
            args: Prisma.VideoCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoCategoryPayload>
          }
          aggregate: {
            args: Prisma.VideoCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoCategory>
          }
          groupBy: {
            args: Prisma.VideoCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCategoryCountAggregateOutputType> | number
          }
        }
      }
      Movie: {
        payload: Prisma.$MoviePayload<ExtArgs>
        fields: Prisma.MovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findFirst: {
            args: Prisma.MovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findMany: {
            args: Prisma.MovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          create: {
            args: Prisma.MovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          createMany: {
            args: Prisma.MovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          delete: {
            args: Prisma.MovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          update: {
            args: Prisma.MovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          deleteMany: {
            args: Prisma.MovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          upsert: {
            args: Prisma.MovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          aggregate: {
            args: Prisma.MovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovie>
          }
          groupBy: {
            args: Prisma.MovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCountAggregateOutputType> | number
          }
        }
      }
      Series: {
        payload: Prisma.$SeriesPayload<ExtArgs>
        fields: Prisma.SeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findFirst: {
            args: Prisma.SeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findMany: {
            args: Prisma.SeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          create: {
            args: Prisma.SeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          createMany: {
            args: Prisma.SeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          delete: {
            args: Prisma.SeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          update: {
            args: Prisma.SeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          deleteMany: {
            args: Prisma.SeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          upsert: {
            args: Prisma.SeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeries>
          }
          groupBy: {
            args: Prisma.SeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      Episode: {
        payload: Prisma.$EpisodePayload<ExtArgs>
        fields: Prisma.EpisodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EpisodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EpisodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          findFirst: {
            args: Prisma.EpisodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EpisodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          findMany: {
            args: Prisma.EpisodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>[]
          }
          create: {
            args: Prisma.EpisodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          createMany: {
            args: Prisma.EpisodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EpisodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>[]
          }
          delete: {
            args: Prisma.EpisodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          update: {
            args: Prisma.EpisodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          deleteMany: {
            args: Prisma.EpisodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EpisodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EpisodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>[]
          }
          upsert: {
            args: Prisma.EpisodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          aggregate: {
            args: Prisma.EpisodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpisode>
          }
          groupBy: {
            args: Prisma.EpisodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpisodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EpisodeCountArgs<ExtArgs>
            result: $Utils.Optional<EpisodeCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      MovieTag: {
        payload: Prisma.$MovieTagPayload<ExtArgs>
        fields: Prisma.MovieTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          findFirst: {
            args: Prisma.MovieTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          findMany: {
            args: Prisma.MovieTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>[]
          }
          create: {
            args: Prisma.MovieTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          createMany: {
            args: Prisma.MovieTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>[]
          }
          delete: {
            args: Prisma.MovieTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          update: {
            args: Prisma.MovieTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          deleteMany: {
            args: Prisma.MovieTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MovieTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>[]
          }
          upsert: {
            args: Prisma.MovieTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieTagPayload>
          }
          aggregate: {
            args: Prisma.MovieTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieTag>
          }
          groupBy: {
            args: Prisma.MovieTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieTagCountArgs<ExtArgs>
            result: $Utils.Optional<MovieTagCountAggregateOutputType> | number
          }
        }
      }
      SeriesTag: {
        payload: Prisma.$SeriesTagPayload<ExtArgs>
        fields: Prisma.SeriesTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>
          }
          findFirst: {
            args: Prisma.SeriesTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>
          }
          findMany: {
            args: Prisma.SeriesTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>[]
          }
          create: {
            args: Prisma.SeriesTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>
          }
          createMany: {
            args: Prisma.SeriesTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>[]
          }
          delete: {
            args: Prisma.SeriesTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>
          }
          update: {
            args: Prisma.SeriesTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>
          }
          deleteMany: {
            args: Prisma.SeriesTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>[]
          }
          upsert: {
            args: Prisma.SeriesTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesTagPayload>
          }
          aggregate: {
            args: Prisma.SeriesTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeriesTag>
          }
          groupBy: {
            args: Prisma.SeriesTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesTagCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesTagCountAggregateOutputType> | number
          }
        }
      }
      Subtitle: {
        payload: Prisma.$SubtitlePayload<ExtArgs>
        fields: Prisma.SubtitleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtitleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtitleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          findFirst: {
            args: Prisma.SubtitleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtitleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          findMany: {
            args: Prisma.SubtitleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>[]
          }
          create: {
            args: Prisma.SubtitleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          createMany: {
            args: Prisma.SubtitleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtitleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>[]
          }
          delete: {
            args: Prisma.SubtitleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          update: {
            args: Prisma.SubtitleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          deleteMany: {
            args: Prisma.SubtitleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtitleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubtitleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>[]
          }
          upsert: {
            args: Prisma.SubtitleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          aggregate: {
            args: Prisma.SubtitleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtitle>
          }
          groupBy: {
            args: Prisma.SubtitleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtitleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtitleCountArgs<ExtArgs>
            result: $Utils.Optional<SubtitleCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      View: {
        payload: Prisma.$ViewPayload<ExtArgs>
        fields: Prisma.ViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>
          }
          findFirst: {
            args: Prisma.ViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>
          }
          findMany: {
            args: Prisma.ViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>[]
          }
          create: {
            args: Prisma.ViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>
          }
          createMany: {
            args: Prisma.ViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>[]
          }
          delete: {
            args: Prisma.ViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>
          }
          update: {
            args: Prisma.ViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>
          }
          deleteMany: {
            args: Prisma.ViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>[]
          }
          upsert: {
            args: Prisma.ViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewPayload>
          }
          aggregate: {
            args: Prisma.ViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateView>
          }
          groupBy: {
            args: Prisma.ViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewCountArgs<ExtArgs>
            result: $Utils.Optional<ViewCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Ad: {
        payload: Prisma.$AdPayload<ExtArgs>
        fields: Prisma.AdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findFirst: {
            args: Prisma.AdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findMany: {
            args: Prisma.AdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          create: {
            args: Prisma.AdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          createMany: {
            args: Prisma.AdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          delete: {
            args: Prisma.AdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          update: {
            args: Prisma.AdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          deleteMany: {
            args: Prisma.AdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          upsert: {
            args: Prisma.AdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          aggregate: {
            args: Prisma.AdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAd>
          }
          groupBy: {
            args: Prisma.AdGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdCountArgs<ExtArgs>
            result: $Utils.Optional<AdCountAggregateOutputType> | number
          }
        }
      }
      AdView: {
        payload: Prisma.$AdViewPayload<ExtArgs>
        fields: Prisma.AdViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>
          }
          findFirst: {
            args: Prisma.AdViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>
          }
          findMany: {
            args: Prisma.AdViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>[]
          }
          create: {
            args: Prisma.AdViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>
          }
          createMany: {
            args: Prisma.AdViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>[]
          }
          delete: {
            args: Prisma.AdViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>
          }
          update: {
            args: Prisma.AdViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>
          }
          deleteMany: {
            args: Prisma.AdViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>[]
          }
          upsert: {
            args: Prisma.AdViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdViewPayload>
          }
          aggregate: {
            args: Prisma.AdViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdView>
          }
          groupBy: {
            args: Prisma.AdViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdViewCountArgs<ExtArgs>
            result: $Utils.Optional<AdViewCountAggregateOutputType> | number
          }
        }
      }
      SharedProfileActivity: {
        payload: Prisma.$SharedProfileActivityPayload<ExtArgs>
        fields: Prisma.SharedProfileActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedProfileActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedProfileActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>
          }
          findFirst: {
            args: Prisma.SharedProfileActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedProfileActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>
          }
          findMany: {
            args: Prisma.SharedProfileActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>[]
          }
          create: {
            args: Prisma.SharedProfileActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>
          }
          createMany: {
            args: Prisma.SharedProfileActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedProfileActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>[]
          }
          delete: {
            args: Prisma.SharedProfileActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>
          }
          update: {
            args: Prisma.SharedProfileActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>
          }
          deleteMany: {
            args: Prisma.SharedProfileActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedProfileActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedProfileActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>[]
          }
          upsert: {
            args: Prisma.SharedProfileActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProfileActivityPayload>
          }
          aggregate: {
            args: Prisma.SharedProfileActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedProfileActivity>
          }
          groupBy: {
            args: Prisma.SharedProfileActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedProfileActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedProfileActivityCountArgs<ExtArgs>
            result: $Utils.Optional<SharedProfileActivityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    subscriptionPlan?: SubscriptionPlanOmit
    subscription?: SubscriptionOmit
    sharedAccount?: SharedAccountOmit
    sharedAccountUser?: SharedAccountUserOmit
    videoMetadata?: VideoMetadataOmit
    videoFile?: VideoFileOmit
    videoGenre?: VideoGenreOmit
    actor?: ActorOmit
    videoActor?: VideoActorOmit
    videoLanguage?: VideoLanguageOmit
    videoFormat?: VideoFormatOmit
    videoCategory?: VideoCategoryOmit
    movie?: MovieOmit
    series?: SeriesOmit
    season?: SeasonOmit
    episode?: EpisodeOmit
    tag?: TagOmit
    movieTag?: MovieTagOmit
    seriesTag?: SeriesTagOmit
    subtitle?: SubtitleOmit
    purchase?: PurchaseOmit
    view?: ViewOmit
    comment?: CommentOmit
    ad?: AdOmit
    adView?: AdViewOmit
    sharedProfileActivity?: SharedProfileActivityOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    subscriptions: number
    ownedSharedAccounts: number
    sharedProfiles: number
    purchases: number
    views: number
    comments: number
    SharedAccount: number
    adViews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    ownedSharedAccounts?: boolean | UserCountOutputTypeCountOwnedSharedAccountsArgs
    sharedProfiles?: boolean | UserCountOutputTypeCountSharedProfilesArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    views?: boolean | UserCountOutputTypeCountViewsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    SharedAccount?: boolean | UserCountOutputTypeCountSharedAccountArgs
    adViews?: boolean | UserCountOutputTypeCountAdViewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedSharedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdViewWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    sharedAccounts: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedAccounts?: boolean | SubscriptionCountOutputTypeCountSharedAccountsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountSharedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountWhereInput
  }


  /**
   * Count Type SharedAccountCountOutputType
   */

  export type SharedAccountCountOutputType = {
    profiles: number
  }

  export type SharedAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | SharedAccountCountOutputTypeCountProfilesArgs
  }

  // Custom InputTypes
  /**
   * SharedAccountCountOutputType without action
   */
  export type SharedAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountCountOutputType
     */
    select?: SharedAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SharedAccountCountOutputType without action
   */
  export type SharedAccountCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountUserWhereInput
  }


  /**
   * Count Type SharedAccountUserCountOutputType
   */

  export type SharedAccountUserCountOutputType = {
    views: number
    adViews: number
    activities: number
  }

  export type SharedAccountUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    views?: boolean | SharedAccountUserCountOutputTypeCountViewsArgs
    adViews?: boolean | SharedAccountUserCountOutputTypeCountAdViewsArgs
    activities?: boolean | SharedAccountUserCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * SharedAccountUserCountOutputType without action
   */
  export type SharedAccountUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUserCountOutputType
     */
    select?: SharedAccountUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SharedAccountUserCountOutputType without action
   */
  export type SharedAccountUserCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewWhereInput
  }

  /**
   * SharedAccountUserCountOutputType without action
   */
  export type SharedAccountUserCountOutputTypeCountAdViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdViewWhereInput
  }

  /**
   * SharedAccountUserCountOutputType without action
   */
  export type SharedAccountUserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedProfileActivityWhereInput
  }


  /**
   * Count Type VideoMetadataCountOutputType
   */

  export type VideoMetadataCountOutputType = {
    genres: number
    actors: number
    subtitles: number
    languages: number
  }

  export type VideoMetadataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genres?: boolean | VideoMetadataCountOutputTypeCountGenresArgs
    actors?: boolean | VideoMetadataCountOutputTypeCountActorsArgs
    subtitles?: boolean | VideoMetadataCountOutputTypeCountSubtitlesArgs
    languages?: boolean | VideoMetadataCountOutputTypeCountLanguagesArgs
  }

  // Custom InputTypes
  /**
   * VideoMetadataCountOutputType without action
   */
  export type VideoMetadataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadataCountOutputType
     */
    select?: VideoMetadataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoMetadataCountOutputType without action
   */
  export type VideoMetadataCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoGenreWhereInput
  }

  /**
   * VideoMetadataCountOutputType without action
   */
  export type VideoMetadataCountOutputTypeCountActorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoActorWhereInput
  }

  /**
   * VideoMetadataCountOutputType without action
   */
  export type VideoMetadataCountOutputTypeCountSubtitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleWhereInput
  }

  /**
   * VideoMetadataCountOutputType without action
   */
  export type VideoMetadataCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoLanguageWhereInput
  }


  /**
   * Count Type VideoFileCountOutputType
   */

  export type VideoFileCountOutputType = {
    subtitles: number
    purchases: number
    comments: number
    views: number
  }

  export type VideoFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtitles?: boolean | VideoFileCountOutputTypeCountSubtitlesArgs
    purchases?: boolean | VideoFileCountOutputTypeCountPurchasesArgs
    comments?: boolean | VideoFileCountOutputTypeCountCommentsArgs
    views?: boolean | VideoFileCountOutputTypeCountViewsArgs
  }

  // Custom InputTypes
  /**
   * VideoFileCountOutputType without action
   */
  export type VideoFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFileCountOutputType
     */
    select?: VideoFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoFileCountOutputType without action
   */
  export type VideoFileCountOutputTypeCountSubtitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleWhereInput
  }

  /**
   * VideoFileCountOutputType without action
   */
  export type VideoFileCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * VideoFileCountOutputType without action
   */
  export type VideoFileCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * VideoFileCountOutputType without action
   */
  export type VideoFileCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewWhereInput
  }


  /**
   * Count Type VideoGenreCountOutputType
   */

  export type VideoGenreCountOutputType = {
    videos: number
  }

  export type VideoGenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoGenreCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * VideoGenreCountOutputType without action
   */
  export type VideoGenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenreCountOutputType
     */
    select?: VideoGenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoGenreCountOutputType without action
   */
  export type VideoGenreCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMetadataWhereInput
  }


  /**
   * Count Type ActorCountOutputType
   */

  export type ActorCountOutputType = {
    VideoActor: number
  }

  export type ActorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VideoActor?: boolean | ActorCountOutputTypeCountVideoActorArgs
  }

  // Custom InputTypes
  /**
   * ActorCountOutputType without action
   */
  export type ActorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActorCountOutputType
     */
    select?: ActorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActorCountOutputType without action
   */
  export type ActorCountOutputTypeCountVideoActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoActorWhereInput
  }


  /**
   * Count Type VideoLanguageCountOutputType
   */

  export type VideoLanguageCountOutputType = {
    videos: number
  }

  export type VideoLanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoLanguageCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * VideoLanguageCountOutputType without action
   */
  export type VideoLanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguageCountOutputType
     */
    select?: VideoLanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoLanguageCountOutputType without action
   */
  export type VideoLanguageCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMetadataWhereInput
  }


  /**
   * Count Type VideoFormatCountOutputType
   */

  export type VideoFormatCountOutputType = {
    videos: number
  }

  export type VideoFormatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoFormatCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * VideoFormatCountOutputType without action
   */
  export type VideoFormatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormatCountOutputType
     */
    select?: VideoFormatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoFormatCountOutputType without action
   */
  export type VideoFormatCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMetadataWhereInput
  }


  /**
   * Count Type VideoCategoryCountOutputType
   */

  export type VideoCategoryCountOutputType = {
    videos: number
  }

  export type VideoCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoCategoryCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * VideoCategoryCountOutputType without action
   */
  export type VideoCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategoryCountOutputType
     */
    select?: VideoCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoCategoryCountOutputType without action
   */
  export type VideoCategoryCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMetadataWhereInput
  }


  /**
   * Count Type MovieCountOutputType
   */

  export type MovieCountOutputType = {
    tags: number
  }

  export type MovieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | MovieCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieTagWhereInput
  }


  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    seasons: number
    tags: number
  }

  export type SeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | SeriesCountOutputTypeCountSeasonsArgs
    tags?: boolean | SeriesCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesTagWhereInput
  }


  /**
   * Count Type SeasonCountOutputType
   */

  export type SeasonCountOutputType = {
    episodes: number
  }

  export type SeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episodes?: boolean | SeasonCountOutputTypeCountEpisodesArgs
  }

  // Custom InputTypes
  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountEpisodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpisodeWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    movieTags: number
    seriesTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieTags?: boolean | TagCountOutputTypeCountMovieTagsArgs
    seriesTags?: boolean | TagCountOutputTypeCountSeriesTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMovieTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountSeriesTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesTagWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type AdCountOutputType
   */

  export type AdCountOutputType = {
    views: number
  }

  export type AdCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    views?: boolean | AdCountOutputTypeCountViewsArgs
  }

  // Custom InputTypes
  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCountOutputType
     */
    select?: AdCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdViewWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    avatarUrl: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
    isVerified: boolean | null
    isMainAccount: boolean | null
    role: $Enums.UserRole | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    avatarUrl: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
    isVerified: boolean | null
    isMainAccount: boolean | null
    role: $Enums.UserRole | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    name: number
    avatarUrl: number
    createdAt: number
    lastLoginAt: number
    isVerified: number
    isMainAccount: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    avatarUrl?: true
    createdAt?: true
    lastLoginAt?: true
    isVerified?: true
    isMainAccount?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    avatarUrl?: true
    createdAt?: true
    lastLoginAt?: true
    isVerified?: true
    isMainAccount?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    avatarUrl?: true
    createdAt?: true
    lastLoginAt?: true
    isVerified?: true
    isMainAccount?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    name: string | null
    avatarUrl: string | null
    createdAt: Date
    lastLoginAt: Date | null
    isVerified: boolean
    isMainAccount: boolean
    role: $Enums.UserRole
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    isVerified?: boolean
    isMainAccount?: boolean
    role?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    ownedSharedAccounts?: boolean | User$ownedSharedAccountsArgs<ExtArgs>
    sharedProfiles?: boolean | User$sharedProfilesArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    views?: boolean | User$viewsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    SharedAccount?: boolean | User$SharedAccountArgs<ExtArgs>
    adViews?: boolean | User$adViewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    isVerified?: boolean
    isMainAccount?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    isVerified?: boolean
    isMainAccount?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    isVerified?: boolean
    isMainAccount?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "name" | "avatarUrl" | "createdAt" | "lastLoginAt" | "isVerified" | "isMainAccount" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    ownedSharedAccounts?: boolean | User$ownedSharedAccountsArgs<ExtArgs>
    sharedProfiles?: boolean | User$sharedProfilesArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    views?: boolean | User$viewsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    SharedAccount?: boolean | User$SharedAccountArgs<ExtArgs>
    adViews?: boolean | User$adViewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      ownedSharedAccounts: Prisma.$SharedAccountPayload<ExtArgs>[]
      sharedProfiles: Prisma.$SharedAccountUserPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      views: Prisma.$ViewPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      SharedAccount: Prisma.$SharedAccountPayload<ExtArgs>[]
      adViews: Prisma.$AdViewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      name: string | null
      avatarUrl: string | null
      createdAt: Date
      lastLoginAt: Date | null
      isVerified: boolean
      isMainAccount: boolean
      role: $Enums.UserRole
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedSharedAccounts<T extends User$ownedSharedAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedSharedAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedProfiles<T extends User$sharedProfilesArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends User$viewsArgs<ExtArgs> = {}>(args?: Subset<T, User$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SharedAccount<T extends User$SharedAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$SharedAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adViews<T extends User$adViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$adViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isMainAccount: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.ownedSharedAccounts
   */
  export type User$ownedSharedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    where?: SharedAccountWhereInput
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    cursor?: SharedAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAccountScalarFieldEnum | SharedAccountScalarFieldEnum[]
  }

  /**
   * User.sharedProfiles
   */
  export type User$sharedProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    where?: SharedAccountUserWhereInput
    orderBy?: SharedAccountUserOrderByWithRelationInput | SharedAccountUserOrderByWithRelationInput[]
    cursor?: SharedAccountUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAccountUserScalarFieldEnum | SharedAccountUserScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.views
   */
  export type User$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    where?: ViewWhereInput
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    cursor?: ViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewScalarFieldEnum | ViewScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.SharedAccount
   */
  export type User$SharedAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    where?: SharedAccountWhereInput
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    cursor?: SharedAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAccountScalarFieldEnum | SharedAccountScalarFieldEnum[]
  }

  /**
   * User.adViews
   */
  export type User$adViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    where?: AdViewWhereInput
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    cursor?: AdViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdViewScalarFieldEnum | AdViewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshToken: number
    ipAddress: number
    userAgent: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshToken: string
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    expiresAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refreshToken" | "ipAddress" | "userAgent" | "createdAt" | "expiresAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshToken: string
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: number | null
    maxSharedAccounts: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: number | null
    maxSharedAccounts: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    maxSharedAccounts: number | null
    videoQuality: $Enums.VideoQuality | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    maxSharedAccounts: number | null
    videoQuality: $Enums.VideoQuality | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    maxSharedAccounts: number
    videoQuality: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
    maxSharedAccounts?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
    maxSharedAccounts?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    maxSharedAccounts?: true
    videoQuality?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    maxSharedAccounts?: true
    videoQuality?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    maxSharedAccounts?: true
    videoQuality?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    price: number
    maxSharedAccounts: number
    videoQuality: $Enums.VideoQuality
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    maxSharedAccounts?: boolean
    videoQuality?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    maxSharedAccounts?: boolean
    videoQuality?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    maxSharedAccounts?: boolean
    videoQuality?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    maxSharedAccounts?: boolean
    videoQuality?: boolean
  }

  export type SubscriptionPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "maxSharedAccounts" | "videoQuality", ExtArgs["result"]["subscriptionPlan"]>
  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      maxSharedAccounts: number
      videoQuality: $Enums.VideoQuality
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Float'>
    readonly maxSharedAccounts: FieldRef<"SubscriptionPlan", 'Int'>
    readonly videoQuality: FieldRef<"SubscriptionPlan", 'VideoQuality'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    start_date: Date | null
    end_date: Date | null
    renewal_status: $Enums.RenewalStatus | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    start_date: Date | null
    end_date: Date | null
    renewal_status: $Enums.RenewalStatus | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    start_date: number
    end_date: number
    renewal_status: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    start_date?: true
    end_date?: true
    renewal_status?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    start_date?: true
    end_date?: true
    renewal_status?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    start_date?: true
    end_date?: true
    renewal_status?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    start_date: Date
    end_date: Date
    renewal_status: $Enums.RenewalStatus
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    start_date?: boolean
    end_date?: boolean
    renewal_status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    sharedAccounts?: boolean | Subscription$sharedAccountsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    start_date?: boolean
    end_date?: boolean
    renewal_status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    start_date?: boolean
    end_date?: boolean
    renewal_status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    start_date?: boolean
    end_date?: boolean
    renewal_status?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "start_date" | "end_date" | "renewal_status", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    sharedAccounts?: boolean | Subscription$sharedAccountsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      sharedAccounts: Prisma.$SharedAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      start_date: Date
      end_date: Date
      renewal_status: $Enums.RenewalStatus
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sharedAccounts<T extends Subscription$sharedAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$sharedAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly start_date: FieldRef<"Subscription", 'DateTime'>
    readonly end_date: FieldRef<"Subscription", 'DateTime'>
    readonly renewal_status: FieldRef<"Subscription", 'RenewalStatus'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.sharedAccounts
   */
  export type Subscription$sharedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    where?: SharedAccountWhereInput
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    cursor?: SharedAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAccountScalarFieldEnum | SharedAccountScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SharedAccount
   */

  export type AggregateSharedAccount = {
    _count: SharedAccountCountAggregateOutputType | null
    _min: SharedAccountMinAggregateOutputType | null
    _max: SharedAccountMaxAggregateOutputType | null
  }

  export type SharedAccountMinAggregateOutputType = {
    id: string | null
    ownerUserId: string | null
    sharedUserId: string | null
    subscriptionId: string | null
    shared_on: Date | null
    status: $Enums.SharedAccountStatus | null
    is_active: boolean | null
  }

  export type SharedAccountMaxAggregateOutputType = {
    id: string | null
    ownerUserId: string | null
    sharedUserId: string | null
    subscriptionId: string | null
    shared_on: Date | null
    status: $Enums.SharedAccountStatus | null
    is_active: boolean | null
  }

  export type SharedAccountCountAggregateOutputType = {
    id: number
    ownerUserId: number
    sharedUserId: number
    subscriptionId: number
    shared_on: number
    status: number
    is_active: number
    _all: number
  }


  export type SharedAccountMinAggregateInputType = {
    id?: true
    ownerUserId?: true
    sharedUserId?: true
    subscriptionId?: true
    shared_on?: true
    status?: true
    is_active?: true
  }

  export type SharedAccountMaxAggregateInputType = {
    id?: true
    ownerUserId?: true
    sharedUserId?: true
    subscriptionId?: true
    shared_on?: true
    status?: true
    is_active?: true
  }

  export type SharedAccountCountAggregateInputType = {
    id?: true
    ownerUserId?: true
    sharedUserId?: true
    subscriptionId?: true
    shared_on?: true
    status?: true
    is_active?: true
    _all?: true
  }

  export type SharedAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAccount to aggregate.
     */
    where?: SharedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccounts to fetch.
     */
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedAccounts
    **/
    _count?: true | SharedAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedAccountMaxAggregateInputType
  }

  export type GetSharedAccountAggregateType<T extends SharedAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedAccount[P]>
      : GetScalarType<T[P], AggregateSharedAccount[P]>
  }




  export type SharedAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountWhereInput
    orderBy?: SharedAccountOrderByWithAggregationInput | SharedAccountOrderByWithAggregationInput[]
    by: SharedAccountScalarFieldEnum[] | SharedAccountScalarFieldEnum
    having?: SharedAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedAccountCountAggregateInputType | true
    _min?: SharedAccountMinAggregateInputType
    _max?: SharedAccountMaxAggregateInputType
  }

  export type SharedAccountGroupByOutputType = {
    id: string
    ownerUserId: string
    sharedUserId: string | null
    subscriptionId: string
    shared_on: Date
    status: $Enums.SharedAccountStatus
    is_active: boolean
    _count: SharedAccountCountAggregateOutputType | null
    _min: SharedAccountMinAggregateOutputType | null
    _max: SharedAccountMaxAggregateOutputType | null
  }

  type GetSharedAccountGroupByPayload<T extends SharedAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SharedAccountGroupByOutputType[P]>
        }
      >
    >


  export type SharedAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerUserId?: boolean
    sharedUserId?: boolean
    subscriptionId?: boolean
    shared_on?: boolean
    status?: boolean
    is_active?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    sharedUser?: boolean | SharedAccount$sharedUserArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    profiles?: boolean | SharedAccount$profilesArgs<ExtArgs>
    _count?: boolean | SharedAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccount"]>

  export type SharedAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerUserId?: boolean
    sharedUserId?: boolean
    subscriptionId?: boolean
    shared_on?: boolean
    status?: boolean
    is_active?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    sharedUser?: boolean | SharedAccount$sharedUserArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccount"]>

  export type SharedAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerUserId?: boolean
    sharedUserId?: boolean
    subscriptionId?: boolean
    shared_on?: boolean
    status?: boolean
    is_active?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    sharedUser?: boolean | SharedAccount$sharedUserArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccount"]>

  export type SharedAccountSelectScalar = {
    id?: boolean
    ownerUserId?: boolean
    sharedUserId?: boolean
    subscriptionId?: boolean
    shared_on?: boolean
    status?: boolean
    is_active?: boolean
  }

  export type SharedAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerUserId" | "sharedUserId" | "subscriptionId" | "shared_on" | "status" | "is_active", ExtArgs["result"]["sharedAccount"]>
  export type SharedAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    sharedUser?: boolean | SharedAccount$sharedUserArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    profiles?: boolean | SharedAccount$profilesArgs<ExtArgs>
    _count?: boolean | SharedAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SharedAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    sharedUser?: boolean | SharedAccount$sharedUserArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SharedAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    sharedUser?: boolean | SharedAccount$sharedUserArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $SharedAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedAccount"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      sharedUser: Prisma.$UserPayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
      profiles: Prisma.$SharedAccountUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerUserId: string
      sharedUserId: string | null
      subscriptionId: string
      shared_on: Date
      status: $Enums.SharedAccountStatus
      is_active: boolean
    }, ExtArgs["result"]["sharedAccount"]>
    composites: {}
  }

  type SharedAccountGetPayload<S extends boolean | null | undefined | SharedAccountDefaultArgs> = $Result.GetResult<Prisma.$SharedAccountPayload, S>

  type SharedAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedAccountCountAggregateInputType | true
    }

  export interface SharedAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedAccount'], meta: { name: 'SharedAccount' } }
    /**
     * Find zero or one SharedAccount that matches the filter.
     * @param {SharedAccountFindUniqueArgs} args - Arguments to find a SharedAccount
     * @example
     * // Get one SharedAccount
     * const sharedAccount = await prisma.sharedAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedAccountFindUniqueArgs>(args: SelectSubset<T, SharedAccountFindUniqueArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedAccountFindUniqueOrThrowArgs} args - Arguments to find a SharedAccount
     * @example
     * // Get one SharedAccount
     * const sharedAccount = await prisma.sharedAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountFindFirstArgs} args - Arguments to find a SharedAccount
     * @example
     * // Get one SharedAccount
     * const sharedAccount = await prisma.sharedAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedAccountFindFirstArgs>(args?: SelectSubset<T, SharedAccountFindFirstArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountFindFirstOrThrowArgs} args - Arguments to find a SharedAccount
     * @example
     * // Get one SharedAccount
     * const sharedAccount = await prisma.sharedAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedAccounts
     * const sharedAccounts = await prisma.sharedAccount.findMany()
     * 
     * // Get first 10 SharedAccounts
     * const sharedAccounts = await prisma.sharedAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedAccountWithIdOnly = await prisma.sharedAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedAccountFindManyArgs>(args?: SelectSubset<T, SharedAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedAccount.
     * @param {SharedAccountCreateArgs} args - Arguments to create a SharedAccount.
     * @example
     * // Create one SharedAccount
     * const SharedAccount = await prisma.sharedAccount.create({
     *   data: {
     *     // ... data to create a SharedAccount
     *   }
     * })
     * 
     */
    create<T extends SharedAccountCreateArgs>(args: SelectSubset<T, SharedAccountCreateArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedAccounts.
     * @param {SharedAccountCreateManyArgs} args - Arguments to create many SharedAccounts.
     * @example
     * // Create many SharedAccounts
     * const sharedAccount = await prisma.sharedAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedAccountCreateManyArgs>(args?: SelectSubset<T, SharedAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedAccounts and returns the data saved in the database.
     * @param {SharedAccountCreateManyAndReturnArgs} args - Arguments to create many SharedAccounts.
     * @example
     * // Create many SharedAccounts
     * const sharedAccount = await prisma.sharedAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedAccounts and only return the `id`
     * const sharedAccountWithIdOnly = await prisma.sharedAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedAccount.
     * @param {SharedAccountDeleteArgs} args - Arguments to delete one SharedAccount.
     * @example
     * // Delete one SharedAccount
     * const SharedAccount = await prisma.sharedAccount.delete({
     *   where: {
     *     // ... filter to delete one SharedAccount
     *   }
     * })
     * 
     */
    delete<T extends SharedAccountDeleteArgs>(args: SelectSubset<T, SharedAccountDeleteArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedAccount.
     * @param {SharedAccountUpdateArgs} args - Arguments to update one SharedAccount.
     * @example
     * // Update one SharedAccount
     * const sharedAccount = await prisma.sharedAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedAccountUpdateArgs>(args: SelectSubset<T, SharedAccountUpdateArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedAccounts.
     * @param {SharedAccountDeleteManyArgs} args - Arguments to filter SharedAccounts to delete.
     * @example
     * // Delete a few SharedAccounts
     * const { count } = await prisma.sharedAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedAccountDeleteManyArgs>(args?: SelectSubset<T, SharedAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedAccounts
     * const sharedAccount = await prisma.sharedAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedAccountUpdateManyArgs>(args: SelectSubset<T, SharedAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAccounts and returns the data updated in the database.
     * @param {SharedAccountUpdateManyAndReturnArgs} args - Arguments to update many SharedAccounts.
     * @example
     * // Update many SharedAccounts
     * const sharedAccount = await prisma.sharedAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedAccounts and only return the `id`
     * const sharedAccountWithIdOnly = await prisma.sharedAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedAccount.
     * @param {SharedAccountUpsertArgs} args - Arguments to update or create a SharedAccount.
     * @example
     * // Update or create a SharedAccount
     * const sharedAccount = await prisma.sharedAccount.upsert({
     *   create: {
     *     // ... data to create a SharedAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedAccount we want to update
     *   }
     * })
     */
    upsert<T extends SharedAccountUpsertArgs>(args: SelectSubset<T, SharedAccountUpsertArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountCountArgs} args - Arguments to filter SharedAccounts to count.
     * @example
     * // Count the number of SharedAccounts
     * const count = await prisma.sharedAccount.count({
     *   where: {
     *     // ... the filter for the SharedAccounts we want to count
     *   }
     * })
    **/
    count<T extends SharedAccountCountArgs>(
      args?: Subset<T, SharedAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedAccountAggregateArgs>(args: Subset<T, SharedAccountAggregateArgs>): Prisma.PrismaPromise<GetSharedAccountAggregateType<T>>

    /**
     * Group by SharedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedAccountGroupByArgs['orderBy'] }
        : { orderBy?: SharedAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedAccount model
   */
  readonly fields: SharedAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sharedUser<T extends SharedAccount$sharedUserArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccount$sharedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profiles<T extends SharedAccount$profilesArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccount$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedAccount model
   */
  interface SharedAccountFieldRefs {
    readonly id: FieldRef<"SharedAccount", 'String'>
    readonly ownerUserId: FieldRef<"SharedAccount", 'String'>
    readonly sharedUserId: FieldRef<"SharedAccount", 'String'>
    readonly subscriptionId: FieldRef<"SharedAccount", 'String'>
    readonly shared_on: FieldRef<"SharedAccount", 'DateTime'>
    readonly status: FieldRef<"SharedAccount", 'SharedAccountStatus'>
    readonly is_active: FieldRef<"SharedAccount", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SharedAccount findUnique
   */
  export type SharedAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccount to fetch.
     */
    where: SharedAccountWhereUniqueInput
  }

  /**
   * SharedAccount findUniqueOrThrow
   */
  export type SharedAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccount to fetch.
     */
    where: SharedAccountWhereUniqueInput
  }

  /**
   * SharedAccount findFirst
   */
  export type SharedAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccount to fetch.
     */
    where?: SharedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccounts to fetch.
     */
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAccounts.
     */
    cursor?: SharedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAccounts.
     */
    distinct?: SharedAccountScalarFieldEnum | SharedAccountScalarFieldEnum[]
  }

  /**
   * SharedAccount findFirstOrThrow
   */
  export type SharedAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccount to fetch.
     */
    where?: SharedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccounts to fetch.
     */
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAccounts.
     */
    cursor?: SharedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAccounts.
     */
    distinct?: SharedAccountScalarFieldEnum | SharedAccountScalarFieldEnum[]
  }

  /**
   * SharedAccount findMany
   */
  export type SharedAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccounts to fetch.
     */
    where?: SharedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccounts to fetch.
     */
    orderBy?: SharedAccountOrderByWithRelationInput | SharedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedAccounts.
     */
    cursor?: SharedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccounts.
     */
    skip?: number
    distinct?: SharedAccountScalarFieldEnum | SharedAccountScalarFieldEnum[]
  }

  /**
   * SharedAccount create
   */
  export type SharedAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedAccount.
     */
    data: XOR<SharedAccountCreateInput, SharedAccountUncheckedCreateInput>
  }

  /**
   * SharedAccount createMany
   */
  export type SharedAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedAccounts.
     */
    data: SharedAccountCreateManyInput | SharedAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedAccount createManyAndReturn
   */
  export type SharedAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SharedAccounts.
     */
    data: SharedAccountCreateManyInput | SharedAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAccount update
   */
  export type SharedAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedAccount.
     */
    data: XOR<SharedAccountUpdateInput, SharedAccountUncheckedUpdateInput>
    /**
     * Choose, which SharedAccount to update.
     */
    where: SharedAccountWhereUniqueInput
  }

  /**
   * SharedAccount updateMany
   */
  export type SharedAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedAccounts.
     */
    data: XOR<SharedAccountUpdateManyMutationInput, SharedAccountUncheckedUpdateManyInput>
    /**
     * Filter which SharedAccounts to update
     */
    where?: SharedAccountWhereInput
    /**
     * Limit how many SharedAccounts to update.
     */
    limit?: number
  }

  /**
   * SharedAccount updateManyAndReturn
   */
  export type SharedAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * The data used to update SharedAccounts.
     */
    data: XOR<SharedAccountUpdateManyMutationInput, SharedAccountUncheckedUpdateManyInput>
    /**
     * Filter which SharedAccounts to update
     */
    where?: SharedAccountWhereInput
    /**
     * Limit how many SharedAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAccount upsert
   */
  export type SharedAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedAccount to update in case it exists.
     */
    where: SharedAccountWhereUniqueInput
    /**
     * In case the SharedAccount found by the `where` argument doesn't exist, create a new SharedAccount with this data.
     */
    create: XOR<SharedAccountCreateInput, SharedAccountUncheckedCreateInput>
    /**
     * In case the SharedAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedAccountUpdateInput, SharedAccountUncheckedUpdateInput>
  }

  /**
   * SharedAccount delete
   */
  export type SharedAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
    /**
     * Filter which SharedAccount to delete.
     */
    where: SharedAccountWhereUniqueInput
  }

  /**
   * SharedAccount deleteMany
   */
  export type SharedAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAccounts to delete
     */
    where?: SharedAccountWhereInput
    /**
     * Limit how many SharedAccounts to delete.
     */
    limit?: number
  }

  /**
   * SharedAccount.sharedUser
   */
  export type SharedAccount$sharedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SharedAccount.profiles
   */
  export type SharedAccount$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    where?: SharedAccountUserWhereInput
    orderBy?: SharedAccountUserOrderByWithRelationInput | SharedAccountUserOrderByWithRelationInput[]
    cursor?: SharedAccountUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAccountUserScalarFieldEnum | SharedAccountUserScalarFieldEnum[]
  }

  /**
   * SharedAccount without action
   */
  export type SharedAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccount
     */
    select?: SharedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccount
     */
    omit?: SharedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountInclude<ExtArgs> | null
  }


  /**
   * Model SharedAccountUser
   */

  export type AggregateSharedAccountUser = {
    _count: SharedAccountUserCountAggregateOutputType | null
    _min: SharedAccountUserMinAggregateOutputType | null
    _max: SharedAccountUserMaxAggregateOutputType | null
  }

  export type SharedAccountUserMinAggregateOutputType = {
    id: string | null
    sharedAccountId: string | null
    userId: string | null
    profile_name: string | null
    is_kid_profile: boolean | null
    avatar_url: string | null
    pin_code: string | null
    created_at: Date | null
  }

  export type SharedAccountUserMaxAggregateOutputType = {
    id: string | null
    sharedAccountId: string | null
    userId: string | null
    profile_name: string | null
    is_kid_profile: boolean | null
    avatar_url: string | null
    pin_code: string | null
    created_at: Date | null
  }

  export type SharedAccountUserCountAggregateOutputType = {
    id: number
    sharedAccountId: number
    userId: number
    profile_name: number
    is_kid_profile: number
    avatar_url: number
    pin_code: number
    created_at: number
    _all: number
  }


  export type SharedAccountUserMinAggregateInputType = {
    id?: true
    sharedAccountId?: true
    userId?: true
    profile_name?: true
    is_kid_profile?: true
    avatar_url?: true
    pin_code?: true
    created_at?: true
  }

  export type SharedAccountUserMaxAggregateInputType = {
    id?: true
    sharedAccountId?: true
    userId?: true
    profile_name?: true
    is_kid_profile?: true
    avatar_url?: true
    pin_code?: true
    created_at?: true
  }

  export type SharedAccountUserCountAggregateInputType = {
    id?: true
    sharedAccountId?: true
    userId?: true
    profile_name?: true
    is_kid_profile?: true
    avatar_url?: true
    pin_code?: true
    created_at?: true
    _all?: true
  }

  export type SharedAccountUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAccountUser to aggregate.
     */
    where?: SharedAccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccountUsers to fetch.
     */
    orderBy?: SharedAccountUserOrderByWithRelationInput | SharedAccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedAccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccountUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedAccountUsers
    **/
    _count?: true | SharedAccountUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedAccountUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedAccountUserMaxAggregateInputType
  }

  export type GetSharedAccountUserAggregateType<T extends SharedAccountUserAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedAccountUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedAccountUser[P]>
      : GetScalarType<T[P], AggregateSharedAccountUser[P]>
  }




  export type SharedAccountUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAccountUserWhereInput
    orderBy?: SharedAccountUserOrderByWithAggregationInput | SharedAccountUserOrderByWithAggregationInput[]
    by: SharedAccountUserScalarFieldEnum[] | SharedAccountUserScalarFieldEnum
    having?: SharedAccountUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedAccountUserCountAggregateInputType | true
    _min?: SharedAccountUserMinAggregateInputType
    _max?: SharedAccountUserMaxAggregateInputType
  }

  export type SharedAccountUserGroupByOutputType = {
    id: string
    sharedAccountId: string
    userId: string
    profile_name: string
    is_kid_profile: boolean
    avatar_url: string | null
    pin_code: string | null
    created_at: Date
    _count: SharedAccountUserCountAggregateOutputType | null
    _min: SharedAccountUserMinAggregateOutputType | null
    _max: SharedAccountUserMaxAggregateOutputType | null
  }

  type GetSharedAccountUserGroupByPayload<T extends SharedAccountUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedAccountUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedAccountUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedAccountUserGroupByOutputType[P]>
            : GetScalarType<T[P], SharedAccountUserGroupByOutputType[P]>
        }
      >
    >


  export type SharedAccountUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sharedAccountId?: boolean
    userId?: boolean
    profile_name?: boolean
    is_kid_profile?: boolean
    avatar_url?: boolean
    pin_code?: boolean
    created_at?: boolean
    sharedAccount?: boolean | SharedAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    views?: boolean | SharedAccountUser$viewsArgs<ExtArgs>
    adViews?: boolean | SharedAccountUser$adViewsArgs<ExtArgs>
    activities?: boolean | SharedAccountUser$activitiesArgs<ExtArgs>
    _count?: boolean | SharedAccountUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccountUser"]>

  export type SharedAccountUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sharedAccountId?: boolean
    userId?: boolean
    profile_name?: boolean
    is_kid_profile?: boolean
    avatar_url?: boolean
    pin_code?: boolean
    created_at?: boolean
    sharedAccount?: boolean | SharedAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccountUser"]>

  export type SharedAccountUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sharedAccountId?: boolean
    userId?: boolean
    profile_name?: boolean
    is_kid_profile?: boolean
    avatar_url?: boolean
    pin_code?: boolean
    created_at?: boolean
    sharedAccount?: boolean | SharedAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAccountUser"]>

  export type SharedAccountUserSelectScalar = {
    id?: boolean
    sharedAccountId?: boolean
    userId?: boolean
    profile_name?: boolean
    is_kid_profile?: boolean
    avatar_url?: boolean
    pin_code?: boolean
    created_at?: boolean
  }

  export type SharedAccountUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sharedAccountId" | "userId" | "profile_name" | "is_kid_profile" | "avatar_url" | "pin_code" | "created_at", ExtArgs["result"]["sharedAccountUser"]>
  export type SharedAccountUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedAccount?: boolean | SharedAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    views?: boolean | SharedAccountUser$viewsArgs<ExtArgs>
    adViews?: boolean | SharedAccountUser$adViewsArgs<ExtArgs>
    activities?: boolean | SharedAccountUser$activitiesArgs<ExtArgs>
    _count?: boolean | SharedAccountUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SharedAccountUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedAccount?: boolean | SharedAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SharedAccountUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedAccount?: boolean | SharedAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SharedAccountUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedAccountUser"
    objects: {
      sharedAccount: Prisma.$SharedAccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      views: Prisma.$ViewPayload<ExtArgs>[]
      adViews: Prisma.$AdViewPayload<ExtArgs>[]
      activities: Prisma.$SharedProfileActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sharedAccountId: string
      userId: string
      profile_name: string
      is_kid_profile: boolean
      avatar_url: string | null
      pin_code: string | null
      created_at: Date
    }, ExtArgs["result"]["sharedAccountUser"]>
    composites: {}
  }

  type SharedAccountUserGetPayload<S extends boolean | null | undefined | SharedAccountUserDefaultArgs> = $Result.GetResult<Prisma.$SharedAccountUserPayload, S>

  type SharedAccountUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedAccountUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedAccountUserCountAggregateInputType | true
    }

  export interface SharedAccountUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedAccountUser'], meta: { name: 'SharedAccountUser' } }
    /**
     * Find zero or one SharedAccountUser that matches the filter.
     * @param {SharedAccountUserFindUniqueArgs} args - Arguments to find a SharedAccountUser
     * @example
     * // Get one SharedAccountUser
     * const sharedAccountUser = await prisma.sharedAccountUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedAccountUserFindUniqueArgs>(args: SelectSubset<T, SharedAccountUserFindUniqueArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedAccountUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedAccountUserFindUniqueOrThrowArgs} args - Arguments to find a SharedAccountUser
     * @example
     * // Get one SharedAccountUser
     * const sharedAccountUser = await prisma.sharedAccountUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedAccountUserFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedAccountUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAccountUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserFindFirstArgs} args - Arguments to find a SharedAccountUser
     * @example
     * // Get one SharedAccountUser
     * const sharedAccountUser = await prisma.sharedAccountUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedAccountUserFindFirstArgs>(args?: SelectSubset<T, SharedAccountUserFindFirstArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAccountUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserFindFirstOrThrowArgs} args - Arguments to find a SharedAccountUser
     * @example
     * // Get one SharedAccountUser
     * const sharedAccountUser = await prisma.sharedAccountUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedAccountUserFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedAccountUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedAccountUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedAccountUsers
     * const sharedAccountUsers = await prisma.sharedAccountUser.findMany()
     * 
     * // Get first 10 SharedAccountUsers
     * const sharedAccountUsers = await prisma.sharedAccountUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedAccountUserWithIdOnly = await prisma.sharedAccountUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedAccountUserFindManyArgs>(args?: SelectSubset<T, SharedAccountUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedAccountUser.
     * @param {SharedAccountUserCreateArgs} args - Arguments to create a SharedAccountUser.
     * @example
     * // Create one SharedAccountUser
     * const SharedAccountUser = await prisma.sharedAccountUser.create({
     *   data: {
     *     // ... data to create a SharedAccountUser
     *   }
     * })
     * 
     */
    create<T extends SharedAccountUserCreateArgs>(args: SelectSubset<T, SharedAccountUserCreateArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedAccountUsers.
     * @param {SharedAccountUserCreateManyArgs} args - Arguments to create many SharedAccountUsers.
     * @example
     * // Create many SharedAccountUsers
     * const sharedAccountUser = await prisma.sharedAccountUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedAccountUserCreateManyArgs>(args?: SelectSubset<T, SharedAccountUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedAccountUsers and returns the data saved in the database.
     * @param {SharedAccountUserCreateManyAndReturnArgs} args - Arguments to create many SharedAccountUsers.
     * @example
     * // Create many SharedAccountUsers
     * const sharedAccountUser = await prisma.sharedAccountUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedAccountUsers and only return the `id`
     * const sharedAccountUserWithIdOnly = await prisma.sharedAccountUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedAccountUserCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedAccountUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedAccountUser.
     * @param {SharedAccountUserDeleteArgs} args - Arguments to delete one SharedAccountUser.
     * @example
     * // Delete one SharedAccountUser
     * const SharedAccountUser = await prisma.sharedAccountUser.delete({
     *   where: {
     *     // ... filter to delete one SharedAccountUser
     *   }
     * })
     * 
     */
    delete<T extends SharedAccountUserDeleteArgs>(args: SelectSubset<T, SharedAccountUserDeleteArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedAccountUser.
     * @param {SharedAccountUserUpdateArgs} args - Arguments to update one SharedAccountUser.
     * @example
     * // Update one SharedAccountUser
     * const sharedAccountUser = await prisma.sharedAccountUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedAccountUserUpdateArgs>(args: SelectSubset<T, SharedAccountUserUpdateArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedAccountUsers.
     * @param {SharedAccountUserDeleteManyArgs} args - Arguments to filter SharedAccountUsers to delete.
     * @example
     * // Delete a few SharedAccountUsers
     * const { count } = await prisma.sharedAccountUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedAccountUserDeleteManyArgs>(args?: SelectSubset<T, SharedAccountUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedAccountUsers
     * const sharedAccountUser = await prisma.sharedAccountUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedAccountUserUpdateManyArgs>(args: SelectSubset<T, SharedAccountUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAccountUsers and returns the data updated in the database.
     * @param {SharedAccountUserUpdateManyAndReturnArgs} args - Arguments to update many SharedAccountUsers.
     * @example
     * // Update many SharedAccountUsers
     * const sharedAccountUser = await prisma.sharedAccountUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedAccountUsers and only return the `id`
     * const sharedAccountUserWithIdOnly = await prisma.sharedAccountUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedAccountUserUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedAccountUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedAccountUser.
     * @param {SharedAccountUserUpsertArgs} args - Arguments to update or create a SharedAccountUser.
     * @example
     * // Update or create a SharedAccountUser
     * const sharedAccountUser = await prisma.sharedAccountUser.upsert({
     *   create: {
     *     // ... data to create a SharedAccountUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedAccountUser we want to update
     *   }
     * })
     */
    upsert<T extends SharedAccountUserUpsertArgs>(args: SelectSubset<T, SharedAccountUserUpsertArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedAccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserCountArgs} args - Arguments to filter SharedAccountUsers to count.
     * @example
     * // Count the number of SharedAccountUsers
     * const count = await prisma.sharedAccountUser.count({
     *   where: {
     *     // ... the filter for the SharedAccountUsers we want to count
     *   }
     * })
    **/
    count<T extends SharedAccountUserCountArgs>(
      args?: Subset<T, SharedAccountUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedAccountUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedAccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedAccountUserAggregateArgs>(args: Subset<T, SharedAccountUserAggregateArgs>): Prisma.PrismaPromise<GetSharedAccountUserAggregateType<T>>

    /**
     * Group by SharedAccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAccountUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedAccountUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedAccountUserGroupByArgs['orderBy'] }
        : { orderBy?: SharedAccountUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedAccountUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedAccountUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedAccountUser model
   */
  readonly fields: SharedAccountUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedAccountUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedAccountUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sharedAccount<T extends SharedAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccountDefaultArgs<ExtArgs>>): Prisma__SharedAccountClient<$Result.GetResult<Prisma.$SharedAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    views<T extends SharedAccountUser$viewsArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccountUser$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adViews<T extends SharedAccountUser$adViewsArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccountUser$adViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends SharedAccountUser$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccountUser$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedAccountUser model
   */
  interface SharedAccountUserFieldRefs {
    readonly id: FieldRef<"SharedAccountUser", 'String'>
    readonly sharedAccountId: FieldRef<"SharedAccountUser", 'String'>
    readonly userId: FieldRef<"SharedAccountUser", 'String'>
    readonly profile_name: FieldRef<"SharedAccountUser", 'String'>
    readonly is_kid_profile: FieldRef<"SharedAccountUser", 'Boolean'>
    readonly avatar_url: FieldRef<"SharedAccountUser", 'String'>
    readonly pin_code: FieldRef<"SharedAccountUser", 'String'>
    readonly created_at: FieldRef<"SharedAccountUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedAccountUser findUnique
   */
  export type SharedAccountUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccountUser to fetch.
     */
    where: SharedAccountUserWhereUniqueInput
  }

  /**
   * SharedAccountUser findUniqueOrThrow
   */
  export type SharedAccountUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccountUser to fetch.
     */
    where: SharedAccountUserWhereUniqueInput
  }

  /**
   * SharedAccountUser findFirst
   */
  export type SharedAccountUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccountUser to fetch.
     */
    where?: SharedAccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccountUsers to fetch.
     */
    orderBy?: SharedAccountUserOrderByWithRelationInput | SharedAccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAccountUsers.
     */
    cursor?: SharedAccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccountUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAccountUsers.
     */
    distinct?: SharedAccountUserScalarFieldEnum | SharedAccountUserScalarFieldEnum[]
  }

  /**
   * SharedAccountUser findFirstOrThrow
   */
  export type SharedAccountUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccountUser to fetch.
     */
    where?: SharedAccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccountUsers to fetch.
     */
    orderBy?: SharedAccountUserOrderByWithRelationInput | SharedAccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAccountUsers.
     */
    cursor?: SharedAccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccountUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAccountUsers.
     */
    distinct?: SharedAccountUserScalarFieldEnum | SharedAccountUserScalarFieldEnum[]
  }

  /**
   * SharedAccountUser findMany
   */
  export type SharedAccountUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * Filter, which SharedAccountUsers to fetch.
     */
    where?: SharedAccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAccountUsers to fetch.
     */
    orderBy?: SharedAccountUserOrderByWithRelationInput | SharedAccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedAccountUsers.
     */
    cursor?: SharedAccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAccountUsers.
     */
    skip?: number
    distinct?: SharedAccountUserScalarFieldEnum | SharedAccountUserScalarFieldEnum[]
  }

  /**
   * SharedAccountUser create
   */
  export type SharedAccountUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedAccountUser.
     */
    data: XOR<SharedAccountUserCreateInput, SharedAccountUserUncheckedCreateInput>
  }

  /**
   * SharedAccountUser createMany
   */
  export type SharedAccountUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedAccountUsers.
     */
    data: SharedAccountUserCreateManyInput | SharedAccountUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedAccountUser createManyAndReturn
   */
  export type SharedAccountUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * The data used to create many SharedAccountUsers.
     */
    data: SharedAccountUserCreateManyInput | SharedAccountUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAccountUser update
   */
  export type SharedAccountUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedAccountUser.
     */
    data: XOR<SharedAccountUserUpdateInput, SharedAccountUserUncheckedUpdateInput>
    /**
     * Choose, which SharedAccountUser to update.
     */
    where: SharedAccountUserWhereUniqueInput
  }

  /**
   * SharedAccountUser updateMany
   */
  export type SharedAccountUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedAccountUsers.
     */
    data: XOR<SharedAccountUserUpdateManyMutationInput, SharedAccountUserUncheckedUpdateManyInput>
    /**
     * Filter which SharedAccountUsers to update
     */
    where?: SharedAccountUserWhereInput
    /**
     * Limit how many SharedAccountUsers to update.
     */
    limit?: number
  }

  /**
   * SharedAccountUser updateManyAndReturn
   */
  export type SharedAccountUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * The data used to update SharedAccountUsers.
     */
    data: XOR<SharedAccountUserUpdateManyMutationInput, SharedAccountUserUncheckedUpdateManyInput>
    /**
     * Filter which SharedAccountUsers to update
     */
    where?: SharedAccountUserWhereInput
    /**
     * Limit how many SharedAccountUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAccountUser upsert
   */
  export type SharedAccountUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedAccountUser to update in case it exists.
     */
    where: SharedAccountUserWhereUniqueInput
    /**
     * In case the SharedAccountUser found by the `where` argument doesn't exist, create a new SharedAccountUser with this data.
     */
    create: XOR<SharedAccountUserCreateInput, SharedAccountUserUncheckedCreateInput>
    /**
     * In case the SharedAccountUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedAccountUserUpdateInput, SharedAccountUserUncheckedUpdateInput>
  }

  /**
   * SharedAccountUser delete
   */
  export type SharedAccountUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    /**
     * Filter which SharedAccountUser to delete.
     */
    where: SharedAccountUserWhereUniqueInput
  }

  /**
   * SharedAccountUser deleteMany
   */
  export type SharedAccountUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAccountUsers to delete
     */
    where?: SharedAccountUserWhereInput
    /**
     * Limit how many SharedAccountUsers to delete.
     */
    limit?: number
  }

  /**
   * SharedAccountUser.views
   */
  export type SharedAccountUser$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    where?: ViewWhereInput
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    cursor?: ViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewScalarFieldEnum | ViewScalarFieldEnum[]
  }

  /**
   * SharedAccountUser.adViews
   */
  export type SharedAccountUser$adViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    where?: AdViewWhereInput
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    cursor?: AdViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdViewScalarFieldEnum | AdViewScalarFieldEnum[]
  }

  /**
   * SharedAccountUser.activities
   */
  export type SharedAccountUser$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    where?: SharedProfileActivityWhereInput
    orderBy?: SharedProfileActivityOrderByWithRelationInput | SharedProfileActivityOrderByWithRelationInput[]
    cursor?: SharedProfileActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedProfileActivityScalarFieldEnum | SharedProfileActivityScalarFieldEnum[]
  }

  /**
   * SharedAccountUser without action
   */
  export type SharedAccountUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
  }


  /**
   * Model VideoMetadata
   */

  export type AggregateVideoMetadata = {
    _count: VideoMetadataCountAggregateOutputType | null
    _min: VideoMetadataMinAggregateOutputType | null
    _max: VideoMetadataMaxAggregateOutputType | null
  }

  export type VideoMetadataMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnailUrl: string | null
    secondaryImage: string | null
    releaseDate: Date | null
    platformDate: Date | null
    ageRating: string | null
    productionHouse: string | null
    productionCountry: string | null
    director: string | null
    formatId: string | null
    categoryId: string | null
    status: string | null
  }

  export type VideoMetadataMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnailUrl: string | null
    secondaryImage: string | null
    releaseDate: Date | null
    platformDate: Date | null
    ageRating: string | null
    productionHouse: string | null
    productionCountry: string | null
    director: string | null
    formatId: string | null
    categoryId: string | null
    status: string | null
  }

  export type VideoMetadataCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnailUrl: number
    secondaryImage: number
    releaseDate: number
    platformDate: number
    ageRating: number
    productionHouse: number
    productionCountry: number
    director: number
    formatId: number
    categoryId: number
    status: number
    _all: number
  }


  export type VideoMetadataMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnailUrl?: true
    secondaryImage?: true
    releaseDate?: true
    platformDate?: true
    ageRating?: true
    productionHouse?: true
    productionCountry?: true
    director?: true
    formatId?: true
    categoryId?: true
    status?: true
  }

  export type VideoMetadataMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnailUrl?: true
    secondaryImage?: true
    releaseDate?: true
    platformDate?: true
    ageRating?: true
    productionHouse?: true
    productionCountry?: true
    director?: true
    formatId?: true
    categoryId?: true
    status?: true
  }

  export type VideoMetadataCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnailUrl?: true
    secondaryImage?: true
    releaseDate?: true
    platformDate?: true
    ageRating?: true
    productionHouse?: true
    productionCountry?: true
    director?: true
    formatId?: true
    categoryId?: true
    status?: true
    _all?: true
  }

  export type VideoMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoMetadata to aggregate.
     */
    where?: VideoMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMetadata to fetch.
     */
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoMetadata
    **/
    _count?: true | VideoMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMetadataMaxAggregateInputType
  }

  export type GetVideoMetadataAggregateType<T extends VideoMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoMetadata[P]>
      : GetScalarType<T[P], AggregateVideoMetadata[P]>
  }




  export type VideoMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMetadataWhereInput
    orderBy?: VideoMetadataOrderByWithAggregationInput | VideoMetadataOrderByWithAggregationInput[]
    by: VideoMetadataScalarFieldEnum[] | VideoMetadataScalarFieldEnum
    having?: VideoMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoMetadataCountAggregateInputType | true
    _min?: VideoMetadataMinAggregateInputType
    _max?: VideoMetadataMaxAggregateInputType
  }

  export type VideoMetadataGroupByOutputType = {
    id: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage: string | null
    releaseDate: Date
    platformDate: Date
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status: string
    _count: VideoMetadataCountAggregateOutputType | null
    _min: VideoMetadataMinAggregateOutputType | null
    _max: VideoMetadataMaxAggregateOutputType | null
  }

  type GetVideoMetadataGroupByPayload<T extends VideoMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], VideoMetadataGroupByOutputType[P]>
        }
      >
    >


  export type VideoMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    secondaryImage?: boolean
    releaseDate?: boolean
    platformDate?: boolean
    ageRating?: boolean
    productionHouse?: boolean
    productionCountry?: boolean
    director?: boolean
    formatId?: boolean
    categoryId?: boolean
    status?: boolean
    format?: boolean | VideoFormatDefaultArgs<ExtArgs>
    category?: boolean | VideoCategoryDefaultArgs<ExtArgs>
    movie?: boolean | VideoMetadata$movieArgs<ExtArgs>
    episode?: boolean | VideoMetadata$episodeArgs<ExtArgs>
    series?: boolean | VideoMetadata$seriesArgs<ExtArgs>
    genres?: boolean | VideoMetadata$genresArgs<ExtArgs>
    actors?: boolean | VideoMetadata$actorsArgs<ExtArgs>
    subtitles?: boolean | VideoMetadata$subtitlesArgs<ExtArgs>
    languages?: boolean | VideoMetadata$languagesArgs<ExtArgs>
    _count?: boolean | VideoMetadataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoMetadata"]>

  export type VideoMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    secondaryImage?: boolean
    releaseDate?: boolean
    platformDate?: boolean
    ageRating?: boolean
    productionHouse?: boolean
    productionCountry?: boolean
    director?: boolean
    formatId?: boolean
    categoryId?: boolean
    status?: boolean
    format?: boolean | VideoFormatDefaultArgs<ExtArgs>
    category?: boolean | VideoCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoMetadata"]>

  export type VideoMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    secondaryImage?: boolean
    releaseDate?: boolean
    platformDate?: boolean
    ageRating?: boolean
    productionHouse?: boolean
    productionCountry?: boolean
    director?: boolean
    formatId?: boolean
    categoryId?: boolean
    status?: boolean
    format?: boolean | VideoFormatDefaultArgs<ExtArgs>
    category?: boolean | VideoCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoMetadata"]>

  export type VideoMetadataSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    secondaryImage?: boolean
    releaseDate?: boolean
    platformDate?: boolean
    ageRating?: boolean
    productionHouse?: boolean
    productionCountry?: boolean
    director?: boolean
    formatId?: boolean
    categoryId?: boolean
    status?: boolean
  }

  export type VideoMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnailUrl" | "secondaryImage" | "releaseDate" | "platformDate" | "ageRating" | "productionHouse" | "productionCountry" | "director" | "formatId" | "categoryId" | "status", ExtArgs["result"]["videoMetadata"]>
  export type VideoMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | VideoFormatDefaultArgs<ExtArgs>
    category?: boolean | VideoCategoryDefaultArgs<ExtArgs>
    movie?: boolean | VideoMetadata$movieArgs<ExtArgs>
    episode?: boolean | VideoMetadata$episodeArgs<ExtArgs>
    series?: boolean | VideoMetadata$seriesArgs<ExtArgs>
    genres?: boolean | VideoMetadata$genresArgs<ExtArgs>
    actors?: boolean | VideoMetadata$actorsArgs<ExtArgs>
    subtitles?: boolean | VideoMetadata$subtitlesArgs<ExtArgs>
    languages?: boolean | VideoMetadata$languagesArgs<ExtArgs>
    _count?: boolean | VideoMetadataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | VideoFormatDefaultArgs<ExtArgs>
    category?: boolean | VideoCategoryDefaultArgs<ExtArgs>
  }
  export type VideoMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | VideoFormatDefaultArgs<ExtArgs>
    category?: boolean | VideoCategoryDefaultArgs<ExtArgs>
  }

  export type $VideoMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoMetadata"
    objects: {
      format: Prisma.$VideoFormatPayload<ExtArgs>
      category: Prisma.$VideoCategoryPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs> | null
      episode: Prisma.$EpisodePayload<ExtArgs> | null
      series: Prisma.$SeriesPayload<ExtArgs> | null
      genres: Prisma.$VideoGenrePayload<ExtArgs>[]
      actors: Prisma.$VideoActorPayload<ExtArgs>[]
      subtitles: Prisma.$SubtitlePayload<ExtArgs>[]
      languages: Prisma.$VideoLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      thumbnailUrl: string
      secondaryImage: string | null
      releaseDate: Date
      platformDate: Date
      ageRating: string
      productionHouse: string
      productionCountry: string
      director: string
      formatId: string
      categoryId: string
      status: string
    }, ExtArgs["result"]["videoMetadata"]>
    composites: {}
  }

  type VideoMetadataGetPayload<S extends boolean | null | undefined | VideoMetadataDefaultArgs> = $Result.GetResult<Prisma.$VideoMetadataPayload, S>

  type VideoMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoMetadataCountAggregateInputType | true
    }

  export interface VideoMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoMetadata'], meta: { name: 'VideoMetadata' } }
    /**
     * Find zero or one VideoMetadata that matches the filter.
     * @param {VideoMetadataFindUniqueArgs} args - Arguments to find a VideoMetadata
     * @example
     * // Get one VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoMetadataFindUniqueArgs>(args: SelectSubset<T, VideoMetadataFindUniqueArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoMetadataFindUniqueOrThrowArgs} args - Arguments to find a VideoMetadata
     * @example
     * // Get one VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataFindFirstArgs} args - Arguments to find a VideoMetadata
     * @example
     * // Get one VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoMetadataFindFirstArgs>(args?: SelectSubset<T, VideoMetadataFindFirstArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataFindFirstOrThrowArgs} args - Arguments to find a VideoMetadata
     * @example
     * // Get one VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.findMany()
     * 
     * // Get first 10 VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoMetadataWithIdOnly = await prisma.videoMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoMetadataFindManyArgs>(args?: SelectSubset<T, VideoMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoMetadata.
     * @param {VideoMetadataCreateArgs} args - Arguments to create a VideoMetadata.
     * @example
     * // Create one VideoMetadata
     * const VideoMetadata = await prisma.videoMetadata.create({
     *   data: {
     *     // ... data to create a VideoMetadata
     *   }
     * })
     * 
     */
    create<T extends VideoMetadataCreateArgs>(args: SelectSubset<T, VideoMetadataCreateArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoMetadata.
     * @param {VideoMetadataCreateManyArgs} args - Arguments to create many VideoMetadata.
     * @example
     * // Create many VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoMetadataCreateManyArgs>(args?: SelectSubset<T, VideoMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoMetadata and returns the data saved in the database.
     * @param {VideoMetadataCreateManyAndReturnArgs} args - Arguments to create many VideoMetadata.
     * @example
     * // Create many VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoMetadata and only return the `id`
     * const videoMetadataWithIdOnly = await prisma.videoMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoMetadata.
     * @param {VideoMetadataDeleteArgs} args - Arguments to delete one VideoMetadata.
     * @example
     * // Delete one VideoMetadata
     * const VideoMetadata = await prisma.videoMetadata.delete({
     *   where: {
     *     // ... filter to delete one VideoMetadata
     *   }
     * })
     * 
     */
    delete<T extends VideoMetadataDeleteArgs>(args: SelectSubset<T, VideoMetadataDeleteArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoMetadata.
     * @param {VideoMetadataUpdateArgs} args - Arguments to update one VideoMetadata.
     * @example
     * // Update one VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoMetadataUpdateArgs>(args: SelectSubset<T, VideoMetadataUpdateArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoMetadata.
     * @param {VideoMetadataDeleteManyArgs} args - Arguments to filter VideoMetadata to delete.
     * @example
     * // Delete a few VideoMetadata
     * const { count } = await prisma.videoMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoMetadataDeleteManyArgs>(args?: SelectSubset<T, VideoMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoMetadataUpdateManyArgs>(args: SelectSubset<T, VideoMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoMetadata and returns the data updated in the database.
     * @param {VideoMetadataUpdateManyAndReturnArgs} args - Arguments to update many VideoMetadata.
     * @example
     * // Update many VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoMetadata and only return the `id`
     * const videoMetadataWithIdOnly = await prisma.videoMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoMetadata.
     * @param {VideoMetadataUpsertArgs} args - Arguments to update or create a VideoMetadata.
     * @example
     * // Update or create a VideoMetadata
     * const videoMetadata = await prisma.videoMetadata.upsert({
     *   create: {
     *     // ... data to create a VideoMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoMetadata we want to update
     *   }
     * })
     */
    upsert<T extends VideoMetadataUpsertArgs>(args: SelectSubset<T, VideoMetadataUpsertArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataCountArgs} args - Arguments to filter VideoMetadata to count.
     * @example
     * // Count the number of VideoMetadata
     * const count = await prisma.videoMetadata.count({
     *   where: {
     *     // ... the filter for the VideoMetadata we want to count
     *   }
     * })
    **/
    count<T extends VideoMetadataCountArgs>(
      args?: Subset<T, VideoMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoMetadataAggregateArgs>(args: Subset<T, VideoMetadataAggregateArgs>): Prisma.PrismaPromise<GetVideoMetadataAggregateType<T>>

    /**
     * Group by VideoMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoMetadataGroupByArgs['orderBy'] }
        : { orderBy?: VideoMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoMetadata model
   */
  readonly fields: VideoMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    format<T extends VideoFormatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFormatDefaultArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends VideoCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoCategoryDefaultArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movie<T extends VideoMetadata$movieArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$movieArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    episode<T extends VideoMetadata$episodeArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$episodeArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    series<T extends VideoMetadata$seriesArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$seriesArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    genres<T extends VideoMetadata$genresArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actors<T extends VideoMetadata$actorsArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$actorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subtitles<T extends VideoMetadata$subtitlesArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$subtitlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languages<T extends VideoMetadata$languagesArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadata$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoMetadata model
   */
  interface VideoMetadataFieldRefs {
    readonly id: FieldRef<"VideoMetadata", 'String'>
    readonly title: FieldRef<"VideoMetadata", 'String'>
    readonly description: FieldRef<"VideoMetadata", 'String'>
    readonly thumbnailUrl: FieldRef<"VideoMetadata", 'String'>
    readonly secondaryImage: FieldRef<"VideoMetadata", 'String'>
    readonly releaseDate: FieldRef<"VideoMetadata", 'DateTime'>
    readonly platformDate: FieldRef<"VideoMetadata", 'DateTime'>
    readonly ageRating: FieldRef<"VideoMetadata", 'String'>
    readonly productionHouse: FieldRef<"VideoMetadata", 'String'>
    readonly productionCountry: FieldRef<"VideoMetadata", 'String'>
    readonly director: FieldRef<"VideoMetadata", 'String'>
    readonly formatId: FieldRef<"VideoMetadata", 'String'>
    readonly categoryId: FieldRef<"VideoMetadata", 'String'>
    readonly status: FieldRef<"VideoMetadata", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoMetadata findUnique
   */
  export type VideoMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VideoMetadata to fetch.
     */
    where: VideoMetadataWhereUniqueInput
  }

  /**
   * VideoMetadata findUniqueOrThrow
   */
  export type VideoMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VideoMetadata to fetch.
     */
    where: VideoMetadataWhereUniqueInput
  }

  /**
   * VideoMetadata findFirst
   */
  export type VideoMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VideoMetadata to fetch.
     */
    where?: VideoMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMetadata to fetch.
     */
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoMetadata.
     */
    cursor?: VideoMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoMetadata.
     */
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoMetadata findFirstOrThrow
   */
  export type VideoMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VideoMetadata to fetch.
     */
    where?: VideoMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMetadata to fetch.
     */
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoMetadata.
     */
    cursor?: VideoMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoMetadata.
     */
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoMetadata findMany
   */
  export type VideoMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VideoMetadata to fetch.
     */
    where?: VideoMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMetadata to fetch.
     */
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoMetadata.
     */
    cursor?: VideoMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMetadata.
     */
    skip?: number
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoMetadata create
   */
  export type VideoMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoMetadata.
     */
    data: XOR<VideoMetadataCreateInput, VideoMetadataUncheckedCreateInput>
  }

  /**
   * VideoMetadata createMany
   */
  export type VideoMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoMetadata.
     */
    data: VideoMetadataCreateManyInput | VideoMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoMetadata createManyAndReturn
   */
  export type VideoMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many VideoMetadata.
     */
    data: VideoMetadataCreateManyInput | VideoMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoMetadata update
   */
  export type VideoMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoMetadata.
     */
    data: XOR<VideoMetadataUpdateInput, VideoMetadataUncheckedUpdateInput>
    /**
     * Choose, which VideoMetadata to update.
     */
    where: VideoMetadataWhereUniqueInput
  }

  /**
   * VideoMetadata updateMany
   */
  export type VideoMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoMetadata.
     */
    data: XOR<VideoMetadataUpdateManyMutationInput, VideoMetadataUncheckedUpdateManyInput>
    /**
     * Filter which VideoMetadata to update
     */
    where?: VideoMetadataWhereInput
    /**
     * Limit how many VideoMetadata to update.
     */
    limit?: number
  }

  /**
   * VideoMetadata updateManyAndReturn
   */
  export type VideoMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * The data used to update VideoMetadata.
     */
    data: XOR<VideoMetadataUpdateManyMutationInput, VideoMetadataUncheckedUpdateManyInput>
    /**
     * Filter which VideoMetadata to update
     */
    where?: VideoMetadataWhereInput
    /**
     * Limit how many VideoMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoMetadata upsert
   */
  export type VideoMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoMetadata to update in case it exists.
     */
    where: VideoMetadataWhereUniqueInput
    /**
     * In case the VideoMetadata found by the `where` argument doesn't exist, create a new VideoMetadata with this data.
     */
    create: XOR<VideoMetadataCreateInput, VideoMetadataUncheckedCreateInput>
    /**
     * In case the VideoMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoMetadataUpdateInput, VideoMetadataUncheckedUpdateInput>
  }

  /**
   * VideoMetadata delete
   */
  export type VideoMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    /**
     * Filter which VideoMetadata to delete.
     */
    where: VideoMetadataWhereUniqueInput
  }

  /**
   * VideoMetadata deleteMany
   */
  export type VideoMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoMetadata to delete
     */
    where?: VideoMetadataWhereInput
    /**
     * Limit how many VideoMetadata to delete.
     */
    limit?: number
  }

  /**
   * VideoMetadata.movie
   */
  export type VideoMetadata$movieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
  }

  /**
   * VideoMetadata.episode
   */
  export type VideoMetadata$episodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    where?: EpisodeWhereInput
  }

  /**
   * VideoMetadata.series
   */
  export type VideoMetadata$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
  }

  /**
   * VideoMetadata.genres
   */
  export type VideoMetadata$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    where?: VideoGenreWhereInput
    orderBy?: VideoGenreOrderByWithRelationInput | VideoGenreOrderByWithRelationInput[]
    cursor?: VideoGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoGenreScalarFieldEnum | VideoGenreScalarFieldEnum[]
  }

  /**
   * VideoMetadata.actors
   */
  export type VideoMetadata$actorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    where?: VideoActorWhereInput
    orderBy?: VideoActorOrderByWithRelationInput | VideoActorOrderByWithRelationInput[]
    cursor?: VideoActorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoActorScalarFieldEnum | VideoActorScalarFieldEnum[]
  }

  /**
   * VideoMetadata.subtitles
   */
  export type VideoMetadata$subtitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    where?: SubtitleWhereInput
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    cursor?: SubtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * VideoMetadata.languages
   */
  export type VideoMetadata$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    where?: VideoLanguageWhereInput
    orderBy?: VideoLanguageOrderByWithRelationInput | VideoLanguageOrderByWithRelationInput[]
    cursor?: VideoLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoLanguageScalarFieldEnum | VideoLanguageScalarFieldEnum[]
  }

  /**
   * VideoMetadata without action
   */
  export type VideoMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
  }


  /**
   * Model VideoFile
   */

  export type AggregateVideoFile = {
    _count: VideoFileCountAggregateOutputType | null
    _avg: VideoFileAvgAggregateOutputType | null
    _sum: VideoFileSumAggregateOutputType | null
    _min: VideoFileMinAggregateOutputType | null
    _max: VideoFileMaxAggregateOutputType | null
  }

  export type VideoFileAvgAggregateOutputType = {
    duration: number | null
    width: number | null
    height: number | null
  }

  export type VideoFileSumAggregateOutputType = {
    duration: number | null
    width: number | null
    height: number | null
  }

  export type VideoFileMinAggregateOutputType = {
    id: string | null
    filePath: string | null
    trailerPath: string | null
    duration: number | null
    width: number | null
    height: number | null
  }

  export type VideoFileMaxAggregateOutputType = {
    id: string | null
    filePath: string | null
    trailerPath: string | null
    duration: number | null
    width: number | null
    height: number | null
  }

  export type VideoFileCountAggregateOutputType = {
    id: number
    filePath: number
    trailerPath: number
    duration: number
    width: number
    height: number
    _all: number
  }


  export type VideoFileAvgAggregateInputType = {
    duration?: true
    width?: true
    height?: true
  }

  export type VideoFileSumAggregateInputType = {
    duration?: true
    width?: true
    height?: true
  }

  export type VideoFileMinAggregateInputType = {
    id?: true
    filePath?: true
    trailerPath?: true
    duration?: true
    width?: true
    height?: true
  }

  export type VideoFileMaxAggregateInputType = {
    id?: true
    filePath?: true
    trailerPath?: true
    duration?: true
    width?: true
    height?: true
  }

  export type VideoFileCountAggregateInputType = {
    id?: true
    filePath?: true
    trailerPath?: true
    duration?: true
    width?: true
    height?: true
    _all?: true
  }

  export type VideoFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoFile to aggregate.
     */
    where?: VideoFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFiles to fetch.
     */
    orderBy?: VideoFileOrderByWithRelationInput | VideoFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoFiles
    **/
    _count?: true | VideoFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoFileMaxAggregateInputType
  }

  export type GetVideoFileAggregateType<T extends VideoFileAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoFile[P]>
      : GetScalarType<T[P], AggregateVideoFile[P]>
  }




  export type VideoFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoFileWhereInput
    orderBy?: VideoFileOrderByWithAggregationInput | VideoFileOrderByWithAggregationInput[]
    by: VideoFileScalarFieldEnum[] | VideoFileScalarFieldEnum
    having?: VideoFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoFileCountAggregateInputType | true
    _avg?: VideoFileAvgAggregateInputType
    _sum?: VideoFileSumAggregateInputType
    _min?: VideoFileMinAggregateInputType
    _max?: VideoFileMaxAggregateInputType
  }

  export type VideoFileGroupByOutputType = {
    id: string
    filePath: string
    trailerPath: string | null
    duration: number
    width: number | null
    height: number | null
    _count: VideoFileCountAggregateOutputType | null
    _avg: VideoFileAvgAggregateOutputType | null
    _sum: VideoFileSumAggregateOutputType | null
    _min: VideoFileMinAggregateOutputType | null
    _max: VideoFileMaxAggregateOutputType | null
  }

  type GetVideoFileGroupByPayload<T extends VideoFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoFileGroupByOutputType[P]>
            : GetScalarType<T[P], VideoFileGroupByOutputType[P]>
        }
      >
    >


  export type VideoFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filePath?: boolean
    trailerPath?: boolean
    duration?: boolean
    width?: boolean
    height?: boolean
    movie?: boolean | VideoFile$movieArgs<ExtArgs>
    episode?: boolean | VideoFile$episodeArgs<ExtArgs>
    subtitles?: boolean | VideoFile$subtitlesArgs<ExtArgs>
    purchases?: boolean | VideoFile$purchasesArgs<ExtArgs>
    comments?: boolean | VideoFile$commentsArgs<ExtArgs>
    views?: boolean | VideoFile$viewsArgs<ExtArgs>
    _count?: boolean | VideoFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoFile"]>

  export type VideoFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filePath?: boolean
    trailerPath?: boolean
    duration?: boolean
    width?: boolean
    height?: boolean
  }, ExtArgs["result"]["videoFile"]>

  export type VideoFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filePath?: boolean
    trailerPath?: boolean
    duration?: boolean
    width?: boolean
    height?: boolean
  }, ExtArgs["result"]["videoFile"]>

  export type VideoFileSelectScalar = {
    id?: boolean
    filePath?: boolean
    trailerPath?: boolean
    duration?: boolean
    width?: boolean
    height?: boolean
  }

  export type VideoFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filePath" | "trailerPath" | "duration" | "width" | "height", ExtArgs["result"]["videoFile"]>
  export type VideoFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | VideoFile$movieArgs<ExtArgs>
    episode?: boolean | VideoFile$episodeArgs<ExtArgs>
    subtitles?: boolean | VideoFile$subtitlesArgs<ExtArgs>
    purchases?: boolean | VideoFile$purchasesArgs<ExtArgs>
    comments?: boolean | VideoFile$commentsArgs<ExtArgs>
    views?: boolean | VideoFile$viewsArgs<ExtArgs>
    _count?: boolean | VideoFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VideoFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoFile"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs> | null
      episode: Prisma.$EpisodePayload<ExtArgs> | null
      subtitles: Prisma.$SubtitlePayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      views: Prisma.$ViewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filePath: string
      trailerPath: string | null
      duration: number
      width: number | null
      height: number | null
    }, ExtArgs["result"]["videoFile"]>
    composites: {}
  }

  type VideoFileGetPayload<S extends boolean | null | undefined | VideoFileDefaultArgs> = $Result.GetResult<Prisma.$VideoFilePayload, S>

  type VideoFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoFileCountAggregateInputType | true
    }

  export interface VideoFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoFile'], meta: { name: 'VideoFile' } }
    /**
     * Find zero or one VideoFile that matches the filter.
     * @param {VideoFileFindUniqueArgs} args - Arguments to find a VideoFile
     * @example
     * // Get one VideoFile
     * const videoFile = await prisma.videoFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFileFindUniqueArgs>(args: SelectSubset<T, VideoFileFindUniqueArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFileFindUniqueOrThrowArgs} args - Arguments to find a VideoFile
     * @example
     * // Get one VideoFile
     * const videoFile = await prisma.videoFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFileFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileFindFirstArgs} args - Arguments to find a VideoFile
     * @example
     * // Get one VideoFile
     * const videoFile = await prisma.videoFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFileFindFirstArgs>(args?: SelectSubset<T, VideoFileFindFirstArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileFindFirstOrThrowArgs} args - Arguments to find a VideoFile
     * @example
     * // Get one VideoFile
     * const videoFile = await prisma.videoFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFileFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoFiles
     * const videoFiles = await prisma.videoFile.findMany()
     * 
     * // Get first 10 VideoFiles
     * const videoFiles = await prisma.videoFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoFileWithIdOnly = await prisma.videoFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFileFindManyArgs>(args?: SelectSubset<T, VideoFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoFile.
     * @param {VideoFileCreateArgs} args - Arguments to create a VideoFile.
     * @example
     * // Create one VideoFile
     * const VideoFile = await prisma.videoFile.create({
     *   data: {
     *     // ... data to create a VideoFile
     *   }
     * })
     * 
     */
    create<T extends VideoFileCreateArgs>(args: SelectSubset<T, VideoFileCreateArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoFiles.
     * @param {VideoFileCreateManyArgs} args - Arguments to create many VideoFiles.
     * @example
     * // Create many VideoFiles
     * const videoFile = await prisma.videoFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoFileCreateManyArgs>(args?: SelectSubset<T, VideoFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoFiles and returns the data saved in the database.
     * @param {VideoFileCreateManyAndReturnArgs} args - Arguments to create many VideoFiles.
     * @example
     * // Create many VideoFiles
     * const videoFile = await prisma.videoFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoFiles and only return the `id`
     * const videoFileWithIdOnly = await prisma.videoFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoFileCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoFile.
     * @param {VideoFileDeleteArgs} args - Arguments to delete one VideoFile.
     * @example
     * // Delete one VideoFile
     * const VideoFile = await prisma.videoFile.delete({
     *   where: {
     *     // ... filter to delete one VideoFile
     *   }
     * })
     * 
     */
    delete<T extends VideoFileDeleteArgs>(args: SelectSubset<T, VideoFileDeleteArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoFile.
     * @param {VideoFileUpdateArgs} args - Arguments to update one VideoFile.
     * @example
     * // Update one VideoFile
     * const videoFile = await prisma.videoFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoFileUpdateArgs>(args: SelectSubset<T, VideoFileUpdateArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoFiles.
     * @param {VideoFileDeleteManyArgs} args - Arguments to filter VideoFiles to delete.
     * @example
     * // Delete a few VideoFiles
     * const { count } = await prisma.videoFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoFileDeleteManyArgs>(args?: SelectSubset<T, VideoFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoFiles
     * const videoFile = await prisma.videoFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoFileUpdateManyArgs>(args: SelectSubset<T, VideoFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoFiles and returns the data updated in the database.
     * @param {VideoFileUpdateManyAndReturnArgs} args - Arguments to update many VideoFiles.
     * @example
     * // Update many VideoFiles
     * const videoFile = await prisma.videoFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoFiles and only return the `id`
     * const videoFileWithIdOnly = await prisma.videoFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoFileUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoFile.
     * @param {VideoFileUpsertArgs} args - Arguments to update or create a VideoFile.
     * @example
     * // Update or create a VideoFile
     * const videoFile = await prisma.videoFile.upsert({
     *   create: {
     *     // ... data to create a VideoFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoFile we want to update
     *   }
     * })
     */
    upsert<T extends VideoFileUpsertArgs>(args: SelectSubset<T, VideoFileUpsertArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileCountArgs} args - Arguments to filter VideoFiles to count.
     * @example
     * // Count the number of VideoFiles
     * const count = await prisma.videoFile.count({
     *   where: {
     *     // ... the filter for the VideoFiles we want to count
     *   }
     * })
    **/
    count<T extends VideoFileCountArgs>(
      args?: Subset<T, VideoFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoFileAggregateArgs>(args: Subset<T, VideoFileAggregateArgs>): Prisma.PrismaPromise<GetVideoFileAggregateType<T>>

    /**
     * Group by VideoFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoFileGroupByArgs['orderBy'] }
        : { orderBy?: VideoFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoFile model
   */
  readonly fields: VideoFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends VideoFile$movieArgs<ExtArgs> = {}>(args?: Subset<T, VideoFile$movieArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    episode<T extends VideoFile$episodeArgs<ExtArgs> = {}>(args?: Subset<T, VideoFile$episodeArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subtitles<T extends VideoFile$subtitlesArgs<ExtArgs> = {}>(args?: Subset<T, VideoFile$subtitlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends VideoFile$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, VideoFile$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends VideoFile$commentsArgs<ExtArgs> = {}>(args?: Subset<T, VideoFile$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends VideoFile$viewsArgs<ExtArgs> = {}>(args?: Subset<T, VideoFile$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoFile model
   */
  interface VideoFileFieldRefs {
    readonly id: FieldRef<"VideoFile", 'String'>
    readonly filePath: FieldRef<"VideoFile", 'String'>
    readonly trailerPath: FieldRef<"VideoFile", 'String'>
    readonly duration: FieldRef<"VideoFile", 'Int'>
    readonly width: FieldRef<"VideoFile", 'Int'>
    readonly height: FieldRef<"VideoFile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VideoFile findUnique
   */
  export type VideoFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * Filter, which VideoFile to fetch.
     */
    where: VideoFileWhereUniqueInput
  }

  /**
   * VideoFile findUniqueOrThrow
   */
  export type VideoFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * Filter, which VideoFile to fetch.
     */
    where: VideoFileWhereUniqueInput
  }

  /**
   * VideoFile findFirst
   */
  export type VideoFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * Filter, which VideoFile to fetch.
     */
    where?: VideoFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFiles to fetch.
     */
    orderBy?: VideoFileOrderByWithRelationInput | VideoFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoFiles.
     */
    cursor?: VideoFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoFiles.
     */
    distinct?: VideoFileScalarFieldEnum | VideoFileScalarFieldEnum[]
  }

  /**
   * VideoFile findFirstOrThrow
   */
  export type VideoFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * Filter, which VideoFile to fetch.
     */
    where?: VideoFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFiles to fetch.
     */
    orderBy?: VideoFileOrderByWithRelationInput | VideoFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoFiles.
     */
    cursor?: VideoFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoFiles.
     */
    distinct?: VideoFileScalarFieldEnum | VideoFileScalarFieldEnum[]
  }

  /**
   * VideoFile findMany
   */
  export type VideoFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * Filter, which VideoFiles to fetch.
     */
    where?: VideoFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFiles to fetch.
     */
    orderBy?: VideoFileOrderByWithRelationInput | VideoFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoFiles.
     */
    cursor?: VideoFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFiles.
     */
    skip?: number
    distinct?: VideoFileScalarFieldEnum | VideoFileScalarFieldEnum[]
  }

  /**
   * VideoFile create
   */
  export type VideoFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoFile.
     */
    data: XOR<VideoFileCreateInput, VideoFileUncheckedCreateInput>
  }

  /**
   * VideoFile createMany
   */
  export type VideoFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoFiles.
     */
    data: VideoFileCreateManyInput | VideoFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoFile createManyAndReturn
   */
  export type VideoFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * The data used to create many VideoFiles.
     */
    data: VideoFileCreateManyInput | VideoFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoFile update
   */
  export type VideoFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoFile.
     */
    data: XOR<VideoFileUpdateInput, VideoFileUncheckedUpdateInput>
    /**
     * Choose, which VideoFile to update.
     */
    where: VideoFileWhereUniqueInput
  }

  /**
   * VideoFile updateMany
   */
  export type VideoFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoFiles.
     */
    data: XOR<VideoFileUpdateManyMutationInput, VideoFileUncheckedUpdateManyInput>
    /**
     * Filter which VideoFiles to update
     */
    where?: VideoFileWhereInput
    /**
     * Limit how many VideoFiles to update.
     */
    limit?: number
  }

  /**
   * VideoFile updateManyAndReturn
   */
  export type VideoFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * The data used to update VideoFiles.
     */
    data: XOR<VideoFileUpdateManyMutationInput, VideoFileUncheckedUpdateManyInput>
    /**
     * Filter which VideoFiles to update
     */
    where?: VideoFileWhereInput
    /**
     * Limit how many VideoFiles to update.
     */
    limit?: number
  }

  /**
   * VideoFile upsert
   */
  export type VideoFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoFile to update in case it exists.
     */
    where: VideoFileWhereUniqueInput
    /**
     * In case the VideoFile found by the `where` argument doesn't exist, create a new VideoFile with this data.
     */
    create: XOR<VideoFileCreateInput, VideoFileUncheckedCreateInput>
    /**
     * In case the VideoFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoFileUpdateInput, VideoFileUncheckedUpdateInput>
  }

  /**
   * VideoFile delete
   */
  export type VideoFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
    /**
     * Filter which VideoFile to delete.
     */
    where: VideoFileWhereUniqueInput
  }

  /**
   * VideoFile deleteMany
   */
  export type VideoFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoFiles to delete
     */
    where?: VideoFileWhereInput
    /**
     * Limit how many VideoFiles to delete.
     */
    limit?: number
  }

  /**
   * VideoFile.movie
   */
  export type VideoFile$movieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
  }

  /**
   * VideoFile.episode
   */
  export type VideoFile$episodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    where?: EpisodeWhereInput
  }

  /**
   * VideoFile.subtitles
   */
  export type VideoFile$subtitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    where?: SubtitleWhereInput
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    cursor?: SubtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * VideoFile.purchases
   */
  export type VideoFile$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * VideoFile.comments
   */
  export type VideoFile$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * VideoFile.views
   */
  export type VideoFile$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    where?: ViewWhereInput
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    cursor?: ViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewScalarFieldEnum | ViewScalarFieldEnum[]
  }

  /**
   * VideoFile without action
   */
  export type VideoFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFile
     */
    select?: VideoFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFile
     */
    omit?: VideoFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFileInclude<ExtArgs> | null
  }


  /**
   * Model VideoGenre
   */

  export type AggregateVideoGenre = {
    _count: VideoGenreCountAggregateOutputType | null
    _min: VideoGenreMinAggregateOutputType | null
    _max: VideoGenreMaxAggregateOutputType | null
  }

  export type VideoGenreMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type VideoGenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type VideoGenreCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type VideoGenreMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type VideoGenreMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type VideoGenreCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type VideoGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoGenre to aggregate.
     */
    where?: VideoGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoGenres to fetch.
     */
    orderBy?: VideoGenreOrderByWithRelationInput | VideoGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoGenres
    **/
    _count?: true | VideoGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoGenreMaxAggregateInputType
  }

  export type GetVideoGenreAggregateType<T extends VideoGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoGenre[P]>
      : GetScalarType<T[P], AggregateVideoGenre[P]>
  }




  export type VideoGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoGenreWhereInput
    orderBy?: VideoGenreOrderByWithAggregationInput | VideoGenreOrderByWithAggregationInput[]
    by: VideoGenreScalarFieldEnum[] | VideoGenreScalarFieldEnum
    having?: VideoGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoGenreCountAggregateInputType | true
    _min?: VideoGenreMinAggregateInputType
    _max?: VideoGenreMaxAggregateInputType
  }

  export type VideoGenreGroupByOutputType = {
    id: string
    name: string
    _count: VideoGenreCountAggregateOutputType | null
    _min: VideoGenreMinAggregateOutputType | null
    _max: VideoGenreMaxAggregateOutputType | null
  }

  type GetVideoGenreGroupByPayload<T extends VideoGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGenreGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGenreGroupByOutputType[P]>
        }
      >
    >


  export type VideoGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    videos?: boolean | VideoGenre$videosArgs<ExtArgs>
    _count?: boolean | VideoGenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoGenre"]>

  export type VideoGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["videoGenre"]>

  export type VideoGenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["videoGenre"]>

  export type VideoGenreSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type VideoGenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["videoGenre"]>
  export type VideoGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoGenre$videosArgs<ExtArgs>
    _count?: boolean | VideoGenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VideoGenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoGenre"
    objects: {
      videos: Prisma.$VideoMetadataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["videoGenre"]>
    composites: {}
  }

  type VideoGenreGetPayload<S extends boolean | null | undefined | VideoGenreDefaultArgs> = $Result.GetResult<Prisma.$VideoGenrePayload, S>

  type VideoGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoGenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoGenreCountAggregateInputType | true
    }

  export interface VideoGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoGenre'], meta: { name: 'VideoGenre' } }
    /**
     * Find zero or one VideoGenre that matches the filter.
     * @param {VideoGenreFindUniqueArgs} args - Arguments to find a VideoGenre
     * @example
     * // Get one VideoGenre
     * const videoGenre = await prisma.videoGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoGenreFindUniqueArgs>(args: SelectSubset<T, VideoGenreFindUniqueArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoGenreFindUniqueOrThrowArgs} args - Arguments to find a VideoGenre
     * @example
     * // Get one VideoGenre
     * const videoGenre = await prisma.videoGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreFindFirstArgs} args - Arguments to find a VideoGenre
     * @example
     * // Get one VideoGenre
     * const videoGenre = await prisma.videoGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoGenreFindFirstArgs>(args?: SelectSubset<T, VideoGenreFindFirstArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreFindFirstOrThrowArgs} args - Arguments to find a VideoGenre
     * @example
     * // Get one VideoGenre
     * const videoGenre = await prisma.videoGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoGenres
     * const videoGenres = await prisma.videoGenre.findMany()
     * 
     * // Get first 10 VideoGenres
     * const videoGenres = await prisma.videoGenre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoGenreWithIdOnly = await prisma.videoGenre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoGenreFindManyArgs>(args?: SelectSubset<T, VideoGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoGenre.
     * @param {VideoGenreCreateArgs} args - Arguments to create a VideoGenre.
     * @example
     * // Create one VideoGenre
     * const VideoGenre = await prisma.videoGenre.create({
     *   data: {
     *     // ... data to create a VideoGenre
     *   }
     * })
     * 
     */
    create<T extends VideoGenreCreateArgs>(args: SelectSubset<T, VideoGenreCreateArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoGenres.
     * @param {VideoGenreCreateManyArgs} args - Arguments to create many VideoGenres.
     * @example
     * // Create many VideoGenres
     * const videoGenre = await prisma.videoGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoGenreCreateManyArgs>(args?: SelectSubset<T, VideoGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoGenres and returns the data saved in the database.
     * @param {VideoGenreCreateManyAndReturnArgs} args - Arguments to create many VideoGenres.
     * @example
     * // Create many VideoGenres
     * const videoGenre = await prisma.videoGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoGenres and only return the `id`
     * const videoGenreWithIdOnly = await prisma.videoGenre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoGenre.
     * @param {VideoGenreDeleteArgs} args - Arguments to delete one VideoGenre.
     * @example
     * // Delete one VideoGenre
     * const VideoGenre = await prisma.videoGenre.delete({
     *   where: {
     *     // ... filter to delete one VideoGenre
     *   }
     * })
     * 
     */
    delete<T extends VideoGenreDeleteArgs>(args: SelectSubset<T, VideoGenreDeleteArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoGenre.
     * @param {VideoGenreUpdateArgs} args - Arguments to update one VideoGenre.
     * @example
     * // Update one VideoGenre
     * const videoGenre = await prisma.videoGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoGenreUpdateArgs>(args: SelectSubset<T, VideoGenreUpdateArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoGenres.
     * @param {VideoGenreDeleteManyArgs} args - Arguments to filter VideoGenres to delete.
     * @example
     * // Delete a few VideoGenres
     * const { count } = await prisma.videoGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoGenreDeleteManyArgs>(args?: SelectSubset<T, VideoGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoGenres
     * const videoGenre = await prisma.videoGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoGenreUpdateManyArgs>(args: SelectSubset<T, VideoGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoGenres and returns the data updated in the database.
     * @param {VideoGenreUpdateManyAndReturnArgs} args - Arguments to update many VideoGenres.
     * @example
     * // Update many VideoGenres
     * const videoGenre = await prisma.videoGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoGenres and only return the `id`
     * const videoGenreWithIdOnly = await prisma.videoGenre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoGenreUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoGenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoGenre.
     * @param {VideoGenreUpsertArgs} args - Arguments to update or create a VideoGenre.
     * @example
     * // Update or create a VideoGenre
     * const videoGenre = await prisma.videoGenre.upsert({
     *   create: {
     *     // ... data to create a VideoGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoGenre we want to update
     *   }
     * })
     */
    upsert<T extends VideoGenreUpsertArgs>(args: SelectSubset<T, VideoGenreUpsertArgs<ExtArgs>>): Prisma__VideoGenreClient<$Result.GetResult<Prisma.$VideoGenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreCountArgs} args - Arguments to filter VideoGenres to count.
     * @example
     * // Count the number of VideoGenres
     * const count = await prisma.videoGenre.count({
     *   where: {
     *     // ... the filter for the VideoGenres we want to count
     *   }
     * })
    **/
    count<T extends VideoGenreCountArgs>(
      args?: Subset<T, VideoGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoGenreAggregateArgs>(args: Subset<T, VideoGenreAggregateArgs>): Prisma.PrismaPromise<GetVideoGenreAggregateType<T>>

    /**
     * Group by VideoGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGenreGroupByArgs['orderBy'] }
        : { orderBy?: VideoGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoGenre model
   */
  readonly fields: VideoGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends VideoGenre$videosArgs<ExtArgs> = {}>(args?: Subset<T, VideoGenre$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoGenre model
   */
  interface VideoGenreFieldRefs {
    readonly id: FieldRef<"VideoGenre", 'String'>
    readonly name: FieldRef<"VideoGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoGenre findUnique
   */
  export type VideoGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * Filter, which VideoGenre to fetch.
     */
    where: VideoGenreWhereUniqueInput
  }

  /**
   * VideoGenre findUniqueOrThrow
   */
  export type VideoGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * Filter, which VideoGenre to fetch.
     */
    where: VideoGenreWhereUniqueInput
  }

  /**
   * VideoGenre findFirst
   */
  export type VideoGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * Filter, which VideoGenre to fetch.
     */
    where?: VideoGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoGenres to fetch.
     */
    orderBy?: VideoGenreOrderByWithRelationInput | VideoGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoGenres.
     */
    cursor?: VideoGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoGenres.
     */
    distinct?: VideoGenreScalarFieldEnum | VideoGenreScalarFieldEnum[]
  }

  /**
   * VideoGenre findFirstOrThrow
   */
  export type VideoGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * Filter, which VideoGenre to fetch.
     */
    where?: VideoGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoGenres to fetch.
     */
    orderBy?: VideoGenreOrderByWithRelationInput | VideoGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoGenres.
     */
    cursor?: VideoGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoGenres.
     */
    distinct?: VideoGenreScalarFieldEnum | VideoGenreScalarFieldEnum[]
  }

  /**
   * VideoGenre findMany
   */
  export type VideoGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * Filter, which VideoGenres to fetch.
     */
    where?: VideoGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoGenres to fetch.
     */
    orderBy?: VideoGenreOrderByWithRelationInput | VideoGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoGenres.
     */
    cursor?: VideoGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoGenres.
     */
    skip?: number
    distinct?: VideoGenreScalarFieldEnum | VideoGenreScalarFieldEnum[]
  }

  /**
   * VideoGenre create
   */
  export type VideoGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoGenre.
     */
    data: XOR<VideoGenreCreateInput, VideoGenreUncheckedCreateInput>
  }

  /**
   * VideoGenre createMany
   */
  export type VideoGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoGenres.
     */
    data: VideoGenreCreateManyInput | VideoGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoGenre createManyAndReturn
   */
  export type VideoGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * The data used to create many VideoGenres.
     */
    data: VideoGenreCreateManyInput | VideoGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoGenre update
   */
  export type VideoGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoGenre.
     */
    data: XOR<VideoGenreUpdateInput, VideoGenreUncheckedUpdateInput>
    /**
     * Choose, which VideoGenre to update.
     */
    where: VideoGenreWhereUniqueInput
  }

  /**
   * VideoGenre updateMany
   */
  export type VideoGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoGenres.
     */
    data: XOR<VideoGenreUpdateManyMutationInput, VideoGenreUncheckedUpdateManyInput>
    /**
     * Filter which VideoGenres to update
     */
    where?: VideoGenreWhereInput
    /**
     * Limit how many VideoGenres to update.
     */
    limit?: number
  }

  /**
   * VideoGenre updateManyAndReturn
   */
  export type VideoGenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * The data used to update VideoGenres.
     */
    data: XOR<VideoGenreUpdateManyMutationInput, VideoGenreUncheckedUpdateManyInput>
    /**
     * Filter which VideoGenres to update
     */
    where?: VideoGenreWhereInput
    /**
     * Limit how many VideoGenres to update.
     */
    limit?: number
  }

  /**
   * VideoGenre upsert
   */
  export type VideoGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoGenre to update in case it exists.
     */
    where: VideoGenreWhereUniqueInput
    /**
     * In case the VideoGenre found by the `where` argument doesn't exist, create a new VideoGenre with this data.
     */
    create: XOR<VideoGenreCreateInput, VideoGenreUncheckedCreateInput>
    /**
     * In case the VideoGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoGenreUpdateInput, VideoGenreUncheckedUpdateInput>
  }

  /**
   * VideoGenre delete
   */
  export type VideoGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
    /**
     * Filter which VideoGenre to delete.
     */
    where: VideoGenreWhereUniqueInput
  }

  /**
   * VideoGenre deleteMany
   */
  export type VideoGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoGenres to delete
     */
    where?: VideoGenreWhereInput
    /**
     * Limit how many VideoGenres to delete.
     */
    limit?: number
  }

  /**
   * VideoGenre.videos
   */
  export type VideoGenre$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    where?: VideoMetadataWhereInput
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    cursor?: VideoMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoGenre without action
   */
  export type VideoGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoGenre
     */
    select?: VideoGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoGenre
     */
    omit?: VideoGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoGenreInclude<ExtArgs> | null
  }


  /**
   * Model Actor
   */

  export type AggregateActor = {
    _count: ActorCountAggregateOutputType | null
    _min: ActorMinAggregateOutputType | null
    _max: ActorMaxAggregateOutputType | null
  }

  export type ActorMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ActorMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ActorCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ActorMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActorMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActorCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ActorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actor to aggregate.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actors
    **/
    _count?: true | ActorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActorMaxAggregateInputType
  }

  export type GetActorAggregateType<T extends ActorAggregateArgs> = {
        [P in keyof T & keyof AggregateActor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActor[P]>
      : GetScalarType<T[P], AggregateActor[P]>
  }




  export type ActorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActorWhereInput
    orderBy?: ActorOrderByWithAggregationInput | ActorOrderByWithAggregationInput[]
    by: ActorScalarFieldEnum[] | ActorScalarFieldEnum
    having?: ActorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActorCountAggregateInputType | true
    _min?: ActorMinAggregateInputType
    _max?: ActorMaxAggregateInputType
  }

  export type ActorGroupByOutputType = {
    id: string
    name: string
    _count: ActorCountAggregateOutputType | null
    _min: ActorMinAggregateOutputType | null
    _max: ActorMaxAggregateOutputType | null
  }

  type GetActorGroupByPayload<T extends ActorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActorGroupByOutputType[P]>
            : GetScalarType<T[P], ActorGroupByOutputType[P]>
        }
      >
    >


  export type ActorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    VideoActor?: boolean | Actor$VideoActorArgs<ExtArgs>
    _count?: boolean | ActorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actor"]>

  export type ActorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["actor"]>

  export type ActorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["actor"]>

  export type ActorSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ActorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["actor"]>
  export type ActorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VideoActor?: boolean | Actor$VideoActorArgs<ExtArgs>
    _count?: boolean | ActorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ActorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Actor"
    objects: {
      VideoActor: Prisma.$VideoActorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["actor"]>
    composites: {}
  }

  type ActorGetPayload<S extends boolean | null | undefined | ActorDefaultArgs> = $Result.GetResult<Prisma.$ActorPayload, S>

  type ActorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActorCountAggregateInputType | true
    }

  export interface ActorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Actor'], meta: { name: 'Actor' } }
    /**
     * Find zero or one Actor that matches the filter.
     * @param {ActorFindUniqueArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActorFindUniqueArgs>(args: SelectSubset<T, ActorFindUniqueArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Actor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActorFindUniqueOrThrowArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActorFindUniqueOrThrowArgs>(args: SelectSubset<T, ActorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorFindFirstArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActorFindFirstArgs>(args?: SelectSubset<T, ActorFindFirstArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorFindFirstOrThrowArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActorFindFirstOrThrowArgs>(args?: SelectSubset<T, ActorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actors
     * const actors = await prisma.actor.findMany()
     * 
     * // Get first 10 Actors
     * const actors = await prisma.actor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actorWithIdOnly = await prisma.actor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActorFindManyArgs>(args?: SelectSubset<T, ActorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Actor.
     * @param {ActorCreateArgs} args - Arguments to create a Actor.
     * @example
     * // Create one Actor
     * const Actor = await prisma.actor.create({
     *   data: {
     *     // ... data to create a Actor
     *   }
     * })
     * 
     */
    create<T extends ActorCreateArgs>(args: SelectSubset<T, ActorCreateArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actors.
     * @param {ActorCreateManyArgs} args - Arguments to create many Actors.
     * @example
     * // Create many Actors
     * const actor = await prisma.actor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActorCreateManyArgs>(args?: SelectSubset<T, ActorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actors and returns the data saved in the database.
     * @param {ActorCreateManyAndReturnArgs} args - Arguments to create many Actors.
     * @example
     * // Create many Actors
     * const actor = await prisma.actor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actors and only return the `id`
     * const actorWithIdOnly = await prisma.actor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActorCreateManyAndReturnArgs>(args?: SelectSubset<T, ActorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Actor.
     * @param {ActorDeleteArgs} args - Arguments to delete one Actor.
     * @example
     * // Delete one Actor
     * const Actor = await prisma.actor.delete({
     *   where: {
     *     // ... filter to delete one Actor
     *   }
     * })
     * 
     */
    delete<T extends ActorDeleteArgs>(args: SelectSubset<T, ActorDeleteArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Actor.
     * @param {ActorUpdateArgs} args - Arguments to update one Actor.
     * @example
     * // Update one Actor
     * const actor = await prisma.actor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActorUpdateArgs>(args: SelectSubset<T, ActorUpdateArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actors.
     * @param {ActorDeleteManyArgs} args - Arguments to filter Actors to delete.
     * @example
     * // Delete a few Actors
     * const { count } = await prisma.actor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActorDeleteManyArgs>(args?: SelectSubset<T, ActorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actors
     * const actor = await prisma.actor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActorUpdateManyArgs>(args: SelectSubset<T, ActorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actors and returns the data updated in the database.
     * @param {ActorUpdateManyAndReturnArgs} args - Arguments to update many Actors.
     * @example
     * // Update many Actors
     * const actor = await prisma.actor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actors and only return the `id`
     * const actorWithIdOnly = await prisma.actor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActorUpdateManyAndReturnArgs>(args: SelectSubset<T, ActorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Actor.
     * @param {ActorUpsertArgs} args - Arguments to update or create a Actor.
     * @example
     * // Update or create a Actor
     * const actor = await prisma.actor.upsert({
     *   create: {
     *     // ... data to create a Actor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actor we want to update
     *   }
     * })
     */
    upsert<T extends ActorUpsertArgs>(args: SelectSubset<T, ActorUpsertArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorCountArgs} args - Arguments to filter Actors to count.
     * @example
     * // Count the number of Actors
     * const count = await prisma.actor.count({
     *   where: {
     *     // ... the filter for the Actors we want to count
     *   }
     * })
    **/
    count<T extends ActorCountArgs>(
      args?: Subset<T, ActorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActorAggregateArgs>(args: Subset<T, ActorAggregateArgs>): Prisma.PrismaPromise<GetActorAggregateType<T>>

    /**
     * Group by Actor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActorGroupByArgs['orderBy'] }
        : { orderBy?: ActorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Actor model
   */
  readonly fields: ActorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Actor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VideoActor<T extends Actor$VideoActorArgs<ExtArgs> = {}>(args?: Subset<T, Actor$VideoActorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Actor model
   */
  interface ActorFieldRefs {
    readonly id: FieldRef<"Actor", 'String'>
    readonly name: FieldRef<"Actor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Actor findUnique
   */
  export type ActorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor findUniqueOrThrow
   */
  export type ActorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor findFirst
   */
  export type ActorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actors.
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actors.
     */
    distinct?: ActorScalarFieldEnum | ActorScalarFieldEnum[]
  }

  /**
   * Actor findFirstOrThrow
   */
  export type ActorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actors.
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actors.
     */
    distinct?: ActorScalarFieldEnum | ActorScalarFieldEnum[]
  }

  /**
   * Actor findMany
   */
  export type ActorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actors to fetch.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actors.
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    distinct?: ActorScalarFieldEnum | ActorScalarFieldEnum[]
  }

  /**
   * Actor create
   */
  export type ActorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * The data needed to create a Actor.
     */
    data: XOR<ActorCreateInput, ActorUncheckedCreateInput>
  }

  /**
   * Actor createMany
   */
  export type ActorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actors.
     */
    data: ActorCreateManyInput | ActorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Actor createManyAndReturn
   */
  export type ActorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * The data used to create many Actors.
     */
    data: ActorCreateManyInput | ActorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Actor update
   */
  export type ActorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * The data needed to update a Actor.
     */
    data: XOR<ActorUpdateInput, ActorUncheckedUpdateInput>
    /**
     * Choose, which Actor to update.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor updateMany
   */
  export type ActorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actors.
     */
    data: XOR<ActorUpdateManyMutationInput, ActorUncheckedUpdateManyInput>
    /**
     * Filter which Actors to update
     */
    where?: ActorWhereInput
    /**
     * Limit how many Actors to update.
     */
    limit?: number
  }

  /**
   * Actor updateManyAndReturn
   */
  export type ActorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * The data used to update Actors.
     */
    data: XOR<ActorUpdateManyMutationInput, ActorUncheckedUpdateManyInput>
    /**
     * Filter which Actors to update
     */
    where?: ActorWhereInput
    /**
     * Limit how many Actors to update.
     */
    limit?: number
  }

  /**
   * Actor upsert
   */
  export type ActorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * The filter to search for the Actor to update in case it exists.
     */
    where: ActorWhereUniqueInput
    /**
     * In case the Actor found by the `where` argument doesn't exist, create a new Actor with this data.
     */
    create: XOR<ActorCreateInput, ActorUncheckedCreateInput>
    /**
     * In case the Actor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActorUpdateInput, ActorUncheckedUpdateInput>
  }

  /**
   * Actor delete
   */
  export type ActorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter which Actor to delete.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor deleteMany
   */
  export type ActorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actors to delete
     */
    where?: ActorWhereInput
    /**
     * Limit how many Actors to delete.
     */
    limit?: number
  }

  /**
   * Actor.VideoActor
   */
  export type Actor$VideoActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    where?: VideoActorWhereInput
    orderBy?: VideoActorOrderByWithRelationInput | VideoActorOrderByWithRelationInput[]
    cursor?: VideoActorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoActorScalarFieldEnum | VideoActorScalarFieldEnum[]
  }

  /**
   * Actor without action
   */
  export type ActorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
  }


  /**
   * Model VideoActor
   */

  export type AggregateVideoActor = {
    _count: VideoActorCountAggregateOutputType | null
    _min: VideoActorMinAggregateOutputType | null
    _max: VideoActorMaxAggregateOutputType | null
  }

  export type VideoActorMinAggregateOutputType = {
    videoId: string | null
    actorId: string | null
    role: string | null
  }

  export type VideoActorMaxAggregateOutputType = {
    videoId: string | null
    actorId: string | null
    role: string | null
  }

  export type VideoActorCountAggregateOutputType = {
    videoId: number
    actorId: number
    role: number
    _all: number
  }


  export type VideoActorMinAggregateInputType = {
    videoId?: true
    actorId?: true
    role?: true
  }

  export type VideoActorMaxAggregateInputType = {
    videoId?: true
    actorId?: true
    role?: true
  }

  export type VideoActorCountAggregateInputType = {
    videoId?: true
    actorId?: true
    role?: true
    _all?: true
  }

  export type VideoActorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoActor to aggregate.
     */
    where?: VideoActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoActors to fetch.
     */
    orderBy?: VideoActorOrderByWithRelationInput | VideoActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoActors
    **/
    _count?: true | VideoActorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoActorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoActorMaxAggregateInputType
  }

  export type GetVideoActorAggregateType<T extends VideoActorAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoActor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoActor[P]>
      : GetScalarType<T[P], AggregateVideoActor[P]>
  }




  export type VideoActorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoActorWhereInput
    orderBy?: VideoActorOrderByWithAggregationInput | VideoActorOrderByWithAggregationInput[]
    by: VideoActorScalarFieldEnum[] | VideoActorScalarFieldEnum
    having?: VideoActorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoActorCountAggregateInputType | true
    _min?: VideoActorMinAggregateInputType
    _max?: VideoActorMaxAggregateInputType
  }

  export type VideoActorGroupByOutputType = {
    videoId: string
    actorId: string
    role: string | null
    _count: VideoActorCountAggregateOutputType | null
    _min: VideoActorMinAggregateOutputType | null
    _max: VideoActorMaxAggregateOutputType | null
  }

  type GetVideoActorGroupByPayload<T extends VideoActorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoActorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoActorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoActorGroupByOutputType[P]>
            : GetScalarType<T[P], VideoActorGroupByOutputType[P]>
        }
      >
    >


  export type VideoActorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoId?: boolean
    actorId?: boolean
    role?: boolean
    video?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoActor"]>

  export type VideoActorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoId?: boolean
    actorId?: boolean
    role?: boolean
    video?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoActor"]>

  export type VideoActorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoId?: boolean
    actorId?: boolean
    role?: boolean
    video?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoActor"]>

  export type VideoActorSelectScalar = {
    videoId?: boolean
    actorId?: boolean
    role?: boolean
  }

  export type VideoActorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"videoId" | "actorId" | "role", ExtArgs["result"]["videoActor"]>
  export type VideoActorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }
  export type VideoActorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }
  export type VideoActorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }

  export type $VideoActorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoActor"
    objects: {
      video: Prisma.$VideoMetadataPayload<ExtArgs>
      actor: Prisma.$ActorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      videoId: string
      actorId: string
      role: string | null
    }, ExtArgs["result"]["videoActor"]>
    composites: {}
  }

  type VideoActorGetPayload<S extends boolean | null | undefined | VideoActorDefaultArgs> = $Result.GetResult<Prisma.$VideoActorPayload, S>

  type VideoActorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoActorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoActorCountAggregateInputType | true
    }

  export interface VideoActorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoActor'], meta: { name: 'VideoActor' } }
    /**
     * Find zero or one VideoActor that matches the filter.
     * @param {VideoActorFindUniqueArgs} args - Arguments to find a VideoActor
     * @example
     * // Get one VideoActor
     * const videoActor = await prisma.videoActor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoActorFindUniqueArgs>(args: SelectSubset<T, VideoActorFindUniqueArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoActor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoActorFindUniqueOrThrowArgs} args - Arguments to find a VideoActor
     * @example
     * // Get one VideoActor
     * const videoActor = await prisma.videoActor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoActorFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoActorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoActor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorFindFirstArgs} args - Arguments to find a VideoActor
     * @example
     * // Get one VideoActor
     * const videoActor = await prisma.videoActor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoActorFindFirstArgs>(args?: SelectSubset<T, VideoActorFindFirstArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoActor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorFindFirstOrThrowArgs} args - Arguments to find a VideoActor
     * @example
     * // Get one VideoActor
     * const videoActor = await prisma.videoActor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoActorFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoActorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoActors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoActors
     * const videoActors = await prisma.videoActor.findMany()
     * 
     * // Get first 10 VideoActors
     * const videoActors = await prisma.videoActor.findMany({ take: 10 })
     * 
     * // Only select the `videoId`
     * const videoActorWithVideoIdOnly = await prisma.videoActor.findMany({ select: { videoId: true } })
     * 
     */
    findMany<T extends VideoActorFindManyArgs>(args?: SelectSubset<T, VideoActorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoActor.
     * @param {VideoActorCreateArgs} args - Arguments to create a VideoActor.
     * @example
     * // Create one VideoActor
     * const VideoActor = await prisma.videoActor.create({
     *   data: {
     *     // ... data to create a VideoActor
     *   }
     * })
     * 
     */
    create<T extends VideoActorCreateArgs>(args: SelectSubset<T, VideoActorCreateArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoActors.
     * @param {VideoActorCreateManyArgs} args - Arguments to create many VideoActors.
     * @example
     * // Create many VideoActors
     * const videoActor = await prisma.videoActor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoActorCreateManyArgs>(args?: SelectSubset<T, VideoActorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoActors and returns the data saved in the database.
     * @param {VideoActorCreateManyAndReturnArgs} args - Arguments to create many VideoActors.
     * @example
     * // Create many VideoActors
     * const videoActor = await prisma.videoActor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoActors and only return the `videoId`
     * const videoActorWithVideoIdOnly = await prisma.videoActor.createManyAndReturn({
     *   select: { videoId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoActorCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoActorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoActor.
     * @param {VideoActorDeleteArgs} args - Arguments to delete one VideoActor.
     * @example
     * // Delete one VideoActor
     * const VideoActor = await prisma.videoActor.delete({
     *   where: {
     *     // ... filter to delete one VideoActor
     *   }
     * })
     * 
     */
    delete<T extends VideoActorDeleteArgs>(args: SelectSubset<T, VideoActorDeleteArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoActor.
     * @param {VideoActorUpdateArgs} args - Arguments to update one VideoActor.
     * @example
     * // Update one VideoActor
     * const videoActor = await prisma.videoActor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoActorUpdateArgs>(args: SelectSubset<T, VideoActorUpdateArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoActors.
     * @param {VideoActorDeleteManyArgs} args - Arguments to filter VideoActors to delete.
     * @example
     * // Delete a few VideoActors
     * const { count } = await prisma.videoActor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoActorDeleteManyArgs>(args?: SelectSubset<T, VideoActorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoActors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoActors
     * const videoActor = await prisma.videoActor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoActorUpdateManyArgs>(args: SelectSubset<T, VideoActorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoActors and returns the data updated in the database.
     * @param {VideoActorUpdateManyAndReturnArgs} args - Arguments to update many VideoActors.
     * @example
     * // Update many VideoActors
     * const videoActor = await prisma.videoActor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoActors and only return the `videoId`
     * const videoActorWithVideoIdOnly = await prisma.videoActor.updateManyAndReturn({
     *   select: { videoId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoActorUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoActorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoActor.
     * @param {VideoActorUpsertArgs} args - Arguments to update or create a VideoActor.
     * @example
     * // Update or create a VideoActor
     * const videoActor = await prisma.videoActor.upsert({
     *   create: {
     *     // ... data to create a VideoActor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoActor we want to update
     *   }
     * })
     */
    upsert<T extends VideoActorUpsertArgs>(args: SelectSubset<T, VideoActorUpsertArgs<ExtArgs>>): Prisma__VideoActorClient<$Result.GetResult<Prisma.$VideoActorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoActors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorCountArgs} args - Arguments to filter VideoActors to count.
     * @example
     * // Count the number of VideoActors
     * const count = await prisma.videoActor.count({
     *   where: {
     *     // ... the filter for the VideoActors we want to count
     *   }
     * })
    **/
    count<T extends VideoActorCountArgs>(
      args?: Subset<T, VideoActorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoActorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoActor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoActorAggregateArgs>(args: Subset<T, VideoActorAggregateArgs>): Prisma.PrismaPromise<GetVideoActorAggregateType<T>>

    /**
     * Group by VideoActor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoActorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoActorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoActorGroupByArgs['orderBy'] }
        : { orderBy?: VideoActorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoActorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoActorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoActor model
   */
  readonly fields: VideoActorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoActor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoActorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoMetadataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadataDefaultArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends ActorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActorDefaultArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoActor model
   */
  interface VideoActorFieldRefs {
    readonly videoId: FieldRef<"VideoActor", 'String'>
    readonly actorId: FieldRef<"VideoActor", 'String'>
    readonly role: FieldRef<"VideoActor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoActor findUnique
   */
  export type VideoActorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * Filter, which VideoActor to fetch.
     */
    where: VideoActorWhereUniqueInput
  }

  /**
   * VideoActor findUniqueOrThrow
   */
  export type VideoActorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * Filter, which VideoActor to fetch.
     */
    where: VideoActorWhereUniqueInput
  }

  /**
   * VideoActor findFirst
   */
  export type VideoActorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * Filter, which VideoActor to fetch.
     */
    where?: VideoActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoActors to fetch.
     */
    orderBy?: VideoActorOrderByWithRelationInput | VideoActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoActors.
     */
    cursor?: VideoActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoActors.
     */
    distinct?: VideoActorScalarFieldEnum | VideoActorScalarFieldEnum[]
  }

  /**
   * VideoActor findFirstOrThrow
   */
  export type VideoActorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * Filter, which VideoActor to fetch.
     */
    where?: VideoActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoActors to fetch.
     */
    orderBy?: VideoActorOrderByWithRelationInput | VideoActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoActors.
     */
    cursor?: VideoActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoActors.
     */
    distinct?: VideoActorScalarFieldEnum | VideoActorScalarFieldEnum[]
  }

  /**
   * VideoActor findMany
   */
  export type VideoActorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * Filter, which VideoActors to fetch.
     */
    where?: VideoActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoActors to fetch.
     */
    orderBy?: VideoActorOrderByWithRelationInput | VideoActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoActors.
     */
    cursor?: VideoActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoActors.
     */
    skip?: number
    distinct?: VideoActorScalarFieldEnum | VideoActorScalarFieldEnum[]
  }

  /**
   * VideoActor create
   */
  export type VideoActorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoActor.
     */
    data: XOR<VideoActorCreateInput, VideoActorUncheckedCreateInput>
  }

  /**
   * VideoActor createMany
   */
  export type VideoActorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoActors.
     */
    data: VideoActorCreateManyInput | VideoActorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoActor createManyAndReturn
   */
  export type VideoActorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * The data used to create many VideoActors.
     */
    data: VideoActorCreateManyInput | VideoActorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoActor update
   */
  export type VideoActorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoActor.
     */
    data: XOR<VideoActorUpdateInput, VideoActorUncheckedUpdateInput>
    /**
     * Choose, which VideoActor to update.
     */
    where: VideoActorWhereUniqueInput
  }

  /**
   * VideoActor updateMany
   */
  export type VideoActorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoActors.
     */
    data: XOR<VideoActorUpdateManyMutationInput, VideoActorUncheckedUpdateManyInput>
    /**
     * Filter which VideoActors to update
     */
    where?: VideoActorWhereInput
    /**
     * Limit how many VideoActors to update.
     */
    limit?: number
  }

  /**
   * VideoActor updateManyAndReturn
   */
  export type VideoActorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * The data used to update VideoActors.
     */
    data: XOR<VideoActorUpdateManyMutationInput, VideoActorUncheckedUpdateManyInput>
    /**
     * Filter which VideoActors to update
     */
    where?: VideoActorWhereInput
    /**
     * Limit how many VideoActors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoActor upsert
   */
  export type VideoActorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoActor to update in case it exists.
     */
    where: VideoActorWhereUniqueInput
    /**
     * In case the VideoActor found by the `where` argument doesn't exist, create a new VideoActor with this data.
     */
    create: XOR<VideoActorCreateInput, VideoActorUncheckedCreateInput>
    /**
     * In case the VideoActor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoActorUpdateInput, VideoActorUncheckedUpdateInput>
  }

  /**
   * VideoActor delete
   */
  export type VideoActorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
    /**
     * Filter which VideoActor to delete.
     */
    where: VideoActorWhereUniqueInput
  }

  /**
   * VideoActor deleteMany
   */
  export type VideoActorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoActors to delete
     */
    where?: VideoActorWhereInput
    /**
     * Limit how many VideoActors to delete.
     */
    limit?: number
  }

  /**
   * VideoActor without action
   */
  export type VideoActorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoActor
     */
    select?: VideoActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoActor
     */
    omit?: VideoActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoActorInclude<ExtArgs> | null
  }


  /**
   * Model VideoLanguage
   */

  export type AggregateVideoLanguage = {
    _count: VideoLanguageCountAggregateOutputType | null
    _min: VideoLanguageMinAggregateOutputType | null
    _max: VideoLanguageMaxAggregateOutputType | null
  }

  export type VideoLanguageMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
  }

  export type VideoLanguageMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
  }

  export type VideoLanguageCountAggregateOutputType = {
    id: number
    code: number
    name: number
    _all: number
  }


  export type VideoLanguageMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type VideoLanguageMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type VideoLanguageCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    _all?: true
  }

  export type VideoLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoLanguage to aggregate.
     */
    where?: VideoLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoLanguages to fetch.
     */
    orderBy?: VideoLanguageOrderByWithRelationInput | VideoLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoLanguages
    **/
    _count?: true | VideoLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoLanguageMaxAggregateInputType
  }

  export type GetVideoLanguageAggregateType<T extends VideoLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoLanguage[P]>
      : GetScalarType<T[P], AggregateVideoLanguage[P]>
  }




  export type VideoLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoLanguageWhereInput
    orderBy?: VideoLanguageOrderByWithAggregationInput | VideoLanguageOrderByWithAggregationInput[]
    by: VideoLanguageScalarFieldEnum[] | VideoLanguageScalarFieldEnum
    having?: VideoLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoLanguageCountAggregateInputType | true
    _min?: VideoLanguageMinAggregateInputType
    _max?: VideoLanguageMaxAggregateInputType
  }

  export type VideoLanguageGroupByOutputType = {
    id: string
    code: string
    name: string
    _count: VideoLanguageCountAggregateOutputType | null
    _min: VideoLanguageMinAggregateOutputType | null
    _max: VideoLanguageMaxAggregateOutputType | null
  }

  type GetVideoLanguageGroupByPayload<T extends VideoLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], VideoLanguageGroupByOutputType[P]>
        }
      >
    >


  export type VideoLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    videos?: boolean | VideoLanguage$videosArgs<ExtArgs>
    _count?: boolean | VideoLanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoLanguage"]>

  export type VideoLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["videoLanguage"]>

  export type VideoLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["videoLanguage"]>

  export type VideoLanguageSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
  }

  export type VideoLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name", ExtArgs["result"]["videoLanguage"]>
  export type VideoLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoLanguage$videosArgs<ExtArgs>
    _count?: boolean | VideoLanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VideoLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoLanguage"
    objects: {
      videos: Prisma.$VideoMetadataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
    }, ExtArgs["result"]["videoLanguage"]>
    composites: {}
  }

  type VideoLanguageGetPayload<S extends boolean | null | undefined | VideoLanguageDefaultArgs> = $Result.GetResult<Prisma.$VideoLanguagePayload, S>

  type VideoLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoLanguageCountAggregateInputType | true
    }

  export interface VideoLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoLanguage'], meta: { name: 'VideoLanguage' } }
    /**
     * Find zero or one VideoLanguage that matches the filter.
     * @param {VideoLanguageFindUniqueArgs} args - Arguments to find a VideoLanguage
     * @example
     * // Get one VideoLanguage
     * const videoLanguage = await prisma.videoLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoLanguageFindUniqueArgs>(args: SelectSubset<T, VideoLanguageFindUniqueArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoLanguageFindUniqueOrThrowArgs} args - Arguments to find a VideoLanguage
     * @example
     * // Get one VideoLanguage
     * const videoLanguage = await prisma.videoLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageFindFirstArgs} args - Arguments to find a VideoLanguage
     * @example
     * // Get one VideoLanguage
     * const videoLanguage = await prisma.videoLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoLanguageFindFirstArgs>(args?: SelectSubset<T, VideoLanguageFindFirstArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageFindFirstOrThrowArgs} args - Arguments to find a VideoLanguage
     * @example
     * // Get one VideoLanguage
     * const videoLanguage = await prisma.videoLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoLanguages
     * const videoLanguages = await prisma.videoLanguage.findMany()
     * 
     * // Get first 10 VideoLanguages
     * const videoLanguages = await prisma.videoLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoLanguageWithIdOnly = await prisma.videoLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoLanguageFindManyArgs>(args?: SelectSubset<T, VideoLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoLanguage.
     * @param {VideoLanguageCreateArgs} args - Arguments to create a VideoLanguage.
     * @example
     * // Create one VideoLanguage
     * const VideoLanguage = await prisma.videoLanguage.create({
     *   data: {
     *     // ... data to create a VideoLanguage
     *   }
     * })
     * 
     */
    create<T extends VideoLanguageCreateArgs>(args: SelectSubset<T, VideoLanguageCreateArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoLanguages.
     * @param {VideoLanguageCreateManyArgs} args - Arguments to create many VideoLanguages.
     * @example
     * // Create many VideoLanguages
     * const videoLanguage = await prisma.videoLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoLanguageCreateManyArgs>(args?: SelectSubset<T, VideoLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoLanguages and returns the data saved in the database.
     * @param {VideoLanguageCreateManyAndReturnArgs} args - Arguments to create many VideoLanguages.
     * @example
     * // Create many VideoLanguages
     * const videoLanguage = await prisma.videoLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoLanguages and only return the `id`
     * const videoLanguageWithIdOnly = await prisma.videoLanguage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoLanguage.
     * @param {VideoLanguageDeleteArgs} args - Arguments to delete one VideoLanguage.
     * @example
     * // Delete one VideoLanguage
     * const VideoLanguage = await prisma.videoLanguage.delete({
     *   where: {
     *     // ... filter to delete one VideoLanguage
     *   }
     * })
     * 
     */
    delete<T extends VideoLanguageDeleteArgs>(args: SelectSubset<T, VideoLanguageDeleteArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoLanguage.
     * @param {VideoLanguageUpdateArgs} args - Arguments to update one VideoLanguage.
     * @example
     * // Update one VideoLanguage
     * const videoLanguage = await prisma.videoLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoLanguageUpdateArgs>(args: SelectSubset<T, VideoLanguageUpdateArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoLanguages.
     * @param {VideoLanguageDeleteManyArgs} args - Arguments to filter VideoLanguages to delete.
     * @example
     * // Delete a few VideoLanguages
     * const { count } = await prisma.videoLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoLanguageDeleteManyArgs>(args?: SelectSubset<T, VideoLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoLanguages
     * const videoLanguage = await prisma.videoLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoLanguageUpdateManyArgs>(args: SelectSubset<T, VideoLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoLanguages and returns the data updated in the database.
     * @param {VideoLanguageUpdateManyAndReturnArgs} args - Arguments to update many VideoLanguages.
     * @example
     * // Update many VideoLanguages
     * const videoLanguage = await prisma.videoLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoLanguages and only return the `id`
     * const videoLanguageWithIdOnly = await prisma.videoLanguage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoLanguage.
     * @param {VideoLanguageUpsertArgs} args - Arguments to update or create a VideoLanguage.
     * @example
     * // Update or create a VideoLanguage
     * const videoLanguage = await prisma.videoLanguage.upsert({
     *   create: {
     *     // ... data to create a VideoLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoLanguage we want to update
     *   }
     * })
     */
    upsert<T extends VideoLanguageUpsertArgs>(args: SelectSubset<T, VideoLanguageUpsertArgs<ExtArgs>>): Prisma__VideoLanguageClient<$Result.GetResult<Prisma.$VideoLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageCountArgs} args - Arguments to filter VideoLanguages to count.
     * @example
     * // Count the number of VideoLanguages
     * const count = await prisma.videoLanguage.count({
     *   where: {
     *     // ... the filter for the VideoLanguages we want to count
     *   }
     * })
    **/
    count<T extends VideoLanguageCountArgs>(
      args?: Subset<T, VideoLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoLanguageAggregateArgs>(args: Subset<T, VideoLanguageAggregateArgs>): Prisma.PrismaPromise<GetVideoLanguageAggregateType<T>>

    /**
     * Group by VideoLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoLanguageGroupByArgs['orderBy'] }
        : { orderBy?: VideoLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoLanguage model
   */
  readonly fields: VideoLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends VideoLanguage$videosArgs<ExtArgs> = {}>(args?: Subset<T, VideoLanguage$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoLanguage model
   */
  interface VideoLanguageFieldRefs {
    readonly id: FieldRef<"VideoLanguage", 'String'>
    readonly code: FieldRef<"VideoLanguage", 'String'>
    readonly name: FieldRef<"VideoLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoLanguage findUnique
   */
  export type VideoLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * Filter, which VideoLanguage to fetch.
     */
    where: VideoLanguageWhereUniqueInput
  }

  /**
   * VideoLanguage findUniqueOrThrow
   */
  export type VideoLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * Filter, which VideoLanguage to fetch.
     */
    where: VideoLanguageWhereUniqueInput
  }

  /**
   * VideoLanguage findFirst
   */
  export type VideoLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * Filter, which VideoLanguage to fetch.
     */
    where?: VideoLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoLanguages to fetch.
     */
    orderBy?: VideoLanguageOrderByWithRelationInput | VideoLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoLanguages.
     */
    cursor?: VideoLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoLanguages.
     */
    distinct?: VideoLanguageScalarFieldEnum | VideoLanguageScalarFieldEnum[]
  }

  /**
   * VideoLanguage findFirstOrThrow
   */
  export type VideoLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * Filter, which VideoLanguage to fetch.
     */
    where?: VideoLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoLanguages to fetch.
     */
    orderBy?: VideoLanguageOrderByWithRelationInput | VideoLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoLanguages.
     */
    cursor?: VideoLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoLanguages.
     */
    distinct?: VideoLanguageScalarFieldEnum | VideoLanguageScalarFieldEnum[]
  }

  /**
   * VideoLanguage findMany
   */
  export type VideoLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * Filter, which VideoLanguages to fetch.
     */
    where?: VideoLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoLanguages to fetch.
     */
    orderBy?: VideoLanguageOrderByWithRelationInput | VideoLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoLanguages.
     */
    cursor?: VideoLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoLanguages.
     */
    skip?: number
    distinct?: VideoLanguageScalarFieldEnum | VideoLanguageScalarFieldEnum[]
  }

  /**
   * VideoLanguage create
   */
  export type VideoLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoLanguage.
     */
    data: XOR<VideoLanguageCreateInput, VideoLanguageUncheckedCreateInput>
  }

  /**
   * VideoLanguage createMany
   */
  export type VideoLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoLanguages.
     */
    data: VideoLanguageCreateManyInput | VideoLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoLanguage createManyAndReturn
   */
  export type VideoLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many VideoLanguages.
     */
    data: VideoLanguageCreateManyInput | VideoLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoLanguage update
   */
  export type VideoLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoLanguage.
     */
    data: XOR<VideoLanguageUpdateInput, VideoLanguageUncheckedUpdateInput>
    /**
     * Choose, which VideoLanguage to update.
     */
    where: VideoLanguageWhereUniqueInput
  }

  /**
   * VideoLanguage updateMany
   */
  export type VideoLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoLanguages.
     */
    data: XOR<VideoLanguageUpdateManyMutationInput, VideoLanguageUncheckedUpdateManyInput>
    /**
     * Filter which VideoLanguages to update
     */
    where?: VideoLanguageWhereInput
    /**
     * Limit how many VideoLanguages to update.
     */
    limit?: number
  }

  /**
   * VideoLanguage updateManyAndReturn
   */
  export type VideoLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * The data used to update VideoLanguages.
     */
    data: XOR<VideoLanguageUpdateManyMutationInput, VideoLanguageUncheckedUpdateManyInput>
    /**
     * Filter which VideoLanguages to update
     */
    where?: VideoLanguageWhereInput
    /**
     * Limit how many VideoLanguages to update.
     */
    limit?: number
  }

  /**
   * VideoLanguage upsert
   */
  export type VideoLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoLanguage to update in case it exists.
     */
    where: VideoLanguageWhereUniqueInput
    /**
     * In case the VideoLanguage found by the `where` argument doesn't exist, create a new VideoLanguage with this data.
     */
    create: XOR<VideoLanguageCreateInput, VideoLanguageUncheckedCreateInput>
    /**
     * In case the VideoLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoLanguageUpdateInput, VideoLanguageUncheckedUpdateInput>
  }

  /**
   * VideoLanguage delete
   */
  export type VideoLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
    /**
     * Filter which VideoLanguage to delete.
     */
    where: VideoLanguageWhereUniqueInput
  }

  /**
   * VideoLanguage deleteMany
   */
  export type VideoLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoLanguages to delete
     */
    where?: VideoLanguageWhereInput
    /**
     * Limit how many VideoLanguages to delete.
     */
    limit?: number
  }

  /**
   * VideoLanguage.videos
   */
  export type VideoLanguage$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    where?: VideoMetadataWhereInput
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    cursor?: VideoMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoLanguage without action
   */
  export type VideoLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoLanguage
     */
    select?: VideoLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoLanguage
     */
    omit?: VideoLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoLanguageInclude<ExtArgs> | null
  }


  /**
   * Model VideoFormat
   */

  export type AggregateVideoFormat = {
    _count: VideoFormatCountAggregateOutputType | null
    _min: VideoFormatMinAggregateOutputType | null
    _max: VideoFormatMaxAggregateOutputType | null
  }

  export type VideoFormatMinAggregateOutputType = {
    id: string | null
    format: string | null
    description: string | null
  }

  export type VideoFormatMaxAggregateOutputType = {
    id: string | null
    format: string | null
    description: string | null
  }

  export type VideoFormatCountAggregateOutputType = {
    id: number
    format: number
    description: number
    _all: number
  }


  export type VideoFormatMinAggregateInputType = {
    id?: true
    format?: true
    description?: true
  }

  export type VideoFormatMaxAggregateInputType = {
    id?: true
    format?: true
    description?: true
  }

  export type VideoFormatCountAggregateInputType = {
    id?: true
    format?: true
    description?: true
    _all?: true
  }

  export type VideoFormatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoFormat to aggregate.
     */
    where?: VideoFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFormats to fetch.
     */
    orderBy?: VideoFormatOrderByWithRelationInput | VideoFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFormats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoFormats
    **/
    _count?: true | VideoFormatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoFormatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoFormatMaxAggregateInputType
  }

  export type GetVideoFormatAggregateType<T extends VideoFormatAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoFormat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoFormat[P]>
      : GetScalarType<T[P], AggregateVideoFormat[P]>
  }




  export type VideoFormatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoFormatWhereInput
    orderBy?: VideoFormatOrderByWithAggregationInput | VideoFormatOrderByWithAggregationInput[]
    by: VideoFormatScalarFieldEnum[] | VideoFormatScalarFieldEnum
    having?: VideoFormatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoFormatCountAggregateInputType | true
    _min?: VideoFormatMinAggregateInputType
    _max?: VideoFormatMaxAggregateInputType
  }

  export type VideoFormatGroupByOutputType = {
    id: string
    format: string
    description: string | null
    _count: VideoFormatCountAggregateOutputType | null
    _min: VideoFormatMinAggregateOutputType | null
    _max: VideoFormatMaxAggregateOutputType | null
  }

  type GetVideoFormatGroupByPayload<T extends VideoFormatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoFormatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoFormatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoFormatGroupByOutputType[P]>
            : GetScalarType<T[P], VideoFormatGroupByOutputType[P]>
        }
      >
    >


  export type VideoFormatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    format?: boolean
    description?: boolean
    videos?: boolean | VideoFormat$videosArgs<ExtArgs>
    _count?: boolean | VideoFormatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoFormat"]>

  export type VideoFormatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    format?: boolean
    description?: boolean
  }, ExtArgs["result"]["videoFormat"]>

  export type VideoFormatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    format?: boolean
    description?: boolean
  }, ExtArgs["result"]["videoFormat"]>

  export type VideoFormatSelectScalar = {
    id?: boolean
    format?: boolean
    description?: boolean
  }

  export type VideoFormatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "format" | "description", ExtArgs["result"]["videoFormat"]>
  export type VideoFormatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoFormat$videosArgs<ExtArgs>
    _count?: boolean | VideoFormatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoFormatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VideoFormatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoFormatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoFormat"
    objects: {
      videos: Prisma.$VideoMetadataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      format: string
      description: string | null
    }, ExtArgs["result"]["videoFormat"]>
    composites: {}
  }

  type VideoFormatGetPayload<S extends boolean | null | undefined | VideoFormatDefaultArgs> = $Result.GetResult<Prisma.$VideoFormatPayload, S>

  type VideoFormatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFormatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoFormatCountAggregateInputType | true
    }

  export interface VideoFormatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoFormat'], meta: { name: 'VideoFormat' } }
    /**
     * Find zero or one VideoFormat that matches the filter.
     * @param {VideoFormatFindUniqueArgs} args - Arguments to find a VideoFormat
     * @example
     * // Get one VideoFormat
     * const videoFormat = await prisma.videoFormat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFormatFindUniqueArgs>(args: SelectSubset<T, VideoFormatFindUniqueArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoFormat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFormatFindUniqueOrThrowArgs} args - Arguments to find a VideoFormat
     * @example
     * // Get one VideoFormat
     * const videoFormat = await prisma.videoFormat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFormatFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFormatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoFormat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatFindFirstArgs} args - Arguments to find a VideoFormat
     * @example
     * // Get one VideoFormat
     * const videoFormat = await prisma.videoFormat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFormatFindFirstArgs>(args?: SelectSubset<T, VideoFormatFindFirstArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoFormat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatFindFirstOrThrowArgs} args - Arguments to find a VideoFormat
     * @example
     * // Get one VideoFormat
     * const videoFormat = await prisma.videoFormat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFormatFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFormatFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoFormats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoFormats
     * const videoFormats = await prisma.videoFormat.findMany()
     * 
     * // Get first 10 VideoFormats
     * const videoFormats = await prisma.videoFormat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoFormatWithIdOnly = await prisma.videoFormat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFormatFindManyArgs>(args?: SelectSubset<T, VideoFormatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoFormat.
     * @param {VideoFormatCreateArgs} args - Arguments to create a VideoFormat.
     * @example
     * // Create one VideoFormat
     * const VideoFormat = await prisma.videoFormat.create({
     *   data: {
     *     // ... data to create a VideoFormat
     *   }
     * })
     * 
     */
    create<T extends VideoFormatCreateArgs>(args: SelectSubset<T, VideoFormatCreateArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoFormats.
     * @param {VideoFormatCreateManyArgs} args - Arguments to create many VideoFormats.
     * @example
     * // Create many VideoFormats
     * const videoFormat = await prisma.videoFormat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoFormatCreateManyArgs>(args?: SelectSubset<T, VideoFormatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoFormats and returns the data saved in the database.
     * @param {VideoFormatCreateManyAndReturnArgs} args - Arguments to create many VideoFormats.
     * @example
     * // Create many VideoFormats
     * const videoFormat = await prisma.videoFormat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoFormats and only return the `id`
     * const videoFormatWithIdOnly = await prisma.videoFormat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoFormatCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoFormatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoFormat.
     * @param {VideoFormatDeleteArgs} args - Arguments to delete one VideoFormat.
     * @example
     * // Delete one VideoFormat
     * const VideoFormat = await prisma.videoFormat.delete({
     *   where: {
     *     // ... filter to delete one VideoFormat
     *   }
     * })
     * 
     */
    delete<T extends VideoFormatDeleteArgs>(args: SelectSubset<T, VideoFormatDeleteArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoFormat.
     * @param {VideoFormatUpdateArgs} args - Arguments to update one VideoFormat.
     * @example
     * // Update one VideoFormat
     * const videoFormat = await prisma.videoFormat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoFormatUpdateArgs>(args: SelectSubset<T, VideoFormatUpdateArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoFormats.
     * @param {VideoFormatDeleteManyArgs} args - Arguments to filter VideoFormats to delete.
     * @example
     * // Delete a few VideoFormats
     * const { count } = await prisma.videoFormat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoFormatDeleteManyArgs>(args?: SelectSubset<T, VideoFormatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoFormats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoFormats
     * const videoFormat = await prisma.videoFormat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoFormatUpdateManyArgs>(args: SelectSubset<T, VideoFormatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoFormats and returns the data updated in the database.
     * @param {VideoFormatUpdateManyAndReturnArgs} args - Arguments to update many VideoFormats.
     * @example
     * // Update many VideoFormats
     * const videoFormat = await prisma.videoFormat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoFormats and only return the `id`
     * const videoFormatWithIdOnly = await prisma.videoFormat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoFormatUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoFormatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoFormat.
     * @param {VideoFormatUpsertArgs} args - Arguments to update or create a VideoFormat.
     * @example
     * // Update or create a VideoFormat
     * const videoFormat = await prisma.videoFormat.upsert({
     *   create: {
     *     // ... data to create a VideoFormat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoFormat we want to update
     *   }
     * })
     */
    upsert<T extends VideoFormatUpsertArgs>(args: SelectSubset<T, VideoFormatUpsertArgs<ExtArgs>>): Prisma__VideoFormatClient<$Result.GetResult<Prisma.$VideoFormatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoFormats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatCountArgs} args - Arguments to filter VideoFormats to count.
     * @example
     * // Count the number of VideoFormats
     * const count = await prisma.videoFormat.count({
     *   where: {
     *     // ... the filter for the VideoFormats we want to count
     *   }
     * })
    **/
    count<T extends VideoFormatCountArgs>(
      args?: Subset<T, VideoFormatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoFormatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoFormat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoFormatAggregateArgs>(args: Subset<T, VideoFormatAggregateArgs>): Prisma.PrismaPromise<GetVideoFormatAggregateType<T>>

    /**
     * Group by VideoFormat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFormatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoFormatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoFormatGroupByArgs['orderBy'] }
        : { orderBy?: VideoFormatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoFormatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoFormatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoFormat model
   */
  readonly fields: VideoFormatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoFormat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoFormatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends VideoFormat$videosArgs<ExtArgs> = {}>(args?: Subset<T, VideoFormat$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoFormat model
   */
  interface VideoFormatFieldRefs {
    readonly id: FieldRef<"VideoFormat", 'String'>
    readonly format: FieldRef<"VideoFormat", 'String'>
    readonly description: FieldRef<"VideoFormat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoFormat findUnique
   */
  export type VideoFormatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * Filter, which VideoFormat to fetch.
     */
    where: VideoFormatWhereUniqueInput
  }

  /**
   * VideoFormat findUniqueOrThrow
   */
  export type VideoFormatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * Filter, which VideoFormat to fetch.
     */
    where: VideoFormatWhereUniqueInput
  }

  /**
   * VideoFormat findFirst
   */
  export type VideoFormatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * Filter, which VideoFormat to fetch.
     */
    where?: VideoFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFormats to fetch.
     */
    orderBy?: VideoFormatOrderByWithRelationInput | VideoFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoFormats.
     */
    cursor?: VideoFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFormats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoFormats.
     */
    distinct?: VideoFormatScalarFieldEnum | VideoFormatScalarFieldEnum[]
  }

  /**
   * VideoFormat findFirstOrThrow
   */
  export type VideoFormatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * Filter, which VideoFormat to fetch.
     */
    where?: VideoFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFormats to fetch.
     */
    orderBy?: VideoFormatOrderByWithRelationInput | VideoFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoFormats.
     */
    cursor?: VideoFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFormats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoFormats.
     */
    distinct?: VideoFormatScalarFieldEnum | VideoFormatScalarFieldEnum[]
  }

  /**
   * VideoFormat findMany
   */
  export type VideoFormatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * Filter, which VideoFormats to fetch.
     */
    where?: VideoFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoFormats to fetch.
     */
    orderBy?: VideoFormatOrderByWithRelationInput | VideoFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoFormats.
     */
    cursor?: VideoFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoFormats.
     */
    skip?: number
    distinct?: VideoFormatScalarFieldEnum | VideoFormatScalarFieldEnum[]
  }

  /**
   * VideoFormat create
   */
  export type VideoFormatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoFormat.
     */
    data: XOR<VideoFormatCreateInput, VideoFormatUncheckedCreateInput>
  }

  /**
   * VideoFormat createMany
   */
  export type VideoFormatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoFormats.
     */
    data: VideoFormatCreateManyInput | VideoFormatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoFormat createManyAndReturn
   */
  export type VideoFormatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * The data used to create many VideoFormats.
     */
    data: VideoFormatCreateManyInput | VideoFormatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoFormat update
   */
  export type VideoFormatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoFormat.
     */
    data: XOR<VideoFormatUpdateInput, VideoFormatUncheckedUpdateInput>
    /**
     * Choose, which VideoFormat to update.
     */
    where: VideoFormatWhereUniqueInput
  }

  /**
   * VideoFormat updateMany
   */
  export type VideoFormatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoFormats.
     */
    data: XOR<VideoFormatUpdateManyMutationInput, VideoFormatUncheckedUpdateManyInput>
    /**
     * Filter which VideoFormats to update
     */
    where?: VideoFormatWhereInput
    /**
     * Limit how many VideoFormats to update.
     */
    limit?: number
  }

  /**
   * VideoFormat updateManyAndReturn
   */
  export type VideoFormatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * The data used to update VideoFormats.
     */
    data: XOR<VideoFormatUpdateManyMutationInput, VideoFormatUncheckedUpdateManyInput>
    /**
     * Filter which VideoFormats to update
     */
    where?: VideoFormatWhereInput
    /**
     * Limit how many VideoFormats to update.
     */
    limit?: number
  }

  /**
   * VideoFormat upsert
   */
  export type VideoFormatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoFormat to update in case it exists.
     */
    where: VideoFormatWhereUniqueInput
    /**
     * In case the VideoFormat found by the `where` argument doesn't exist, create a new VideoFormat with this data.
     */
    create: XOR<VideoFormatCreateInput, VideoFormatUncheckedCreateInput>
    /**
     * In case the VideoFormat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoFormatUpdateInput, VideoFormatUncheckedUpdateInput>
  }

  /**
   * VideoFormat delete
   */
  export type VideoFormatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
    /**
     * Filter which VideoFormat to delete.
     */
    where: VideoFormatWhereUniqueInput
  }

  /**
   * VideoFormat deleteMany
   */
  export type VideoFormatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoFormats to delete
     */
    where?: VideoFormatWhereInput
    /**
     * Limit how many VideoFormats to delete.
     */
    limit?: number
  }

  /**
   * VideoFormat.videos
   */
  export type VideoFormat$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    where?: VideoMetadataWhereInput
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    cursor?: VideoMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoFormat without action
   */
  export type VideoFormatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoFormat
     */
    select?: VideoFormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoFormat
     */
    omit?: VideoFormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoFormatInclude<ExtArgs> | null
  }


  /**
   * Model VideoCategory
   */

  export type AggregateVideoCategory = {
    _count: VideoCategoryCountAggregateOutputType | null
    _min: VideoCategoryMinAggregateOutputType | null
    _max: VideoCategoryMaxAggregateOutputType | null
  }

  export type VideoCategoryMinAggregateOutputType = {
    id: string | null
    category: string | null
    description: string | null
  }

  export type VideoCategoryMaxAggregateOutputType = {
    id: string | null
    category: string | null
    description: string | null
  }

  export type VideoCategoryCountAggregateOutputType = {
    id: number
    category: number
    description: number
    _all: number
  }


  export type VideoCategoryMinAggregateInputType = {
    id?: true
    category?: true
    description?: true
  }

  export type VideoCategoryMaxAggregateInputType = {
    id?: true
    category?: true
    description?: true
  }

  export type VideoCategoryCountAggregateInputType = {
    id?: true
    category?: true
    description?: true
    _all?: true
  }

  export type VideoCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoCategory to aggregate.
     */
    where?: VideoCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCategories to fetch.
     */
    orderBy?: VideoCategoryOrderByWithRelationInput | VideoCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoCategories
    **/
    _count?: true | VideoCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoCategoryMaxAggregateInputType
  }

  export type GetVideoCategoryAggregateType<T extends VideoCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoCategory[P]>
      : GetScalarType<T[P], AggregateVideoCategory[P]>
  }




  export type VideoCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoCategoryWhereInput
    orderBy?: VideoCategoryOrderByWithAggregationInput | VideoCategoryOrderByWithAggregationInput[]
    by: VideoCategoryScalarFieldEnum[] | VideoCategoryScalarFieldEnum
    having?: VideoCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCategoryCountAggregateInputType | true
    _min?: VideoCategoryMinAggregateInputType
    _max?: VideoCategoryMaxAggregateInputType
  }

  export type VideoCategoryGroupByOutputType = {
    id: string
    category: string
    description: string | null
    _count: VideoCategoryCountAggregateOutputType | null
    _min: VideoCategoryMinAggregateOutputType | null
    _max: VideoCategoryMaxAggregateOutputType | null
  }

  type GetVideoCategoryGroupByPayload<T extends VideoCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], VideoCategoryGroupByOutputType[P]>
        }
      >
    >


  export type VideoCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    description?: boolean
    videos?: boolean | VideoCategory$videosArgs<ExtArgs>
    _count?: boolean | VideoCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoCategory"]>

  export type VideoCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    description?: boolean
  }, ExtArgs["result"]["videoCategory"]>

  export type VideoCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    description?: boolean
  }, ExtArgs["result"]["videoCategory"]>

  export type VideoCategorySelectScalar = {
    id?: boolean
    category?: boolean
    description?: boolean
  }

  export type VideoCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "description", ExtArgs["result"]["videoCategory"]>
  export type VideoCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | VideoCategory$videosArgs<ExtArgs>
    _count?: boolean | VideoCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VideoCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoCategory"
    objects: {
      videos: Prisma.$VideoMetadataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      description: string | null
    }, ExtArgs["result"]["videoCategory"]>
    composites: {}
  }

  type VideoCategoryGetPayload<S extends boolean | null | undefined | VideoCategoryDefaultArgs> = $Result.GetResult<Prisma.$VideoCategoryPayload, S>

  type VideoCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCategoryCountAggregateInputType | true
    }

  export interface VideoCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoCategory'], meta: { name: 'VideoCategory' } }
    /**
     * Find zero or one VideoCategory that matches the filter.
     * @param {VideoCategoryFindUniqueArgs} args - Arguments to find a VideoCategory
     * @example
     * // Get one VideoCategory
     * const videoCategory = await prisma.videoCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoCategoryFindUniqueArgs>(args: SelectSubset<T, VideoCategoryFindUniqueArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoCategoryFindUniqueOrThrowArgs} args - Arguments to find a VideoCategory
     * @example
     * // Get one VideoCategory
     * const videoCategory = await prisma.videoCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryFindFirstArgs} args - Arguments to find a VideoCategory
     * @example
     * // Get one VideoCategory
     * const videoCategory = await prisma.videoCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoCategoryFindFirstArgs>(args?: SelectSubset<T, VideoCategoryFindFirstArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryFindFirstOrThrowArgs} args - Arguments to find a VideoCategory
     * @example
     * // Get one VideoCategory
     * const videoCategory = await prisma.videoCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoCategories
     * const videoCategories = await prisma.videoCategory.findMany()
     * 
     * // Get first 10 VideoCategories
     * const videoCategories = await prisma.videoCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoCategoryWithIdOnly = await prisma.videoCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoCategoryFindManyArgs>(args?: SelectSubset<T, VideoCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoCategory.
     * @param {VideoCategoryCreateArgs} args - Arguments to create a VideoCategory.
     * @example
     * // Create one VideoCategory
     * const VideoCategory = await prisma.videoCategory.create({
     *   data: {
     *     // ... data to create a VideoCategory
     *   }
     * })
     * 
     */
    create<T extends VideoCategoryCreateArgs>(args: SelectSubset<T, VideoCategoryCreateArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoCategories.
     * @param {VideoCategoryCreateManyArgs} args - Arguments to create many VideoCategories.
     * @example
     * // Create many VideoCategories
     * const videoCategory = await prisma.videoCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCategoryCreateManyArgs>(args?: SelectSubset<T, VideoCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoCategories and returns the data saved in the database.
     * @param {VideoCategoryCreateManyAndReturnArgs} args - Arguments to create many VideoCategories.
     * @example
     * // Create many VideoCategories
     * const videoCategory = await prisma.videoCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoCategories and only return the `id`
     * const videoCategoryWithIdOnly = await prisma.videoCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoCategory.
     * @param {VideoCategoryDeleteArgs} args - Arguments to delete one VideoCategory.
     * @example
     * // Delete one VideoCategory
     * const VideoCategory = await prisma.videoCategory.delete({
     *   where: {
     *     // ... filter to delete one VideoCategory
     *   }
     * })
     * 
     */
    delete<T extends VideoCategoryDeleteArgs>(args: SelectSubset<T, VideoCategoryDeleteArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoCategory.
     * @param {VideoCategoryUpdateArgs} args - Arguments to update one VideoCategory.
     * @example
     * // Update one VideoCategory
     * const videoCategory = await prisma.videoCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoCategoryUpdateArgs>(args: SelectSubset<T, VideoCategoryUpdateArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoCategories.
     * @param {VideoCategoryDeleteManyArgs} args - Arguments to filter VideoCategories to delete.
     * @example
     * // Delete a few VideoCategories
     * const { count } = await prisma.videoCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoCategoryDeleteManyArgs>(args?: SelectSubset<T, VideoCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoCategories
     * const videoCategory = await prisma.videoCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoCategoryUpdateManyArgs>(args: SelectSubset<T, VideoCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoCategories and returns the data updated in the database.
     * @param {VideoCategoryUpdateManyAndReturnArgs} args - Arguments to update many VideoCategories.
     * @example
     * // Update many VideoCategories
     * const videoCategory = await prisma.videoCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoCategories and only return the `id`
     * const videoCategoryWithIdOnly = await prisma.videoCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoCategory.
     * @param {VideoCategoryUpsertArgs} args - Arguments to update or create a VideoCategory.
     * @example
     * // Update or create a VideoCategory
     * const videoCategory = await prisma.videoCategory.upsert({
     *   create: {
     *     // ... data to create a VideoCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoCategory we want to update
     *   }
     * })
     */
    upsert<T extends VideoCategoryUpsertArgs>(args: SelectSubset<T, VideoCategoryUpsertArgs<ExtArgs>>): Prisma__VideoCategoryClient<$Result.GetResult<Prisma.$VideoCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryCountArgs} args - Arguments to filter VideoCategories to count.
     * @example
     * // Count the number of VideoCategories
     * const count = await prisma.videoCategory.count({
     *   where: {
     *     // ... the filter for the VideoCategories we want to count
     *   }
     * })
    **/
    count<T extends VideoCategoryCountArgs>(
      args?: Subset<T, VideoCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoCategoryAggregateArgs>(args: Subset<T, VideoCategoryAggregateArgs>): Prisma.PrismaPromise<GetVideoCategoryAggregateType<T>>

    /**
     * Group by VideoCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoCategoryGroupByArgs['orderBy'] }
        : { orderBy?: VideoCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoCategory model
   */
  readonly fields: VideoCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends VideoCategory$videosArgs<ExtArgs> = {}>(args?: Subset<T, VideoCategory$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoCategory model
   */
  interface VideoCategoryFieldRefs {
    readonly id: FieldRef<"VideoCategory", 'String'>
    readonly category: FieldRef<"VideoCategory", 'String'>
    readonly description: FieldRef<"VideoCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoCategory findUnique
   */
  export type VideoCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VideoCategory to fetch.
     */
    where: VideoCategoryWhereUniqueInput
  }

  /**
   * VideoCategory findUniqueOrThrow
   */
  export type VideoCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VideoCategory to fetch.
     */
    where: VideoCategoryWhereUniqueInput
  }

  /**
   * VideoCategory findFirst
   */
  export type VideoCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VideoCategory to fetch.
     */
    where?: VideoCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCategories to fetch.
     */
    orderBy?: VideoCategoryOrderByWithRelationInput | VideoCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoCategories.
     */
    cursor?: VideoCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoCategories.
     */
    distinct?: VideoCategoryScalarFieldEnum | VideoCategoryScalarFieldEnum[]
  }

  /**
   * VideoCategory findFirstOrThrow
   */
  export type VideoCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VideoCategory to fetch.
     */
    where?: VideoCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCategories to fetch.
     */
    orderBy?: VideoCategoryOrderByWithRelationInput | VideoCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoCategories.
     */
    cursor?: VideoCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoCategories.
     */
    distinct?: VideoCategoryScalarFieldEnum | VideoCategoryScalarFieldEnum[]
  }

  /**
   * VideoCategory findMany
   */
  export type VideoCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VideoCategories to fetch.
     */
    where?: VideoCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCategories to fetch.
     */
    orderBy?: VideoCategoryOrderByWithRelationInput | VideoCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoCategories.
     */
    cursor?: VideoCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCategories.
     */
    skip?: number
    distinct?: VideoCategoryScalarFieldEnum | VideoCategoryScalarFieldEnum[]
  }

  /**
   * VideoCategory create
   */
  export type VideoCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoCategory.
     */
    data: XOR<VideoCategoryCreateInput, VideoCategoryUncheckedCreateInput>
  }

  /**
   * VideoCategory createMany
   */
  export type VideoCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoCategories.
     */
    data: VideoCategoryCreateManyInput | VideoCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoCategory createManyAndReturn
   */
  export type VideoCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many VideoCategories.
     */
    data: VideoCategoryCreateManyInput | VideoCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoCategory update
   */
  export type VideoCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoCategory.
     */
    data: XOR<VideoCategoryUpdateInput, VideoCategoryUncheckedUpdateInput>
    /**
     * Choose, which VideoCategory to update.
     */
    where: VideoCategoryWhereUniqueInput
  }

  /**
   * VideoCategory updateMany
   */
  export type VideoCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoCategories.
     */
    data: XOR<VideoCategoryUpdateManyMutationInput, VideoCategoryUncheckedUpdateManyInput>
    /**
     * Filter which VideoCategories to update
     */
    where?: VideoCategoryWhereInput
    /**
     * Limit how many VideoCategories to update.
     */
    limit?: number
  }

  /**
   * VideoCategory updateManyAndReturn
   */
  export type VideoCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * The data used to update VideoCategories.
     */
    data: XOR<VideoCategoryUpdateManyMutationInput, VideoCategoryUncheckedUpdateManyInput>
    /**
     * Filter which VideoCategories to update
     */
    where?: VideoCategoryWhereInput
    /**
     * Limit how many VideoCategories to update.
     */
    limit?: number
  }

  /**
   * VideoCategory upsert
   */
  export type VideoCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoCategory to update in case it exists.
     */
    where: VideoCategoryWhereUniqueInput
    /**
     * In case the VideoCategory found by the `where` argument doesn't exist, create a new VideoCategory with this data.
     */
    create: XOR<VideoCategoryCreateInput, VideoCategoryUncheckedCreateInput>
    /**
     * In case the VideoCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoCategoryUpdateInput, VideoCategoryUncheckedUpdateInput>
  }

  /**
   * VideoCategory delete
   */
  export type VideoCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
    /**
     * Filter which VideoCategory to delete.
     */
    where: VideoCategoryWhereUniqueInput
  }

  /**
   * VideoCategory deleteMany
   */
  export type VideoCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoCategories to delete
     */
    where?: VideoCategoryWhereInput
    /**
     * Limit how many VideoCategories to delete.
     */
    limit?: number
  }

  /**
   * VideoCategory.videos
   */
  export type VideoCategory$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    where?: VideoMetadataWhereInput
    orderBy?: VideoMetadataOrderByWithRelationInput | VideoMetadataOrderByWithRelationInput[]
    cursor?: VideoMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoMetadataScalarFieldEnum | VideoMetadataScalarFieldEnum[]
  }

  /**
   * VideoCategory without action
   */
  export type VideoCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCategory
     */
    select?: VideoCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoCategory
     */
    omit?: VideoCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Movie
   */

  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieAvgAggregateOutputType = {
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type MovieSumAggregateOutputType = {
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type MovieMinAggregateOutputType = {
    id: string | null
    metadataId: string | null
    videoFileId: string | null
    status: string | null
    type: string | null
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type MovieMaxAggregateOutputType = {
    id: string | null
    metadataId: string | null
    videoFileId: string | null
    status: string | null
    type: string | null
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type MovieCountAggregateOutputType = {
    id: number
    metadataId: number
    videoFileId: number
    status: number
    type: number
    seasonCount: number
    rentalPrice: number
    _all: number
  }


  export type MovieAvgAggregateInputType = {
    seasonCount?: true
    rentalPrice?: true
  }

  export type MovieSumAggregateInputType = {
    seasonCount?: true
    rentalPrice?: true
  }

  export type MovieMinAggregateInputType = {
    id?: true
    metadataId?: true
    videoFileId?: true
    status?: true
    type?: true
    seasonCount?: true
    rentalPrice?: true
  }

  export type MovieMaxAggregateInputType = {
    id?: true
    metadataId?: true
    videoFileId?: true
    status?: true
    type?: true
    seasonCount?: true
    rentalPrice?: true
  }

  export type MovieCountAggregateInputType = {
    id?: true
    metadataId?: true
    videoFileId?: true
    status?: true
    type?: true
    seasonCount?: true
    rentalPrice?: true
    _all?: true
  }

  export type MovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movie to aggregate.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithAggregationInput | MovieOrderByWithAggregationInput[]
    by: MovieScalarFieldEnum[] | MovieScalarFieldEnum
    having?: MovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _avg?: MovieAvgAggregateInputType
    _sum?: MovieSumAggregateInputType
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }

  export type MovieGroupByOutputType = {
    id: string
    metadataId: string
    videoFileId: string
    status: string
    type: string
    seasonCount: number
    rentalPrice: number | null
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type MovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadataId?: boolean
    videoFileId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    tags?: boolean | Movie$tagsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadataId?: boolean
    videoFileId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadataId?: boolean
    videoFileId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectScalar = {
    id?: boolean
    metadataId?: boolean
    videoFileId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
  }

  export type MovieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metadataId" | "videoFileId" | "status" | "type" | "seasonCount" | "rentalPrice", ExtArgs["result"]["movie"]>
  export type MovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    tags?: boolean | Movie$tagsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
  }
  export type MovieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
  }

  export type $MoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movie"
    objects: {
      metadata: Prisma.$VideoMetadataPayload<ExtArgs>
      videoFile: Prisma.$VideoFilePayload<ExtArgs>
      tags: Prisma.$MovieTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metadataId: string
      videoFileId: string
      status: string
      type: string
      seasonCount: number
      rentalPrice: number | null
    }, ExtArgs["result"]["movie"]>
    composites: {}
  }

  type MovieGetPayload<S extends boolean | null | undefined | MovieDefaultArgs> = $Result.GetResult<Prisma.$MoviePayload, S>

  type MovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface MovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movie'], meta: { name: 'Movie' } }
    /**
     * Find zero or one Movie that matches the filter.
     * @param {MovieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieFindUniqueArgs>(args: SelectSubset<T, MovieFindUniqueArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Movie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieFindFirstArgs>(args?: SelectSubset<T, MovieFindFirstArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieFindManyArgs>(args?: SelectSubset<T, MovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Movie.
     * @param {MovieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
     */
    create<T extends MovieCreateArgs>(args: SelectSubset<T, MovieCreateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Movies.
     * @param {MovieCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCreateManyArgs>(args?: SelectSubset<T, MovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {MovieCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `id`
     * const movieWithIdOnly = await prisma.movie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Movie.
     * @param {MovieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
     */
    delete<T extends MovieDeleteArgs>(args: SelectSubset<T, MovieDeleteArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Movie.
     * @param {MovieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieUpdateArgs>(args: SelectSubset<T, MovieUpdateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Movies.
     * @param {MovieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDeleteManyArgs>(args?: SelectSubset<T, MovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieUpdateManyArgs>(args: SelectSubset<T, MovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies and returns the data updated in the database.
     * @param {MovieUpdateManyAndReturnArgs} args - Arguments to update many Movies.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Movies and only return the `id`
     * const movieWithIdOnly = await prisma.movie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Movie.
     * @param {MovieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
     */
    upsert<T extends MovieUpsertArgs>(args: SelectSubset<T, MovieUpsertArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MovieCountArgs>(
      args?: Subset<T, MovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movie model
   */
  readonly fields: MovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    metadata<T extends VideoMetadataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadataDefaultArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videoFile<T extends VideoFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFileDefaultArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Movie$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movie model
   */
  interface MovieFieldRefs {
    readonly id: FieldRef<"Movie", 'String'>
    readonly metadataId: FieldRef<"Movie", 'String'>
    readonly videoFileId: FieldRef<"Movie", 'String'>
    readonly status: FieldRef<"Movie", 'String'>
    readonly type: FieldRef<"Movie", 'String'>
    readonly seasonCount: FieldRef<"Movie", 'Int'>
    readonly rentalPrice: FieldRef<"Movie", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Movie findUnique
   */
  export type MovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findUniqueOrThrow
   */
  export type MovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findFirst
   */
  export type MovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findFirstOrThrow
   */
  export type MovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findMany
   */
  export type MovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie create
   */
  export type MovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to create a Movie.
     */
    data: XOR<MovieCreateInput, MovieUncheckedCreateInput>
  }

  /**
   * Movie createMany
   */
  export type MovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie createManyAndReturn
   */
  export type MovieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Movie update
   */
  export type MovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to update a Movie.
     */
    data: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
    /**
     * Choose, which Movie to update.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie updateMany
   */
  export type MovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
    /**
     * Limit how many Movies to update.
     */
    limit?: number
  }

  /**
   * Movie updateManyAndReturn
   */
  export type MovieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
    /**
     * Limit how many Movies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Movie upsert
   */
  export type MovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The filter to search for the Movie to update in case it exists.
     */
    where: MovieWhereUniqueInput
    /**
     * In case the Movie found by the `where` argument doesn't exist, create a new Movie with this data.
     */
    create: XOR<MovieCreateInput, MovieUncheckedCreateInput>
    /**
     * In case the Movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
  }

  /**
   * Movie delete
   */
  export type MovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter which Movie to delete.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie deleteMany
   */
  export type MovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MovieWhereInput
    /**
     * Limit how many Movies to delete.
     */
    limit?: number
  }

  /**
   * Movie.tags
   */
  export type Movie$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    where?: MovieTagWhereInput
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    cursor?: MovieTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * Movie without action
   */
  export type MovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movie
     */
    omit?: MovieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
  }


  /**
   * Model Series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  export type SeriesAvgAggregateOutputType = {
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type SeriesSumAggregateOutputType = {
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type SeriesMinAggregateOutputType = {
    id: string | null
    metadataId: string | null
    status: string | null
    type: string | null
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type SeriesMaxAggregateOutputType = {
    id: string | null
    metadataId: string | null
    status: string | null
    type: string | null
    seasonCount: number | null
    rentalPrice: number | null
  }

  export type SeriesCountAggregateOutputType = {
    id: number
    metadataId: number
    status: number
    type: number
    seasonCount: number
    rentalPrice: number
    _all: number
  }


  export type SeriesAvgAggregateInputType = {
    seasonCount?: true
    rentalPrice?: true
  }

  export type SeriesSumAggregateInputType = {
    seasonCount?: true
    rentalPrice?: true
  }

  export type SeriesMinAggregateInputType = {
    id?: true
    metadataId?: true
    status?: true
    type?: true
    seasonCount?: true
    rentalPrice?: true
  }

  export type SeriesMaxAggregateInputType = {
    id?: true
    metadataId?: true
    status?: true
    type?: true
    seasonCount?: true
    rentalPrice?: true
  }

  export type SeriesCountAggregateInputType = {
    id?: true
    metadataId?: true
    status?: true
    type?: true
    seasonCount?: true
    rentalPrice?: true
    _all?: true
  }

  export type SeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to aggregate.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Series
    **/
    _count?: true | SeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesMaxAggregateInputType
  }

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>
  }




  export type SeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithAggregationInput | SeriesOrderByWithAggregationInput[]
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum
    having?: SeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesCountAggregateInputType | true
    _avg?: SeriesAvgAggregateInputType
    _sum?: SeriesSumAggregateInputType
    _min?: SeriesMinAggregateInputType
    _max?: SeriesMaxAggregateInputType
  }

  export type SeriesGroupByOutputType = {
    id: string
    metadataId: string
    status: string
    type: string
    seasonCount: number
    rentalPrice: number | null
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  type GetSeriesGroupByPayload<T extends SeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
        }
      >
    >


  export type SeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadataId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    seasons?: boolean | Series$seasonsArgs<ExtArgs>
    tags?: boolean | Series$tagsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadataId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadataId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectScalar = {
    id?: boolean
    metadataId?: boolean
    status?: boolean
    type?: boolean
    seasonCount?: boolean
    rentalPrice?: boolean
  }

  export type SeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metadataId" | "status" | "type" | "seasonCount" | "rentalPrice", ExtArgs["result"]["series"]>
  export type SeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
    seasons?: boolean | Series$seasonsArgs<ExtArgs>
    tags?: boolean | Series$tagsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }

  export type $SeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Series"
    objects: {
      metadata: Prisma.$VideoMetadataPayload<ExtArgs>
      seasons: Prisma.$SeasonPayload<ExtArgs>[]
      tags: Prisma.$SeriesTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metadataId: string
      status: string
      type: string
      seasonCount: number
      rentalPrice: number | null
    }, ExtArgs["result"]["series"]>
    composites: {}
  }

  type SeriesGetPayload<S extends boolean | null | undefined | SeriesDefaultArgs> = $Result.GetResult<Prisma.$SeriesPayload, S>

  type SeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesCountAggregateInputType | true
    }

  export interface SeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Series'], meta: { name: 'Series' } }
    /**
     * Find zero or one Series that matches the filter.
     * @param {SeriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesFindUniqueArgs>(args: SelectSubset<T, SeriesFindUniqueArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesFindFirstArgs>(args?: SelectSubset<T, SeriesFindFirstArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     * 
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeriesFindManyArgs>(args?: SelectSubset<T, SeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Series.
     * @param {SeriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     * 
     */
    create<T extends SeriesCreateArgs>(args: SelectSubset<T, SeriesCreateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Series.
     * @param {SeriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesCreateManyArgs>(args?: SelectSubset<T, SeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Series and returns the data saved in the database.
     * @param {SeriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Series.
     * @param {SeriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     * 
     */
    delete<T extends SeriesDeleteArgs>(args: SelectSubset<T, SeriesDeleteArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Series.
     * @param {SeriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesUpdateArgs>(args: SelectSubset<T, SeriesUpdateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Series.
     * @param {SeriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesDeleteManyArgs>(args?: SelectSubset<T, SeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesUpdateManyArgs>(args: SelectSubset<T, SeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {SeriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Series.
     * @param {SeriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends SeriesUpsertArgs>(args: SelectSubset<T, SeriesUpsertArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
    **/
    count<T extends SeriesCountArgs>(
      args?: Subset<T, SeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesAggregateArgs>(args: Subset<T, SeriesAggregateArgs>): Prisma.PrismaPromise<GetSeriesAggregateType<T>>

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesGroupByArgs['orderBy'] }
        : { orderBy?: SeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Series model
   */
  readonly fields: SeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    metadata<T extends VideoMetadataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadataDefaultArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seasons<T extends Series$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, Series$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Series$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Series$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Series model
   */
  interface SeriesFieldRefs {
    readonly id: FieldRef<"Series", 'String'>
    readonly metadataId: FieldRef<"Series", 'String'>
    readonly status: FieldRef<"Series", 'String'>
    readonly type: FieldRef<"Series", 'String'>
    readonly seasonCount: FieldRef<"Series", 'Int'>
    readonly rentalPrice: FieldRef<"Series", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Series findUnique
   */
  export type SeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findUniqueOrThrow
   */
  export type SeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findFirst
   */
  export type SeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findFirstOrThrow
   */
  export type SeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findMany
   */
  export type SeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series create
   */
  export type SeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Series.
     */
    data: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
  }

  /**
   * Series createMany
   */
  export type SeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Series createManyAndReturn
   */
  export type SeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series update
   */
  export type SeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Series.
     */
    data: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
    /**
     * Choose, which Series to update.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series updateMany
   */
  export type SeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
  }

  /**
   * Series updateManyAndReturn
   */
  export type SeriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series upsert
   */
  export type SeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Series to update in case it exists.
     */
    where: SeriesWhereUniqueInput
    /**
     * In case the Series found by the `where` argument doesn't exist, create a new Series with this data.
     */
    create: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
    /**
     * In case the Series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
  }

  /**
   * Series delete
   */
  export type SeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter which Series to delete.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series deleteMany
   */
  export type SeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to delete
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to delete.
     */
    limit?: number
  }

  /**
   * Series.seasons
   */
  export type Series$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    cursor?: SeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Series.tags
   */
  export type Series$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    where?: SeriesTagWhereInput
    orderBy?: SeriesTagOrderByWithRelationInput | SeriesTagOrderByWithRelationInput[]
    cursor?: SeriesTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesTagScalarFieldEnum | SeriesTagScalarFieldEnum[]
  }

  /**
   * Series without action
   */
  export type SeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    number: number | null
  }

  export type SeasonSumAggregateOutputType = {
    number: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    seriesId: string | null
    number: number | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    seriesId: string | null
    number: number | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    seriesId: number
    number: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    number?: true
  }

  export type SeasonSumAggregateInputType = {
    number?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    seriesId?: true
    number?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    seriesId?: true
    number?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    seriesId?: true
    number?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: string
    seriesId: string
    number: number
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    number?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    episodes?: boolean | Season$episodesArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    number?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    number?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    seriesId?: boolean
    number?: boolean
  }

  export type SeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seriesId" | "number", ExtArgs["result"]["season"]>
  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    episodes?: boolean | Season$episodesArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      series: Prisma.$SeriesPayload<ExtArgs>
      episodes: Prisma.$EpisodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seriesId: string
      number: number
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons and returns the data updated in the database.
     * @param {SeasonUpdateManyAndReturnArgs} args - Arguments to update many Seasons.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeasonUpdateManyAndReturnArgs>(args: SelectSubset<T, SeasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    series<T extends SeriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeriesDefaultArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    episodes<T extends Season$episodesArgs<ExtArgs> = {}>(args?: Subset<T, Season$episodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'String'>
    readonly seriesId: FieldRef<"Season", 'String'>
    readonly number: FieldRef<"Season", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season updateManyAndReturn
   */
  export type SeasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to delete.
     */
    limit?: number
  }

  /**
   * Season.episodes
   */
  export type Season$episodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    where?: EpisodeWhereInput
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    cursor?: EpisodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model Episode
   */

  export type AggregateEpisode = {
    _count: EpisodeCountAggregateOutputType | null
    _avg: EpisodeAvgAggregateOutputType | null
    _sum: EpisodeSumAggregateOutputType | null
    _min: EpisodeMinAggregateOutputType | null
    _max: EpisodeMaxAggregateOutputType | null
  }

  export type EpisodeAvgAggregateOutputType = {
    number: number | null
  }

  export type EpisodeSumAggregateOutputType = {
    number: number | null
  }

  export type EpisodeMinAggregateOutputType = {
    id: string | null
    seasonId: string | null
    number: number | null
    videoFileId: string | null
    metadataId: string | null
  }

  export type EpisodeMaxAggregateOutputType = {
    id: string | null
    seasonId: string | null
    number: number | null
    videoFileId: string | null
    metadataId: string | null
  }

  export type EpisodeCountAggregateOutputType = {
    id: number
    seasonId: number
    number: number
    videoFileId: number
    metadataId: number
    _all: number
  }


  export type EpisodeAvgAggregateInputType = {
    number?: true
  }

  export type EpisodeSumAggregateInputType = {
    number?: true
  }

  export type EpisodeMinAggregateInputType = {
    id?: true
    seasonId?: true
    number?: true
    videoFileId?: true
    metadataId?: true
  }

  export type EpisodeMaxAggregateInputType = {
    id?: true
    seasonId?: true
    number?: true
    videoFileId?: true
    metadataId?: true
  }

  export type EpisodeCountAggregateInputType = {
    id?: true
    seasonId?: true
    number?: true
    videoFileId?: true
    metadataId?: true
    _all?: true
  }

  export type EpisodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Episode to aggregate.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Episodes
    **/
    _count?: true | EpisodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpisodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpisodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpisodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpisodeMaxAggregateInputType
  }

  export type GetEpisodeAggregateType<T extends EpisodeAggregateArgs> = {
        [P in keyof T & keyof AggregateEpisode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpisode[P]>
      : GetScalarType<T[P], AggregateEpisode[P]>
  }




  export type EpisodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpisodeWhereInput
    orderBy?: EpisodeOrderByWithAggregationInput | EpisodeOrderByWithAggregationInput[]
    by: EpisodeScalarFieldEnum[] | EpisodeScalarFieldEnum
    having?: EpisodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpisodeCountAggregateInputType | true
    _avg?: EpisodeAvgAggregateInputType
    _sum?: EpisodeSumAggregateInputType
    _min?: EpisodeMinAggregateInputType
    _max?: EpisodeMaxAggregateInputType
  }

  export type EpisodeGroupByOutputType = {
    id: string
    seasonId: string
    number: number
    videoFileId: string
    metadataId: string
    _count: EpisodeCountAggregateOutputType | null
    _avg: EpisodeAvgAggregateOutputType | null
    _sum: EpisodeSumAggregateOutputType | null
    _min: EpisodeMinAggregateOutputType | null
    _max: EpisodeMaxAggregateOutputType | null
  }

  type GetEpisodeGroupByPayload<T extends EpisodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpisodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpisodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpisodeGroupByOutputType[P]>
            : GetScalarType<T[P], EpisodeGroupByOutputType[P]>
        }
      >
    >


  export type EpisodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    number?: boolean
    videoFileId?: boolean
    metadataId?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["episode"]>

  export type EpisodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    number?: boolean
    videoFileId?: boolean
    metadataId?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["episode"]>

  export type EpisodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    number?: boolean
    videoFileId?: boolean
    metadataId?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["episode"]>

  export type EpisodeSelectScalar = {
    id?: boolean
    seasonId?: boolean
    number?: boolean
    videoFileId?: boolean
    metadataId?: boolean
  }

  export type EpisodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seasonId" | "number" | "videoFileId" | "metadataId", ExtArgs["result"]["episode"]>
  export type EpisodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }
  export type EpisodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }
  export type EpisodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    videoFile?: boolean | VideoFileDefaultArgs<ExtArgs>
    metadata?: boolean | VideoMetadataDefaultArgs<ExtArgs>
  }

  export type $EpisodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Episode"
    objects: {
      season: Prisma.$SeasonPayload<ExtArgs>
      videoFile: Prisma.$VideoFilePayload<ExtArgs>
      metadata: Prisma.$VideoMetadataPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seasonId: string
      number: number
      videoFileId: string
      metadataId: string
    }, ExtArgs["result"]["episode"]>
    composites: {}
  }

  type EpisodeGetPayload<S extends boolean | null | undefined | EpisodeDefaultArgs> = $Result.GetResult<Prisma.$EpisodePayload, S>

  type EpisodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EpisodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EpisodeCountAggregateInputType | true
    }

  export interface EpisodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Episode'], meta: { name: 'Episode' } }
    /**
     * Find zero or one Episode that matches the filter.
     * @param {EpisodeFindUniqueArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EpisodeFindUniqueArgs>(args: SelectSubset<T, EpisodeFindUniqueArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Episode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EpisodeFindUniqueOrThrowArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EpisodeFindUniqueOrThrowArgs>(args: SelectSubset<T, EpisodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Episode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeFindFirstArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EpisodeFindFirstArgs>(args?: SelectSubset<T, EpisodeFindFirstArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Episode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeFindFirstOrThrowArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EpisodeFindFirstOrThrowArgs>(args?: SelectSubset<T, EpisodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Episodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Episodes
     * const episodes = await prisma.episode.findMany()
     * 
     * // Get first 10 Episodes
     * const episodes = await prisma.episode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const episodeWithIdOnly = await prisma.episode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EpisodeFindManyArgs>(args?: SelectSubset<T, EpisodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Episode.
     * @param {EpisodeCreateArgs} args - Arguments to create a Episode.
     * @example
     * // Create one Episode
     * const Episode = await prisma.episode.create({
     *   data: {
     *     // ... data to create a Episode
     *   }
     * })
     * 
     */
    create<T extends EpisodeCreateArgs>(args: SelectSubset<T, EpisodeCreateArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Episodes.
     * @param {EpisodeCreateManyArgs} args - Arguments to create many Episodes.
     * @example
     * // Create many Episodes
     * const episode = await prisma.episode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EpisodeCreateManyArgs>(args?: SelectSubset<T, EpisodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Episodes and returns the data saved in the database.
     * @param {EpisodeCreateManyAndReturnArgs} args - Arguments to create many Episodes.
     * @example
     * // Create many Episodes
     * const episode = await prisma.episode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Episodes and only return the `id`
     * const episodeWithIdOnly = await prisma.episode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EpisodeCreateManyAndReturnArgs>(args?: SelectSubset<T, EpisodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Episode.
     * @param {EpisodeDeleteArgs} args - Arguments to delete one Episode.
     * @example
     * // Delete one Episode
     * const Episode = await prisma.episode.delete({
     *   where: {
     *     // ... filter to delete one Episode
     *   }
     * })
     * 
     */
    delete<T extends EpisodeDeleteArgs>(args: SelectSubset<T, EpisodeDeleteArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Episode.
     * @param {EpisodeUpdateArgs} args - Arguments to update one Episode.
     * @example
     * // Update one Episode
     * const episode = await prisma.episode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EpisodeUpdateArgs>(args: SelectSubset<T, EpisodeUpdateArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Episodes.
     * @param {EpisodeDeleteManyArgs} args - Arguments to filter Episodes to delete.
     * @example
     * // Delete a few Episodes
     * const { count } = await prisma.episode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EpisodeDeleteManyArgs>(args?: SelectSubset<T, EpisodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Episodes
     * const episode = await prisma.episode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EpisodeUpdateManyArgs>(args: SelectSubset<T, EpisodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episodes and returns the data updated in the database.
     * @param {EpisodeUpdateManyAndReturnArgs} args - Arguments to update many Episodes.
     * @example
     * // Update many Episodes
     * const episode = await prisma.episode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Episodes and only return the `id`
     * const episodeWithIdOnly = await prisma.episode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EpisodeUpdateManyAndReturnArgs>(args: SelectSubset<T, EpisodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Episode.
     * @param {EpisodeUpsertArgs} args - Arguments to update or create a Episode.
     * @example
     * // Update or create a Episode
     * const episode = await prisma.episode.upsert({
     *   create: {
     *     // ... data to create a Episode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Episode we want to update
     *   }
     * })
     */
    upsert<T extends EpisodeUpsertArgs>(args: SelectSubset<T, EpisodeUpsertArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeCountArgs} args - Arguments to filter Episodes to count.
     * @example
     * // Count the number of Episodes
     * const count = await prisma.episode.count({
     *   where: {
     *     // ... the filter for the Episodes we want to count
     *   }
     * })
    **/
    count<T extends EpisodeCountArgs>(
      args?: Subset<T, EpisodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpisodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpisodeAggregateArgs>(args: Subset<T, EpisodeAggregateArgs>): Prisma.PrismaPromise<GetEpisodeAggregateType<T>>

    /**
     * Group by Episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpisodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpisodeGroupByArgs['orderBy'] }
        : { orderBy?: EpisodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpisodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpisodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Episode model
   */
  readonly fields: EpisodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Episode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EpisodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videoFile<T extends VideoFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFileDefaultArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metadata<T extends VideoMetadataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoMetadataDefaultArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Episode model
   */
  interface EpisodeFieldRefs {
    readonly id: FieldRef<"Episode", 'String'>
    readonly seasonId: FieldRef<"Episode", 'String'>
    readonly number: FieldRef<"Episode", 'Int'>
    readonly videoFileId: FieldRef<"Episode", 'String'>
    readonly metadataId: FieldRef<"Episode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Episode findUnique
   */
  export type EpisodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode findUniqueOrThrow
   */
  export type EpisodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode findFirst
   */
  export type EpisodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Episodes.
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Episodes.
     */
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Episode findFirstOrThrow
   */
  export type EpisodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Episodes.
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Episodes.
     */
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Episode findMany
   */
  export type EpisodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episodes to fetch.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Episodes.
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Episode create
   */
  export type EpisodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Episode.
     */
    data: XOR<EpisodeCreateInput, EpisodeUncheckedCreateInput>
  }

  /**
   * Episode createMany
   */
  export type EpisodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Episodes.
     */
    data: EpisodeCreateManyInput | EpisodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Episode createManyAndReturn
   */
  export type EpisodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * The data used to create many Episodes.
     */
    data: EpisodeCreateManyInput | EpisodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Episode update
   */
  export type EpisodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Episode.
     */
    data: XOR<EpisodeUpdateInput, EpisodeUncheckedUpdateInput>
    /**
     * Choose, which Episode to update.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode updateMany
   */
  export type EpisodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Episodes.
     */
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyInput>
    /**
     * Filter which Episodes to update
     */
    where?: EpisodeWhereInput
    /**
     * Limit how many Episodes to update.
     */
    limit?: number
  }

  /**
   * Episode updateManyAndReturn
   */
  export type EpisodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * The data used to update Episodes.
     */
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyInput>
    /**
     * Filter which Episodes to update
     */
    where?: EpisodeWhereInput
    /**
     * Limit how many Episodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Episode upsert
   */
  export type EpisodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Episode to update in case it exists.
     */
    where: EpisodeWhereUniqueInput
    /**
     * In case the Episode found by the `where` argument doesn't exist, create a new Episode with this data.
     */
    create: XOR<EpisodeCreateInput, EpisodeUncheckedCreateInput>
    /**
     * In case the Episode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EpisodeUpdateInput, EpisodeUncheckedUpdateInput>
  }

  /**
   * Episode delete
   */
  export type EpisodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter which Episode to delete.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode deleteMany
   */
  export type EpisodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Episodes to delete
     */
    where?: EpisodeWhereInput
    /**
     * Limit how many Episodes to delete.
     */
    limit?: number
  }

  /**
   * Episode without action
   */
  export type EpisodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    movieTags?: boolean | Tag$movieTagsArgs<ExtArgs>
    seriesTags?: boolean | Tag$seriesTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieTags?: boolean | Tag$movieTagsArgs<ExtArgs>
    seriesTags?: boolean | Tag$seriesTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      movieTags: Prisma.$MovieTagPayload<ExtArgs>[]
      seriesTags: Prisma.$SeriesTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movieTags<T extends Tag$movieTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$movieTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seriesTags<T extends Tag$seriesTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$seriesTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.movieTags
   */
  export type Tag$movieTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    where?: MovieTagWhereInput
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    cursor?: MovieTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * Tag.seriesTags
   */
  export type Tag$seriesTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    where?: SeriesTagWhereInput
    orderBy?: SeriesTagOrderByWithRelationInput | SeriesTagOrderByWithRelationInput[]
    cursor?: SeriesTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesTagScalarFieldEnum | SeriesTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model MovieTag
   */

  export type AggregateMovieTag = {
    _count: MovieTagCountAggregateOutputType | null
    _min: MovieTagMinAggregateOutputType | null
    _max: MovieTagMaxAggregateOutputType | null
  }

  export type MovieTagMinAggregateOutputType = {
    movieId: string | null
    tagId: string | null
  }

  export type MovieTagMaxAggregateOutputType = {
    movieId: string | null
    tagId: string | null
  }

  export type MovieTagCountAggregateOutputType = {
    movieId: number
    tagId: number
    _all: number
  }


  export type MovieTagMinAggregateInputType = {
    movieId?: true
    tagId?: true
  }

  export type MovieTagMaxAggregateInputType = {
    movieId?: true
    tagId?: true
  }

  export type MovieTagCountAggregateInputType = {
    movieId?: true
    tagId?: true
    _all?: true
  }

  export type MovieTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieTag to aggregate.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieTags
    **/
    _count?: true | MovieTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieTagMaxAggregateInputType
  }

  export type GetMovieTagAggregateType<T extends MovieTagAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieTag[P]>
      : GetScalarType<T[P], AggregateMovieTag[P]>
  }




  export type MovieTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieTagWhereInput
    orderBy?: MovieTagOrderByWithAggregationInput | MovieTagOrderByWithAggregationInput[]
    by: MovieTagScalarFieldEnum[] | MovieTagScalarFieldEnum
    having?: MovieTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieTagCountAggregateInputType | true
    _min?: MovieTagMinAggregateInputType
    _max?: MovieTagMaxAggregateInputType
  }

  export type MovieTagGroupByOutputType = {
    movieId: string
    tagId: string
    _count: MovieTagCountAggregateOutputType | null
    _min: MovieTagMinAggregateOutputType | null
    _max: MovieTagMaxAggregateOutputType | null
  }

  type GetMovieTagGroupByPayload<T extends MovieTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieTagGroupByOutputType[P]>
            : GetScalarType<T[P], MovieTagGroupByOutputType[P]>
        }
      >
    >


  export type MovieTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieId?: boolean
    tagId?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieTag"]>

  export type MovieTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieId?: boolean
    tagId?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieTag"]>

  export type MovieTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieId?: boolean
    tagId?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieTag"]>

  export type MovieTagSelectScalar = {
    movieId?: boolean
    tagId?: boolean
  }

  export type MovieTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"movieId" | "tagId", ExtArgs["result"]["movieTag"]>
  export type MovieTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MovieTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type MovieTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $MovieTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieTag"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      movieId: string
      tagId: string
    }, ExtArgs["result"]["movieTag"]>
    composites: {}
  }

  type MovieTagGetPayload<S extends boolean | null | undefined | MovieTagDefaultArgs> = $Result.GetResult<Prisma.$MovieTagPayload, S>

  type MovieTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MovieTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MovieTagCountAggregateInputType | true
    }

  export interface MovieTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieTag'], meta: { name: 'MovieTag' } }
    /**
     * Find zero or one MovieTag that matches the filter.
     * @param {MovieTagFindUniqueArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieTagFindUniqueArgs>(args: SelectSubset<T, MovieTagFindUniqueArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MovieTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MovieTagFindUniqueOrThrowArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieTagFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagFindFirstArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieTagFindFirstArgs>(args?: SelectSubset<T, MovieTagFindFirstArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MovieTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagFindFirstOrThrowArgs} args - Arguments to find a MovieTag
     * @example
     * // Get one MovieTag
     * const movieTag = await prisma.movieTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieTagFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MovieTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieTags
     * const movieTags = await prisma.movieTag.findMany()
     * 
     * // Get first 10 MovieTags
     * const movieTags = await prisma.movieTag.findMany({ take: 10 })
     * 
     * // Only select the `movieId`
     * const movieTagWithMovieIdOnly = await prisma.movieTag.findMany({ select: { movieId: true } })
     * 
     */
    findMany<T extends MovieTagFindManyArgs>(args?: SelectSubset<T, MovieTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MovieTag.
     * @param {MovieTagCreateArgs} args - Arguments to create a MovieTag.
     * @example
     * // Create one MovieTag
     * const MovieTag = await prisma.movieTag.create({
     *   data: {
     *     // ... data to create a MovieTag
     *   }
     * })
     * 
     */
    create<T extends MovieTagCreateArgs>(args: SelectSubset<T, MovieTagCreateArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MovieTags.
     * @param {MovieTagCreateManyArgs} args - Arguments to create many MovieTags.
     * @example
     * // Create many MovieTags
     * const movieTag = await prisma.movieTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieTagCreateManyArgs>(args?: SelectSubset<T, MovieTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieTags and returns the data saved in the database.
     * @param {MovieTagCreateManyAndReturnArgs} args - Arguments to create many MovieTags.
     * @example
     * // Create many MovieTags
     * const movieTag = await prisma.movieTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieTags and only return the `movieId`
     * const movieTagWithMovieIdOnly = await prisma.movieTag.createManyAndReturn({
     *   select: { movieId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieTagCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MovieTag.
     * @param {MovieTagDeleteArgs} args - Arguments to delete one MovieTag.
     * @example
     * // Delete one MovieTag
     * const MovieTag = await prisma.movieTag.delete({
     *   where: {
     *     // ... filter to delete one MovieTag
     *   }
     * })
     * 
     */
    delete<T extends MovieTagDeleteArgs>(args: SelectSubset<T, MovieTagDeleteArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MovieTag.
     * @param {MovieTagUpdateArgs} args - Arguments to update one MovieTag.
     * @example
     * // Update one MovieTag
     * const movieTag = await prisma.movieTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieTagUpdateArgs>(args: SelectSubset<T, MovieTagUpdateArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MovieTags.
     * @param {MovieTagDeleteManyArgs} args - Arguments to filter MovieTags to delete.
     * @example
     * // Delete a few MovieTags
     * const { count } = await prisma.movieTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieTagDeleteManyArgs>(args?: SelectSubset<T, MovieTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieTags
     * const movieTag = await prisma.movieTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieTagUpdateManyArgs>(args: SelectSubset<T, MovieTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieTags and returns the data updated in the database.
     * @param {MovieTagUpdateManyAndReturnArgs} args - Arguments to update many MovieTags.
     * @example
     * // Update many MovieTags
     * const movieTag = await prisma.movieTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MovieTags and only return the `movieId`
     * const movieTagWithMovieIdOnly = await prisma.movieTag.updateManyAndReturn({
     *   select: { movieId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MovieTagUpdateManyAndReturnArgs>(args: SelectSubset<T, MovieTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MovieTag.
     * @param {MovieTagUpsertArgs} args - Arguments to update or create a MovieTag.
     * @example
     * // Update or create a MovieTag
     * const movieTag = await prisma.movieTag.upsert({
     *   create: {
     *     // ... data to create a MovieTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieTag we want to update
     *   }
     * })
     */
    upsert<T extends MovieTagUpsertArgs>(args: SelectSubset<T, MovieTagUpsertArgs<ExtArgs>>): Prisma__MovieTagClient<$Result.GetResult<Prisma.$MovieTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MovieTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagCountArgs} args - Arguments to filter MovieTags to count.
     * @example
     * // Count the number of MovieTags
     * const count = await prisma.movieTag.count({
     *   where: {
     *     // ... the filter for the MovieTags we want to count
     *   }
     * })
    **/
    count<T extends MovieTagCountArgs>(
      args?: Subset<T, MovieTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieTagAggregateArgs>(args: Subset<T, MovieTagAggregateArgs>): Prisma.PrismaPromise<GetMovieTagAggregateType<T>>

    /**
     * Group by MovieTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieTagGroupByArgs['orderBy'] }
        : { orderBy?: MovieTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieTag model
   */
  readonly fields: MovieTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieTag model
   */
  interface MovieTagFieldRefs {
    readonly movieId: FieldRef<"MovieTag", 'String'>
    readonly tagId: FieldRef<"MovieTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MovieTag findUnique
   */
  export type MovieTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag findUniqueOrThrow
   */
  export type MovieTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag findFirst
   */
  export type MovieTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieTags.
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieTags.
     */
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * MovieTag findFirstOrThrow
   */
  export type MovieTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTag to fetch.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieTags.
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieTags.
     */
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * MovieTag findMany
   */
  export type MovieTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter, which MovieTags to fetch.
     */
    where?: MovieTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieTags to fetch.
     */
    orderBy?: MovieTagOrderByWithRelationInput | MovieTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieTags.
     */
    cursor?: MovieTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieTags.
     */
    skip?: number
    distinct?: MovieTagScalarFieldEnum | MovieTagScalarFieldEnum[]
  }

  /**
   * MovieTag create
   */
  export type MovieTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieTag.
     */
    data: XOR<MovieTagCreateInput, MovieTagUncheckedCreateInput>
  }

  /**
   * MovieTag createMany
   */
  export type MovieTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieTags.
     */
    data: MovieTagCreateManyInput | MovieTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieTag createManyAndReturn
   */
  export type MovieTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * The data used to create many MovieTags.
     */
    data: MovieTagCreateManyInput | MovieTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieTag update
   */
  export type MovieTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieTag.
     */
    data: XOR<MovieTagUpdateInput, MovieTagUncheckedUpdateInput>
    /**
     * Choose, which MovieTag to update.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag updateMany
   */
  export type MovieTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieTags.
     */
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyInput>
    /**
     * Filter which MovieTags to update
     */
    where?: MovieTagWhereInput
    /**
     * Limit how many MovieTags to update.
     */
    limit?: number
  }

  /**
   * MovieTag updateManyAndReturn
   */
  export type MovieTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * The data used to update MovieTags.
     */
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyInput>
    /**
     * Filter which MovieTags to update
     */
    where?: MovieTagWhereInput
    /**
     * Limit how many MovieTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieTag upsert
   */
  export type MovieTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieTag to update in case it exists.
     */
    where: MovieTagWhereUniqueInput
    /**
     * In case the MovieTag found by the `where` argument doesn't exist, create a new MovieTag with this data.
     */
    create: XOR<MovieTagCreateInput, MovieTagUncheckedCreateInput>
    /**
     * In case the MovieTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieTagUpdateInput, MovieTagUncheckedUpdateInput>
  }

  /**
   * MovieTag delete
   */
  export type MovieTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
    /**
     * Filter which MovieTag to delete.
     */
    where: MovieTagWhereUniqueInput
  }

  /**
   * MovieTag deleteMany
   */
  export type MovieTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieTags to delete
     */
    where?: MovieTagWhereInput
    /**
     * Limit how many MovieTags to delete.
     */
    limit?: number
  }

  /**
   * MovieTag without action
   */
  export type MovieTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieTag
     */
    select?: MovieTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MovieTag
     */
    omit?: MovieTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieTagInclude<ExtArgs> | null
  }


  /**
   * Model SeriesTag
   */

  export type AggregateSeriesTag = {
    _count: SeriesTagCountAggregateOutputType | null
    _min: SeriesTagMinAggregateOutputType | null
    _max: SeriesTagMaxAggregateOutputType | null
  }

  export type SeriesTagMinAggregateOutputType = {
    seriesId: string | null
    tagId: string | null
  }

  export type SeriesTagMaxAggregateOutputType = {
    seriesId: string | null
    tagId: string | null
  }

  export type SeriesTagCountAggregateOutputType = {
    seriesId: number
    tagId: number
    _all: number
  }


  export type SeriesTagMinAggregateInputType = {
    seriesId?: true
    tagId?: true
  }

  export type SeriesTagMaxAggregateInputType = {
    seriesId?: true
    tagId?: true
  }

  export type SeriesTagCountAggregateInputType = {
    seriesId?: true
    tagId?: true
    _all?: true
  }

  export type SeriesTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeriesTag to aggregate.
     */
    where?: SeriesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTags to fetch.
     */
    orderBy?: SeriesTagOrderByWithRelationInput | SeriesTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeriesTags
    **/
    _count?: true | SeriesTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesTagMaxAggregateInputType
  }

  export type GetSeriesTagAggregateType<T extends SeriesTagAggregateArgs> = {
        [P in keyof T & keyof AggregateSeriesTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeriesTag[P]>
      : GetScalarType<T[P], AggregateSeriesTag[P]>
  }




  export type SeriesTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesTagWhereInput
    orderBy?: SeriesTagOrderByWithAggregationInput | SeriesTagOrderByWithAggregationInput[]
    by: SeriesTagScalarFieldEnum[] | SeriesTagScalarFieldEnum
    having?: SeriesTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesTagCountAggregateInputType | true
    _min?: SeriesTagMinAggregateInputType
    _max?: SeriesTagMaxAggregateInputType
  }

  export type SeriesTagGroupByOutputType = {
    seriesId: string
    tagId: string
    _count: SeriesTagCountAggregateOutputType | null
    _min: SeriesTagMinAggregateOutputType | null
    _max: SeriesTagMaxAggregateOutputType | null
  }

  type GetSeriesTagGroupByPayload<T extends SeriesTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesTagGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesTagGroupByOutputType[P]>
        }
      >
    >


  export type SeriesTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seriesId?: boolean
    tagId?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seriesTag"]>

  export type SeriesTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seriesId?: boolean
    tagId?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seriesTag"]>

  export type SeriesTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seriesId?: boolean
    tagId?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seriesTag"]>

  export type SeriesTagSelectScalar = {
    seriesId?: boolean
    tagId?: boolean
  }

  export type SeriesTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"seriesId" | "tagId", ExtArgs["result"]["seriesTag"]>
  export type SeriesTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type SeriesTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type SeriesTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $SeriesTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeriesTag"
    objects: {
      series: Prisma.$SeriesPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      seriesId: string
      tagId: string
    }, ExtArgs["result"]["seriesTag"]>
    composites: {}
  }

  type SeriesTagGetPayload<S extends boolean | null | undefined | SeriesTagDefaultArgs> = $Result.GetResult<Prisma.$SeriesTagPayload, S>

  type SeriesTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesTagCountAggregateInputType | true
    }

  export interface SeriesTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeriesTag'], meta: { name: 'SeriesTag' } }
    /**
     * Find zero or one SeriesTag that matches the filter.
     * @param {SeriesTagFindUniqueArgs} args - Arguments to find a SeriesTag
     * @example
     * // Get one SeriesTag
     * const seriesTag = await prisma.seriesTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesTagFindUniqueArgs>(args: SelectSubset<T, SeriesTagFindUniqueArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeriesTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesTagFindUniqueOrThrowArgs} args - Arguments to find a SeriesTag
     * @example
     * // Get one SeriesTag
     * const seriesTag = await prisma.seriesTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesTagFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeriesTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagFindFirstArgs} args - Arguments to find a SeriesTag
     * @example
     * // Get one SeriesTag
     * const seriesTag = await prisma.seriesTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesTagFindFirstArgs>(args?: SelectSubset<T, SeriesTagFindFirstArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeriesTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagFindFirstOrThrowArgs} args - Arguments to find a SeriesTag
     * @example
     * // Get one SeriesTag
     * const seriesTag = await prisma.seriesTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesTagFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeriesTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeriesTags
     * const seriesTags = await prisma.seriesTag.findMany()
     * 
     * // Get first 10 SeriesTags
     * const seriesTags = await prisma.seriesTag.findMany({ take: 10 })
     * 
     * // Only select the `seriesId`
     * const seriesTagWithSeriesIdOnly = await prisma.seriesTag.findMany({ select: { seriesId: true } })
     * 
     */
    findMany<T extends SeriesTagFindManyArgs>(args?: SelectSubset<T, SeriesTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeriesTag.
     * @param {SeriesTagCreateArgs} args - Arguments to create a SeriesTag.
     * @example
     * // Create one SeriesTag
     * const SeriesTag = await prisma.seriesTag.create({
     *   data: {
     *     // ... data to create a SeriesTag
     *   }
     * })
     * 
     */
    create<T extends SeriesTagCreateArgs>(args: SelectSubset<T, SeriesTagCreateArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeriesTags.
     * @param {SeriesTagCreateManyArgs} args - Arguments to create many SeriesTags.
     * @example
     * // Create many SeriesTags
     * const seriesTag = await prisma.seriesTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesTagCreateManyArgs>(args?: SelectSubset<T, SeriesTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeriesTags and returns the data saved in the database.
     * @param {SeriesTagCreateManyAndReturnArgs} args - Arguments to create many SeriesTags.
     * @example
     * // Create many SeriesTags
     * const seriesTag = await prisma.seriesTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeriesTags and only return the `seriesId`
     * const seriesTagWithSeriesIdOnly = await prisma.seriesTag.createManyAndReturn({
     *   select: { seriesId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesTagCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeriesTag.
     * @param {SeriesTagDeleteArgs} args - Arguments to delete one SeriesTag.
     * @example
     * // Delete one SeriesTag
     * const SeriesTag = await prisma.seriesTag.delete({
     *   where: {
     *     // ... filter to delete one SeriesTag
     *   }
     * })
     * 
     */
    delete<T extends SeriesTagDeleteArgs>(args: SelectSubset<T, SeriesTagDeleteArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeriesTag.
     * @param {SeriesTagUpdateArgs} args - Arguments to update one SeriesTag.
     * @example
     * // Update one SeriesTag
     * const seriesTag = await prisma.seriesTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesTagUpdateArgs>(args: SelectSubset<T, SeriesTagUpdateArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeriesTags.
     * @param {SeriesTagDeleteManyArgs} args - Arguments to filter SeriesTags to delete.
     * @example
     * // Delete a few SeriesTags
     * const { count } = await prisma.seriesTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesTagDeleteManyArgs>(args?: SelectSubset<T, SeriesTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeriesTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeriesTags
     * const seriesTag = await prisma.seriesTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesTagUpdateManyArgs>(args: SelectSubset<T, SeriesTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeriesTags and returns the data updated in the database.
     * @param {SeriesTagUpdateManyAndReturnArgs} args - Arguments to update many SeriesTags.
     * @example
     * // Update many SeriesTags
     * const seriesTag = await prisma.seriesTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeriesTags and only return the `seriesId`
     * const seriesTagWithSeriesIdOnly = await prisma.seriesTag.updateManyAndReturn({
     *   select: { seriesId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesTagUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeriesTag.
     * @param {SeriesTagUpsertArgs} args - Arguments to update or create a SeriesTag.
     * @example
     * // Update or create a SeriesTag
     * const seriesTag = await prisma.seriesTag.upsert({
     *   create: {
     *     // ... data to create a SeriesTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeriesTag we want to update
     *   }
     * })
     */
    upsert<T extends SeriesTagUpsertArgs>(args: SelectSubset<T, SeriesTagUpsertArgs<ExtArgs>>): Prisma__SeriesTagClient<$Result.GetResult<Prisma.$SeriesTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeriesTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagCountArgs} args - Arguments to filter SeriesTags to count.
     * @example
     * // Count the number of SeriesTags
     * const count = await prisma.seriesTag.count({
     *   where: {
     *     // ... the filter for the SeriesTags we want to count
     *   }
     * })
    **/
    count<T extends SeriesTagCountArgs>(
      args?: Subset<T, SeriesTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeriesTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesTagAggregateArgs>(args: Subset<T, SeriesTagAggregateArgs>): Prisma.PrismaPromise<GetSeriesTagAggregateType<T>>

    /**
     * Group by SeriesTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesTagGroupByArgs['orderBy'] }
        : { orderBy?: SeriesTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeriesTag model
   */
  readonly fields: SeriesTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeriesTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    series<T extends SeriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeriesDefaultArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeriesTag model
   */
  interface SeriesTagFieldRefs {
    readonly seriesId: FieldRef<"SeriesTag", 'String'>
    readonly tagId: FieldRef<"SeriesTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeriesTag findUnique
   */
  export type SeriesTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * Filter, which SeriesTag to fetch.
     */
    where: SeriesTagWhereUniqueInput
  }

  /**
   * SeriesTag findUniqueOrThrow
   */
  export type SeriesTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * Filter, which SeriesTag to fetch.
     */
    where: SeriesTagWhereUniqueInput
  }

  /**
   * SeriesTag findFirst
   */
  export type SeriesTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * Filter, which SeriesTag to fetch.
     */
    where?: SeriesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTags to fetch.
     */
    orderBy?: SeriesTagOrderByWithRelationInput | SeriesTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeriesTags.
     */
    cursor?: SeriesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeriesTags.
     */
    distinct?: SeriesTagScalarFieldEnum | SeriesTagScalarFieldEnum[]
  }

  /**
   * SeriesTag findFirstOrThrow
   */
  export type SeriesTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * Filter, which SeriesTag to fetch.
     */
    where?: SeriesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTags to fetch.
     */
    orderBy?: SeriesTagOrderByWithRelationInput | SeriesTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeriesTags.
     */
    cursor?: SeriesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeriesTags.
     */
    distinct?: SeriesTagScalarFieldEnum | SeriesTagScalarFieldEnum[]
  }

  /**
   * SeriesTag findMany
   */
  export type SeriesTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * Filter, which SeriesTags to fetch.
     */
    where?: SeriesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTags to fetch.
     */
    orderBy?: SeriesTagOrderByWithRelationInput | SeriesTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeriesTags.
     */
    cursor?: SeriesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTags.
     */
    skip?: number
    distinct?: SeriesTagScalarFieldEnum | SeriesTagScalarFieldEnum[]
  }

  /**
   * SeriesTag create
   */
  export type SeriesTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * The data needed to create a SeriesTag.
     */
    data: XOR<SeriesTagCreateInput, SeriesTagUncheckedCreateInput>
  }

  /**
   * SeriesTag createMany
   */
  export type SeriesTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeriesTags.
     */
    data: SeriesTagCreateManyInput | SeriesTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeriesTag createManyAndReturn
   */
  export type SeriesTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * The data used to create many SeriesTags.
     */
    data: SeriesTagCreateManyInput | SeriesTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeriesTag update
   */
  export type SeriesTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * The data needed to update a SeriesTag.
     */
    data: XOR<SeriesTagUpdateInput, SeriesTagUncheckedUpdateInput>
    /**
     * Choose, which SeriesTag to update.
     */
    where: SeriesTagWhereUniqueInput
  }

  /**
   * SeriesTag updateMany
   */
  export type SeriesTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeriesTags.
     */
    data: XOR<SeriesTagUpdateManyMutationInput, SeriesTagUncheckedUpdateManyInput>
    /**
     * Filter which SeriesTags to update
     */
    where?: SeriesTagWhereInput
    /**
     * Limit how many SeriesTags to update.
     */
    limit?: number
  }

  /**
   * SeriesTag updateManyAndReturn
   */
  export type SeriesTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * The data used to update SeriesTags.
     */
    data: XOR<SeriesTagUpdateManyMutationInput, SeriesTagUncheckedUpdateManyInput>
    /**
     * Filter which SeriesTags to update
     */
    where?: SeriesTagWhereInput
    /**
     * Limit how many SeriesTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeriesTag upsert
   */
  export type SeriesTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * The filter to search for the SeriesTag to update in case it exists.
     */
    where: SeriesTagWhereUniqueInput
    /**
     * In case the SeriesTag found by the `where` argument doesn't exist, create a new SeriesTag with this data.
     */
    create: XOR<SeriesTagCreateInput, SeriesTagUncheckedCreateInput>
    /**
     * In case the SeriesTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesTagUpdateInput, SeriesTagUncheckedUpdateInput>
  }

  /**
   * SeriesTag delete
   */
  export type SeriesTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
    /**
     * Filter which SeriesTag to delete.
     */
    where: SeriesTagWhereUniqueInput
  }

  /**
   * SeriesTag deleteMany
   */
  export type SeriesTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeriesTags to delete
     */
    where?: SeriesTagWhereInput
    /**
     * Limit how many SeriesTags to delete.
     */
    limit?: number
  }

  /**
   * SeriesTag without action
   */
  export type SeriesTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesTag
     */
    select?: SeriesTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesTag
     */
    omit?: SeriesTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesTagInclude<ExtArgs> | null
  }


  /**
   * Model Subtitle
   */

  export type AggregateSubtitle = {
    _count: SubtitleCountAggregateOutputType | null
    _min: SubtitleMinAggregateOutputType | null
    _max: SubtitleMaxAggregateOutputType | null
  }

  export type SubtitleMinAggregateOutputType = {
    videoId: string | null
    language: string | null
    subtitle_url: string | null
    videoMetadataId: string | null
  }

  export type SubtitleMaxAggregateOutputType = {
    videoId: string | null
    language: string | null
    subtitle_url: string | null
    videoMetadataId: string | null
  }

  export type SubtitleCountAggregateOutputType = {
    videoId: number
    language: number
    subtitle_url: number
    videoMetadataId: number
    _all: number
  }


  export type SubtitleMinAggregateInputType = {
    videoId?: true
    language?: true
    subtitle_url?: true
    videoMetadataId?: true
  }

  export type SubtitleMaxAggregateInputType = {
    videoId?: true
    language?: true
    subtitle_url?: true
    videoMetadataId?: true
  }

  export type SubtitleCountAggregateInputType = {
    videoId?: true
    language?: true
    subtitle_url?: true
    videoMetadataId?: true
    _all?: true
  }

  export type SubtitleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtitle to aggregate.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subtitles
    **/
    _count?: true | SubtitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtitleMaxAggregateInputType
  }

  export type GetSubtitleAggregateType<T extends SubtitleAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtitle[P]>
      : GetScalarType<T[P], AggregateSubtitle[P]>
  }




  export type SubtitleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleWhereInput
    orderBy?: SubtitleOrderByWithAggregationInput | SubtitleOrderByWithAggregationInput[]
    by: SubtitleScalarFieldEnum[] | SubtitleScalarFieldEnum
    having?: SubtitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtitleCountAggregateInputType | true
    _min?: SubtitleMinAggregateInputType
    _max?: SubtitleMaxAggregateInputType
  }

  export type SubtitleGroupByOutputType = {
    videoId: string
    language: string
    subtitle_url: string
    videoMetadataId: string | null
    _count: SubtitleCountAggregateOutputType | null
    _min: SubtitleMinAggregateOutputType | null
    _max: SubtitleMaxAggregateOutputType | null
  }

  type GetSubtitleGroupByPayload<T extends SubtitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
            : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
        }
      >
    >


  export type SubtitleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoId?: boolean
    language?: boolean
    subtitle_url?: boolean
    videoMetadataId?: boolean
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    videoMetadata?: boolean | Subtitle$videoMetadataArgs<ExtArgs>
  }, ExtArgs["result"]["subtitle"]>

  export type SubtitleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoId?: boolean
    language?: boolean
    subtitle_url?: boolean
    videoMetadataId?: boolean
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    videoMetadata?: boolean | Subtitle$videoMetadataArgs<ExtArgs>
  }, ExtArgs["result"]["subtitle"]>

  export type SubtitleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoId?: boolean
    language?: boolean
    subtitle_url?: boolean
    videoMetadataId?: boolean
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    videoMetadata?: boolean | Subtitle$videoMetadataArgs<ExtArgs>
  }, ExtArgs["result"]["subtitle"]>

  export type SubtitleSelectScalar = {
    videoId?: boolean
    language?: boolean
    subtitle_url?: boolean
    videoMetadataId?: boolean
  }

  export type SubtitleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"videoId" | "language" | "subtitle_url" | "videoMetadataId", ExtArgs["result"]["subtitle"]>
  export type SubtitleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    videoMetadata?: boolean | Subtitle$videoMetadataArgs<ExtArgs>
  }
  export type SubtitleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    videoMetadata?: boolean | Subtitle$videoMetadataArgs<ExtArgs>
  }
  export type SubtitleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    videoMetadata?: boolean | Subtitle$videoMetadataArgs<ExtArgs>
  }

  export type $SubtitlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subtitle"
    objects: {
      video: Prisma.$VideoFilePayload<ExtArgs>
      videoMetadata: Prisma.$VideoMetadataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      videoId: string
      language: string
      subtitle_url: string
      videoMetadataId: string | null
    }, ExtArgs["result"]["subtitle"]>
    composites: {}
  }

  type SubtitleGetPayload<S extends boolean | null | undefined | SubtitleDefaultArgs> = $Result.GetResult<Prisma.$SubtitlePayload, S>

  type SubtitleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubtitleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubtitleCountAggregateInputType | true
    }

  export interface SubtitleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subtitle'], meta: { name: 'Subtitle' } }
    /**
     * Find zero or one Subtitle that matches the filter.
     * @param {SubtitleFindUniqueArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtitleFindUniqueArgs>(args: SelectSubset<T, SubtitleFindUniqueArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subtitle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubtitleFindUniqueOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtitleFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtitleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subtitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFindFirstArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtitleFindFirstArgs>(args?: SelectSubset<T, SubtitleFindFirstArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subtitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFindFirstOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtitleFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtitleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subtitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtitles
     * const subtitles = await prisma.subtitle.findMany()
     * 
     * // Get first 10 Subtitles
     * const subtitles = await prisma.subtitle.findMany({ take: 10 })
     * 
     * // Only select the `videoId`
     * const subtitleWithVideoIdOnly = await prisma.subtitle.findMany({ select: { videoId: true } })
     * 
     */
    findMany<T extends SubtitleFindManyArgs>(args?: SelectSubset<T, SubtitleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subtitle.
     * @param {SubtitleCreateArgs} args - Arguments to create a Subtitle.
     * @example
     * // Create one Subtitle
     * const Subtitle = await prisma.subtitle.create({
     *   data: {
     *     // ... data to create a Subtitle
     *   }
     * })
     * 
     */
    create<T extends SubtitleCreateArgs>(args: SelectSubset<T, SubtitleCreateArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subtitles.
     * @param {SubtitleCreateManyArgs} args - Arguments to create many Subtitles.
     * @example
     * // Create many Subtitles
     * const subtitle = await prisma.subtitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtitleCreateManyArgs>(args?: SelectSubset<T, SubtitleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subtitles and returns the data saved in the database.
     * @param {SubtitleCreateManyAndReturnArgs} args - Arguments to create many Subtitles.
     * @example
     * // Create many Subtitles
     * const subtitle = await prisma.subtitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subtitles and only return the `videoId`
     * const subtitleWithVideoIdOnly = await prisma.subtitle.createManyAndReturn({
     *   select: { videoId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtitleCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtitleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subtitle.
     * @param {SubtitleDeleteArgs} args - Arguments to delete one Subtitle.
     * @example
     * // Delete one Subtitle
     * const Subtitle = await prisma.subtitle.delete({
     *   where: {
     *     // ... filter to delete one Subtitle
     *   }
     * })
     * 
     */
    delete<T extends SubtitleDeleteArgs>(args: SelectSubset<T, SubtitleDeleteArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subtitle.
     * @param {SubtitleUpdateArgs} args - Arguments to update one Subtitle.
     * @example
     * // Update one Subtitle
     * const subtitle = await prisma.subtitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtitleUpdateArgs>(args: SelectSubset<T, SubtitleUpdateArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subtitles.
     * @param {SubtitleDeleteManyArgs} args - Arguments to filter Subtitles to delete.
     * @example
     * // Delete a few Subtitles
     * const { count } = await prisma.subtitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtitleDeleteManyArgs>(args?: SelectSubset<T, SubtitleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtitles
     * const subtitle = await prisma.subtitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtitleUpdateManyArgs>(args: SelectSubset<T, SubtitleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtitles and returns the data updated in the database.
     * @param {SubtitleUpdateManyAndReturnArgs} args - Arguments to update many Subtitles.
     * @example
     * // Update many Subtitles
     * const subtitle = await prisma.subtitle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subtitles and only return the `videoId`
     * const subtitleWithVideoIdOnly = await prisma.subtitle.updateManyAndReturn({
     *   select: { videoId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubtitleUpdateManyAndReturnArgs>(args: SelectSubset<T, SubtitleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subtitle.
     * @param {SubtitleUpsertArgs} args - Arguments to update or create a Subtitle.
     * @example
     * // Update or create a Subtitle
     * const subtitle = await prisma.subtitle.upsert({
     *   create: {
     *     // ... data to create a Subtitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtitle we want to update
     *   }
     * })
     */
    upsert<T extends SubtitleUpsertArgs>(args: SelectSubset<T, SubtitleUpsertArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleCountArgs} args - Arguments to filter Subtitles to count.
     * @example
     * // Count the number of Subtitles
     * const count = await prisma.subtitle.count({
     *   where: {
     *     // ... the filter for the Subtitles we want to count
     *   }
     * })
    **/
    count<T extends SubtitleCountArgs>(
      args?: Subset<T, SubtitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtitleAggregateArgs>(args: Subset<T, SubtitleAggregateArgs>): Prisma.PrismaPromise<GetSubtitleAggregateType<T>>

    /**
     * Group by Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtitleGroupByArgs['orderBy'] }
        : { orderBy?: SubtitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subtitle model
   */
  readonly fields: SubtitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subtitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtitleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFileDefaultArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videoMetadata<T extends Subtitle$videoMetadataArgs<ExtArgs> = {}>(args?: Subset<T, Subtitle$videoMetadataArgs<ExtArgs>>): Prisma__VideoMetadataClient<$Result.GetResult<Prisma.$VideoMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subtitle model
   */
  interface SubtitleFieldRefs {
    readonly videoId: FieldRef<"Subtitle", 'String'>
    readonly language: FieldRef<"Subtitle", 'String'>
    readonly subtitle_url: FieldRef<"Subtitle", 'String'>
    readonly videoMetadataId: FieldRef<"Subtitle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subtitle findUnique
   */
  export type SubtitleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle findUniqueOrThrow
   */
  export type SubtitleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle findFirst
   */
  export type SubtitleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtitles.
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtitles.
     */
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * Subtitle findFirstOrThrow
   */
  export type SubtitleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtitles.
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtitles.
     */
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * Subtitle findMany
   */
  export type SubtitleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitles to fetch.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subtitles.
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * Subtitle create
   */
  export type SubtitleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * The data needed to create a Subtitle.
     */
    data: XOR<SubtitleCreateInput, SubtitleUncheckedCreateInput>
  }

  /**
   * Subtitle createMany
   */
  export type SubtitleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subtitles.
     */
    data: SubtitleCreateManyInput | SubtitleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subtitle createManyAndReturn
   */
  export type SubtitleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * The data used to create many Subtitles.
     */
    data: SubtitleCreateManyInput | SubtitleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtitle update
   */
  export type SubtitleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * The data needed to update a Subtitle.
     */
    data: XOR<SubtitleUpdateInput, SubtitleUncheckedUpdateInput>
    /**
     * Choose, which Subtitle to update.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle updateMany
   */
  export type SubtitleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subtitles.
     */
    data: XOR<SubtitleUpdateManyMutationInput, SubtitleUncheckedUpdateManyInput>
    /**
     * Filter which Subtitles to update
     */
    where?: SubtitleWhereInput
    /**
     * Limit how many Subtitles to update.
     */
    limit?: number
  }

  /**
   * Subtitle updateManyAndReturn
   */
  export type SubtitleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * The data used to update Subtitles.
     */
    data: XOR<SubtitleUpdateManyMutationInput, SubtitleUncheckedUpdateManyInput>
    /**
     * Filter which Subtitles to update
     */
    where?: SubtitleWhereInput
    /**
     * Limit how many Subtitles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtitle upsert
   */
  export type SubtitleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * The filter to search for the Subtitle to update in case it exists.
     */
    where: SubtitleWhereUniqueInput
    /**
     * In case the Subtitle found by the `where` argument doesn't exist, create a new Subtitle with this data.
     */
    create: XOR<SubtitleCreateInput, SubtitleUncheckedCreateInput>
    /**
     * In case the Subtitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtitleUpdateInput, SubtitleUncheckedUpdateInput>
  }

  /**
   * Subtitle delete
   */
  export type SubtitleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter which Subtitle to delete.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle deleteMany
   */
  export type SubtitleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtitles to delete
     */
    where?: SubtitleWhereInput
    /**
     * Limit how many Subtitles to delete.
     */
    limit?: number
  }

  /**
   * Subtitle.videoMetadata
   */
  export type Subtitle$videoMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMetadata
     */
    select?: VideoMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMetadata
     */
    omit?: VideoMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMetadataInclude<ExtArgs> | null
    where?: VideoMetadataWhereInput
  }

  /**
   * Subtitle without action
   */
  export type SubtitleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtitle
     */
    omit?: SubtitleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    videoId: string | null
    purchase_date: Date | null
    expiration_date: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    videoId: string | null
    purchase_date: Date | null
    expiration_date: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    userId: number
    videoId: number
    purchase_date: number
    expiration_date: number
    _all: number
  }


  export type PurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    purchase_date?: true
    expiration_date?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    purchase_date?: true
    expiration_date?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    purchase_date?: true
    expiration_date?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    userId: string
    videoId: string
    purchase_date: Date
    expiration_date: Date | null
    _count: PurchaseCountAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoId?: boolean
    purchase_date?: boolean
    expiration_date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoId?: boolean
    purchase_date?: boolean
    expiration_date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoId?: boolean
    purchase_date?: boolean
    expiration_date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    videoId?: boolean
    purchase_date?: boolean
    expiration_date?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "videoId" | "purchase_date" | "expiration_date", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      video: Prisma.$VideoFilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      videoId: string
      purchase_date: Date
      expiration_date: Date | null
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    video<T extends VideoFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFileDefaultArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly userId: FieldRef<"Purchase", 'String'>
    readonly videoId: FieldRef<"Purchase", 'String'>
    readonly purchase_date: FieldRef<"Purchase", 'DateTime'>
    readonly expiration_date: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model View
   */

  export type AggregateView = {
    _count: ViewCountAggregateOutputType | null
    _avg: ViewAvgAggregateOutputType | null
    _sum: ViewSumAggregateOutputType | null
    _min: ViewMinAggregateOutputType | null
    _max: ViewMaxAggregateOutputType | null
  }

  export type ViewAvgAggregateOutputType = {
    progress_seconds: number | null
  }

  export type ViewSumAggregateOutputType = {
    progress_seconds: number | null
  }

  export type ViewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    videoId: string | null
    viewed_at: Date | null
    progress_seconds: number | null
  }

  export type ViewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileId: string | null
    videoId: string | null
    viewed_at: Date | null
    progress_seconds: number | null
  }

  export type ViewCountAggregateOutputType = {
    id: number
    userId: number
    profileId: number
    videoId: number
    viewed_at: number
    progress_seconds: number
    _all: number
  }


  export type ViewAvgAggregateInputType = {
    progress_seconds?: true
  }

  export type ViewSumAggregateInputType = {
    progress_seconds?: true
  }

  export type ViewMinAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    videoId?: true
    viewed_at?: true
    progress_seconds?: true
  }

  export type ViewMaxAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    videoId?: true
    viewed_at?: true
    progress_seconds?: true
  }

  export type ViewCountAggregateInputType = {
    id?: true
    userId?: true
    profileId?: true
    videoId?: true
    viewed_at?: true
    progress_seconds?: true
    _all?: true
  }

  export type ViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which View to aggregate.
     */
    where?: ViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Views
    **/
    _count?: true | ViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewMaxAggregateInputType
  }

  export type GetViewAggregateType<T extends ViewAggregateArgs> = {
        [P in keyof T & keyof AggregateView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateView[P]>
      : GetScalarType<T[P], AggregateView[P]>
  }




  export type ViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewWhereInput
    orderBy?: ViewOrderByWithAggregationInput | ViewOrderByWithAggregationInput[]
    by: ViewScalarFieldEnum[] | ViewScalarFieldEnum
    having?: ViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewCountAggregateInputType | true
    _avg?: ViewAvgAggregateInputType
    _sum?: ViewSumAggregateInputType
    _min?: ViewMinAggregateInputType
    _max?: ViewMaxAggregateInputType
  }

  export type ViewGroupByOutputType = {
    id: string
    userId: string
    profileId: string | null
    videoId: string
    viewed_at: Date
    progress_seconds: number
    _count: ViewCountAggregateOutputType | null
    _avg: ViewAvgAggregateOutputType | null
    _sum: ViewSumAggregateOutputType | null
    _min: ViewMinAggregateOutputType | null
    _max: ViewMaxAggregateOutputType | null
  }

  type GetViewGroupByPayload<T extends ViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewGroupByOutputType[P]>
            : GetScalarType<T[P], ViewGroupByOutputType[P]>
        }
      >
    >


  export type ViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    videoId?: boolean
    viewed_at?: boolean
    progress_seconds?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | View$profileArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["view"]>

  export type ViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    videoId?: boolean
    viewed_at?: boolean
    progress_seconds?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | View$profileArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["view"]>

  export type ViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileId?: boolean
    videoId?: boolean
    viewed_at?: boolean
    progress_seconds?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | View$profileArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["view"]>

  export type ViewSelectScalar = {
    id?: boolean
    userId?: boolean
    profileId?: boolean
    videoId?: boolean
    viewed_at?: boolean
    progress_seconds?: boolean
  }

  export type ViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "profileId" | "videoId" | "viewed_at" | "progress_seconds", ExtArgs["result"]["view"]>
  export type ViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | View$profileArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }
  export type ViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | View$profileArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }
  export type ViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | View$profileArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
  }

  export type $ViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "View"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profile: Prisma.$SharedAccountUserPayload<ExtArgs> | null
      video: Prisma.$VideoFilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileId: string | null
      videoId: string
      viewed_at: Date
      progress_seconds: number
    }, ExtArgs["result"]["view"]>
    composites: {}
  }

  type ViewGetPayload<S extends boolean | null | undefined | ViewDefaultArgs> = $Result.GetResult<Prisma.$ViewPayload, S>

  type ViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewCountAggregateInputType | true
    }

  export interface ViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['View'], meta: { name: 'View' } }
    /**
     * Find zero or one View that matches the filter.
     * @param {ViewFindUniqueArgs} args - Arguments to find a View
     * @example
     * // Get one View
     * const view = await prisma.view.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewFindUniqueArgs>(args: SelectSubset<T, ViewFindUniqueArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one View that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewFindUniqueOrThrowArgs} args - Arguments to find a View
     * @example
     * // Get one View
     * const view = await prisma.view.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first View that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFindFirstArgs} args - Arguments to find a View
     * @example
     * // Get one View
     * const view = await prisma.view.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewFindFirstArgs>(args?: SelectSubset<T, ViewFindFirstArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first View that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFindFirstOrThrowArgs} args - Arguments to find a View
     * @example
     * // Get one View
     * const view = await prisma.view.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Views that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Views
     * const views = await prisma.view.findMany()
     * 
     * // Get first 10 Views
     * const views = await prisma.view.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewWithIdOnly = await prisma.view.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewFindManyArgs>(args?: SelectSubset<T, ViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a View.
     * @param {ViewCreateArgs} args - Arguments to create a View.
     * @example
     * // Create one View
     * const View = await prisma.view.create({
     *   data: {
     *     // ... data to create a View
     *   }
     * })
     * 
     */
    create<T extends ViewCreateArgs>(args: SelectSubset<T, ViewCreateArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Views.
     * @param {ViewCreateManyArgs} args - Arguments to create many Views.
     * @example
     * // Create many Views
     * const view = await prisma.view.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewCreateManyArgs>(args?: SelectSubset<T, ViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Views and returns the data saved in the database.
     * @param {ViewCreateManyAndReturnArgs} args - Arguments to create many Views.
     * @example
     * // Create many Views
     * const view = await prisma.view.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Views and only return the `id`
     * const viewWithIdOnly = await prisma.view.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a View.
     * @param {ViewDeleteArgs} args - Arguments to delete one View.
     * @example
     * // Delete one View
     * const View = await prisma.view.delete({
     *   where: {
     *     // ... filter to delete one View
     *   }
     * })
     * 
     */
    delete<T extends ViewDeleteArgs>(args: SelectSubset<T, ViewDeleteArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one View.
     * @param {ViewUpdateArgs} args - Arguments to update one View.
     * @example
     * // Update one View
     * const view = await prisma.view.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewUpdateArgs>(args: SelectSubset<T, ViewUpdateArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Views.
     * @param {ViewDeleteManyArgs} args - Arguments to filter Views to delete.
     * @example
     * // Delete a few Views
     * const { count } = await prisma.view.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewDeleteManyArgs>(args?: SelectSubset<T, ViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Views
     * const view = await prisma.view.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewUpdateManyArgs>(args: SelectSubset<T, ViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Views and returns the data updated in the database.
     * @param {ViewUpdateManyAndReturnArgs} args - Arguments to update many Views.
     * @example
     * // Update many Views
     * const view = await prisma.view.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Views and only return the `id`
     * const viewWithIdOnly = await prisma.view.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one View.
     * @param {ViewUpsertArgs} args - Arguments to update or create a View.
     * @example
     * // Update or create a View
     * const view = await prisma.view.upsert({
     *   create: {
     *     // ... data to create a View
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the View we want to update
     *   }
     * })
     */
    upsert<T extends ViewUpsertArgs>(args: SelectSubset<T, ViewUpsertArgs<ExtArgs>>): Prisma__ViewClient<$Result.GetResult<Prisma.$ViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewCountArgs} args - Arguments to filter Views to count.
     * @example
     * // Count the number of Views
     * const count = await prisma.view.count({
     *   where: {
     *     // ... the filter for the Views we want to count
     *   }
     * })
    **/
    count<T extends ViewCountArgs>(
      args?: Subset<T, ViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a View.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewAggregateArgs>(args: Subset<T, ViewAggregateArgs>): Prisma.PrismaPromise<GetViewAggregateType<T>>

    /**
     * Group by View.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewGroupByArgs['orderBy'] }
        : { orderBy?: ViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the View model
   */
  readonly fields: ViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for View.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends View$profileArgs<ExtArgs> = {}>(args?: Subset<T, View$profileArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    video<T extends VideoFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFileDefaultArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the View model
   */
  interface ViewFieldRefs {
    readonly id: FieldRef<"View", 'String'>
    readonly userId: FieldRef<"View", 'String'>
    readonly profileId: FieldRef<"View", 'String'>
    readonly videoId: FieldRef<"View", 'String'>
    readonly viewed_at: FieldRef<"View", 'DateTime'>
    readonly progress_seconds: FieldRef<"View", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * View findUnique
   */
  export type ViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * Filter, which View to fetch.
     */
    where: ViewWhereUniqueInput
  }

  /**
   * View findUniqueOrThrow
   */
  export type ViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * Filter, which View to fetch.
     */
    where: ViewWhereUniqueInput
  }

  /**
   * View findFirst
   */
  export type ViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * Filter, which View to fetch.
     */
    where?: ViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Views.
     */
    cursor?: ViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Views.
     */
    distinct?: ViewScalarFieldEnum | ViewScalarFieldEnum[]
  }

  /**
   * View findFirstOrThrow
   */
  export type ViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * Filter, which View to fetch.
     */
    where?: ViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Views.
     */
    cursor?: ViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Views.
     */
    distinct?: ViewScalarFieldEnum | ViewScalarFieldEnum[]
  }

  /**
   * View findMany
   */
  export type ViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * Filter, which Views to fetch.
     */
    where?: ViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Views to fetch.
     */
    orderBy?: ViewOrderByWithRelationInput | ViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Views.
     */
    cursor?: ViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Views.
     */
    skip?: number
    distinct?: ViewScalarFieldEnum | ViewScalarFieldEnum[]
  }

  /**
   * View create
   */
  export type ViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * The data needed to create a View.
     */
    data: XOR<ViewCreateInput, ViewUncheckedCreateInput>
  }

  /**
   * View createMany
   */
  export type ViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Views.
     */
    data: ViewCreateManyInput | ViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * View createManyAndReturn
   */
  export type ViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * The data used to create many Views.
     */
    data: ViewCreateManyInput | ViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * View update
   */
  export type ViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * The data needed to update a View.
     */
    data: XOR<ViewUpdateInput, ViewUncheckedUpdateInput>
    /**
     * Choose, which View to update.
     */
    where: ViewWhereUniqueInput
  }

  /**
   * View updateMany
   */
  export type ViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Views.
     */
    data: XOR<ViewUpdateManyMutationInput, ViewUncheckedUpdateManyInput>
    /**
     * Filter which Views to update
     */
    where?: ViewWhereInput
    /**
     * Limit how many Views to update.
     */
    limit?: number
  }

  /**
   * View updateManyAndReturn
   */
  export type ViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * The data used to update Views.
     */
    data: XOR<ViewUpdateManyMutationInput, ViewUncheckedUpdateManyInput>
    /**
     * Filter which Views to update
     */
    where?: ViewWhereInput
    /**
     * Limit how many Views to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * View upsert
   */
  export type ViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * The filter to search for the View to update in case it exists.
     */
    where: ViewWhereUniqueInput
    /**
     * In case the View found by the `where` argument doesn't exist, create a new View with this data.
     */
    create: XOR<ViewCreateInput, ViewUncheckedCreateInput>
    /**
     * In case the View was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewUpdateInput, ViewUncheckedUpdateInput>
  }

  /**
   * View delete
   */
  export type ViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
    /**
     * Filter which View to delete.
     */
    where: ViewWhereUniqueInput
  }

  /**
   * View deleteMany
   */
  export type ViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Views to delete
     */
    where?: ViewWhereInput
    /**
     * Limit how many Views to delete.
     */
    limit?: number
  }

  /**
   * View.profile
   */
  export type View$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    where?: SharedAccountUserWhereInput
  }

  /**
   * View without action
   */
  export type ViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the View
     */
    select?: ViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the View
     */
    omit?: ViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    videoId: string | null
    text: string | null
    created_at: Date | null
    parentCommentId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    videoId: string | null
    text: string | null
    created_at: Date | null
    parentCommentId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    videoId: number
    text: number
    created_at: number
    parentCommentId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    text?: true
    created_at?: true
    parentCommentId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    text?: true
    created_at?: true
    parentCommentId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    text?: true
    created_at?: true
    parentCommentId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userId: string
    videoId: string
    text: string
    created_at: Date
    parentCommentId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoId?: boolean
    text?: boolean
    created_at?: boolean
    parentCommentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoId?: boolean
    text?: boolean
    created_at?: boolean
    parentCommentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoId?: boolean
    text?: boolean
    created_at?: boolean
    parentCommentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    videoId?: boolean
    text?: boolean
    created_at?: boolean
    parentCommentId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "videoId" | "text" | "created_at" | "parentCommentId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoFileDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      video: Prisma.$VideoFilePayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      videoId: string
      text: string
      created_at: Date
      parentCommentId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    video<T extends VideoFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoFileDefaultArgs<ExtArgs>>): Prisma__VideoFileClient<$Result.GetResult<Prisma.$VideoFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly videoId: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly created_at: FieldRef<"Comment", 'DateTime'>
    readonly parentCommentId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Ad
   */

  export type AggregateAd = {
    _count: AdCountAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  export type AdMinAggregateOutputType = {
    id: string | null
    title: string | null
    image_url: string | null
    video_url: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
  }

  export type AdMaxAggregateOutputType = {
    id: string | null
    title: string | null
    image_url: string | null
    video_url: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
  }

  export type AdCountAggregateOutputType = {
    id: number
    title: number
    image_url: number
    video_url: number
    start_date: number
    end_date: number
    is_active: number
    _all: number
  }


  export type AdMinAggregateInputType = {
    id?: true
    title?: true
    image_url?: true
    video_url?: true
    start_date?: true
    end_date?: true
    is_active?: true
  }

  export type AdMaxAggregateInputType = {
    id?: true
    title?: true
    image_url?: true
    video_url?: true
    start_date?: true
    end_date?: true
    is_active?: true
  }

  export type AdCountAggregateInputType = {
    id?: true
    title?: true
    image_url?: true
    video_url?: true
    start_date?: true
    end_date?: true
    is_active?: true
    _all?: true
  }

  export type AdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ad to aggregate.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ads
    **/
    _count?: true | AdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdMaxAggregateInputType
  }

  export type GetAdAggregateType<T extends AdAggregateArgs> = {
        [P in keyof T & keyof AggregateAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAd[P]>
      : GetScalarType<T[P], AggregateAd[P]>
  }




  export type AdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
    orderBy?: AdOrderByWithAggregationInput | AdOrderByWithAggregationInput[]
    by: AdScalarFieldEnum[] | AdScalarFieldEnum
    having?: AdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdCountAggregateInputType | true
    _min?: AdMinAggregateInputType
    _max?: AdMaxAggregateInputType
  }

  export type AdGroupByOutputType = {
    id: string
    title: string
    image_url: string
    video_url: string | null
    start_date: Date
    end_date: Date
    is_active: boolean
    _count: AdCountAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  type GetAdGroupByPayload<T extends AdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdGroupByOutputType[P]>
            : GetScalarType<T[P], AdGroupByOutputType[P]>
        }
      >
    >


  export type AdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image_url?: boolean
    video_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    views?: boolean | Ad$viewsArgs<ExtArgs>
    _count?: boolean | AdCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image_url?: boolean
    video_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["ad"]>

  export type AdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image_url?: boolean
    video_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["ad"]>

  export type AdSelectScalar = {
    id?: boolean
    title?: boolean
    image_url?: boolean
    video_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
  }

  export type AdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "image_url" | "video_url" | "start_date" | "end_date" | "is_active", ExtArgs["result"]["ad"]>
  export type AdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    views?: boolean | Ad$viewsArgs<ExtArgs>
    _count?: boolean | AdCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ad"
    objects: {
      views: Prisma.$AdViewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      image_url: string
      video_url: string | null
      start_date: Date
      end_date: Date
      is_active: boolean
    }, ExtArgs["result"]["ad"]>
    composites: {}
  }

  type AdGetPayload<S extends boolean | null | undefined | AdDefaultArgs> = $Result.GetResult<Prisma.$AdPayload, S>

  type AdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdCountAggregateInputType | true
    }

  export interface AdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ad'], meta: { name: 'Ad' } }
    /**
     * Find zero or one Ad that matches the filter.
     * @param {AdFindUniqueArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdFindUniqueArgs>(args: SelectSubset<T, AdFindUniqueArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ad that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdFindUniqueOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdFindUniqueOrThrowArgs>(args: SelectSubset<T, AdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdFindFirstArgs>(args?: SelectSubset<T, AdFindFirstArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdFindFirstOrThrowArgs>(args?: SelectSubset<T, AdFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ads
     * const ads = await prisma.ad.findMany()
     * 
     * // Get first 10 Ads
     * const ads = await prisma.ad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adWithIdOnly = await prisma.ad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdFindManyArgs>(args?: SelectSubset<T, AdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ad.
     * @param {AdCreateArgs} args - Arguments to create a Ad.
     * @example
     * // Create one Ad
     * const Ad = await prisma.ad.create({
     *   data: {
     *     // ... data to create a Ad
     *   }
     * })
     * 
     */
    create<T extends AdCreateArgs>(args: SelectSubset<T, AdCreateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ads.
     * @param {AdCreateManyArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdCreateManyArgs>(args?: SelectSubset<T, AdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ads and returns the data saved in the database.
     * @param {AdCreateManyAndReturnArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdCreateManyAndReturnArgs>(args?: SelectSubset<T, AdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ad.
     * @param {AdDeleteArgs} args - Arguments to delete one Ad.
     * @example
     * // Delete one Ad
     * const Ad = await prisma.ad.delete({
     *   where: {
     *     // ... filter to delete one Ad
     *   }
     * })
     * 
     */
    delete<T extends AdDeleteArgs>(args: SelectSubset<T, AdDeleteArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ad.
     * @param {AdUpdateArgs} args - Arguments to update one Ad.
     * @example
     * // Update one Ad
     * const ad = await prisma.ad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdUpdateArgs>(args: SelectSubset<T, AdUpdateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ads.
     * @param {AdDeleteManyArgs} args - Arguments to filter Ads to delete.
     * @example
     * // Delete a few Ads
     * const { count } = await prisma.ad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdDeleteManyArgs>(args?: SelectSubset<T, AdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdUpdateManyArgs>(args: SelectSubset<T, AdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads and returns the data updated in the database.
     * @param {AdUpdateManyAndReturnArgs} args - Arguments to update many Ads.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdUpdateManyAndReturnArgs>(args: SelectSubset<T, AdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ad.
     * @param {AdUpsertArgs} args - Arguments to update or create a Ad.
     * @example
     * // Update or create a Ad
     * const ad = await prisma.ad.upsert({
     *   create: {
     *     // ... data to create a Ad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ad we want to update
     *   }
     * })
     */
    upsert<T extends AdUpsertArgs>(args: SelectSubset<T, AdUpsertArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCountArgs} args - Arguments to filter Ads to count.
     * @example
     * // Count the number of Ads
     * const count = await prisma.ad.count({
     *   where: {
     *     // ... the filter for the Ads we want to count
     *   }
     * })
    **/
    count<T extends AdCountArgs>(
      args?: Subset<T, AdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAggregateArgs>(args: Subset<T, AdAggregateArgs>): Prisma.PrismaPromise<GetAdAggregateType<T>>

    /**
     * Group by Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdGroupByArgs['orderBy'] }
        : { orderBy?: AdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ad model
   */
  readonly fields: AdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    views<T extends Ad$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Ad$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ad model
   */
  interface AdFieldRefs {
    readonly id: FieldRef<"Ad", 'String'>
    readonly title: FieldRef<"Ad", 'String'>
    readonly image_url: FieldRef<"Ad", 'String'>
    readonly video_url: FieldRef<"Ad", 'String'>
    readonly start_date: FieldRef<"Ad", 'DateTime'>
    readonly end_date: FieldRef<"Ad", 'DateTime'>
    readonly is_active: FieldRef<"Ad", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Ad findUnique
   */
  export type AdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findUniqueOrThrow
   */
  export type AdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findFirst
   */
  export type AdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findFirstOrThrow
   */
  export type AdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findMany
   */
  export type AdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ads to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad create
   */
  export type AdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to create a Ad.
     */
    data: XOR<AdCreateInput, AdUncheckedCreateInput>
  }

  /**
   * Ad createMany
   */
  export type AdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ad createManyAndReturn
   */
  export type AdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ad update
   */
  export type AdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to update a Ad.
     */
    data: XOR<AdUpdateInput, AdUncheckedUpdateInput>
    /**
     * Choose, which Ad to update.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad updateMany
   */
  export type AdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to update.
     */
    limit?: number
  }

  /**
   * Ad updateManyAndReturn
   */
  export type AdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to update.
     */
    limit?: number
  }

  /**
   * Ad upsert
   */
  export type AdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The filter to search for the Ad to update in case it exists.
     */
    where: AdWhereUniqueInput
    /**
     * In case the Ad found by the `where` argument doesn't exist, create a new Ad with this data.
     */
    create: XOR<AdCreateInput, AdUncheckedCreateInput>
    /**
     * In case the Ad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdUpdateInput, AdUncheckedUpdateInput>
  }

  /**
   * Ad delete
   */
  export type AdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter which Ad to delete.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad deleteMany
   */
  export type AdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ads to delete
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to delete.
     */
    limit?: number
  }

  /**
   * Ad.views
   */
  export type Ad$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    where?: AdViewWhereInput
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    cursor?: AdViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdViewScalarFieldEnum | AdViewScalarFieldEnum[]
  }

  /**
   * Ad without action
   */
  export type AdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
  }


  /**
   * Model AdView
   */

  export type AggregateAdView = {
    _count: AdViewCountAggregateOutputType | null
    _min: AdViewMinAggregateOutputType | null
    _max: AdViewMaxAggregateOutputType | null
  }

  export type AdViewMinAggregateOutputType = {
    id: string | null
    adId: string | null
    userId: string | null
    profileId: string | null
    viewed_at: Date | null
  }

  export type AdViewMaxAggregateOutputType = {
    id: string | null
    adId: string | null
    userId: string | null
    profileId: string | null
    viewed_at: Date | null
  }

  export type AdViewCountAggregateOutputType = {
    id: number
    adId: number
    userId: number
    profileId: number
    viewed_at: number
    _all: number
  }


  export type AdViewMinAggregateInputType = {
    id?: true
    adId?: true
    userId?: true
    profileId?: true
    viewed_at?: true
  }

  export type AdViewMaxAggregateInputType = {
    id?: true
    adId?: true
    userId?: true
    profileId?: true
    viewed_at?: true
  }

  export type AdViewCountAggregateInputType = {
    id?: true
    adId?: true
    userId?: true
    profileId?: true
    viewed_at?: true
    _all?: true
  }

  export type AdViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdView to aggregate.
     */
    where?: AdViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdViews to fetch.
     */
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdViews
    **/
    _count?: true | AdViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdViewMaxAggregateInputType
  }

  export type GetAdViewAggregateType<T extends AdViewAggregateArgs> = {
        [P in keyof T & keyof AggregateAdView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdView[P]>
      : GetScalarType<T[P], AggregateAdView[P]>
  }




  export type AdViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdViewWhereInput
    orderBy?: AdViewOrderByWithAggregationInput | AdViewOrderByWithAggregationInput[]
    by: AdViewScalarFieldEnum[] | AdViewScalarFieldEnum
    having?: AdViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdViewCountAggregateInputType | true
    _min?: AdViewMinAggregateInputType
    _max?: AdViewMaxAggregateInputType
  }

  export type AdViewGroupByOutputType = {
    id: string
    adId: string
    userId: string | null
    profileId: string | null
    viewed_at: Date
    _count: AdViewCountAggregateOutputType | null
    _min: AdViewMinAggregateOutputType | null
    _max: AdViewMaxAggregateOutputType | null
  }

  type GetAdViewGroupByPayload<T extends AdViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdViewGroupByOutputType[P]>
            : GetScalarType<T[P], AdViewGroupByOutputType[P]>
        }
      >
    >


  export type AdViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adId?: boolean
    userId?: boolean
    profileId?: boolean
    viewed_at?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
    user?: boolean | AdView$userArgs<ExtArgs>
    profile?: boolean | AdView$profileArgs<ExtArgs>
  }, ExtArgs["result"]["adView"]>

  export type AdViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adId?: boolean
    userId?: boolean
    profileId?: boolean
    viewed_at?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
    user?: boolean | AdView$userArgs<ExtArgs>
    profile?: boolean | AdView$profileArgs<ExtArgs>
  }, ExtArgs["result"]["adView"]>

  export type AdViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adId?: boolean
    userId?: boolean
    profileId?: boolean
    viewed_at?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
    user?: boolean | AdView$userArgs<ExtArgs>
    profile?: boolean | AdView$profileArgs<ExtArgs>
  }, ExtArgs["result"]["adView"]>

  export type AdViewSelectScalar = {
    id?: boolean
    adId?: boolean
    userId?: boolean
    profileId?: boolean
    viewed_at?: boolean
  }

  export type AdViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adId" | "userId" | "profileId" | "viewed_at", ExtArgs["result"]["adView"]>
  export type AdViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
    user?: boolean | AdView$userArgs<ExtArgs>
    profile?: boolean | AdView$profileArgs<ExtArgs>
  }
  export type AdViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
    user?: boolean | AdView$userArgs<ExtArgs>
    profile?: boolean | AdView$profileArgs<ExtArgs>
  }
  export type AdViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
    user?: boolean | AdView$userArgs<ExtArgs>
    profile?: boolean | AdView$profileArgs<ExtArgs>
  }

  export type $AdViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdView"
    objects: {
      ad: Prisma.$AdPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      profile: Prisma.$SharedAccountUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adId: string
      userId: string | null
      profileId: string | null
      viewed_at: Date
    }, ExtArgs["result"]["adView"]>
    composites: {}
  }

  type AdViewGetPayload<S extends boolean | null | undefined | AdViewDefaultArgs> = $Result.GetResult<Prisma.$AdViewPayload, S>

  type AdViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdViewCountAggregateInputType | true
    }

  export interface AdViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdView'], meta: { name: 'AdView' } }
    /**
     * Find zero or one AdView that matches the filter.
     * @param {AdViewFindUniqueArgs} args - Arguments to find a AdView
     * @example
     * // Get one AdView
     * const adView = await prisma.adView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdViewFindUniqueArgs>(args: SelectSubset<T, AdViewFindUniqueArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdViewFindUniqueOrThrowArgs} args - Arguments to find a AdView
     * @example
     * // Get one AdView
     * const adView = await prisma.adView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdViewFindUniqueOrThrowArgs>(args: SelectSubset<T, AdViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewFindFirstArgs} args - Arguments to find a AdView
     * @example
     * // Get one AdView
     * const adView = await prisma.adView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdViewFindFirstArgs>(args?: SelectSubset<T, AdViewFindFirstArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewFindFirstOrThrowArgs} args - Arguments to find a AdView
     * @example
     * // Get one AdView
     * const adView = await prisma.adView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdViewFindFirstOrThrowArgs>(args?: SelectSubset<T, AdViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdViews
     * const adViews = await prisma.adView.findMany()
     * 
     * // Get first 10 AdViews
     * const adViews = await prisma.adView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adViewWithIdOnly = await prisma.adView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdViewFindManyArgs>(args?: SelectSubset<T, AdViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdView.
     * @param {AdViewCreateArgs} args - Arguments to create a AdView.
     * @example
     * // Create one AdView
     * const AdView = await prisma.adView.create({
     *   data: {
     *     // ... data to create a AdView
     *   }
     * })
     * 
     */
    create<T extends AdViewCreateArgs>(args: SelectSubset<T, AdViewCreateArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdViews.
     * @param {AdViewCreateManyArgs} args - Arguments to create many AdViews.
     * @example
     * // Create many AdViews
     * const adView = await prisma.adView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdViewCreateManyArgs>(args?: SelectSubset<T, AdViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdViews and returns the data saved in the database.
     * @param {AdViewCreateManyAndReturnArgs} args - Arguments to create many AdViews.
     * @example
     * // Create many AdViews
     * const adView = await prisma.adView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdViews and only return the `id`
     * const adViewWithIdOnly = await prisma.adView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdViewCreateManyAndReturnArgs>(args?: SelectSubset<T, AdViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdView.
     * @param {AdViewDeleteArgs} args - Arguments to delete one AdView.
     * @example
     * // Delete one AdView
     * const AdView = await prisma.adView.delete({
     *   where: {
     *     // ... filter to delete one AdView
     *   }
     * })
     * 
     */
    delete<T extends AdViewDeleteArgs>(args: SelectSubset<T, AdViewDeleteArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdView.
     * @param {AdViewUpdateArgs} args - Arguments to update one AdView.
     * @example
     * // Update one AdView
     * const adView = await prisma.adView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdViewUpdateArgs>(args: SelectSubset<T, AdViewUpdateArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdViews.
     * @param {AdViewDeleteManyArgs} args - Arguments to filter AdViews to delete.
     * @example
     * // Delete a few AdViews
     * const { count } = await prisma.adView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdViewDeleteManyArgs>(args?: SelectSubset<T, AdViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdViews
     * const adView = await prisma.adView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdViewUpdateManyArgs>(args: SelectSubset<T, AdViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdViews and returns the data updated in the database.
     * @param {AdViewUpdateManyAndReturnArgs} args - Arguments to update many AdViews.
     * @example
     * // Update many AdViews
     * const adView = await prisma.adView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdViews and only return the `id`
     * const adViewWithIdOnly = await prisma.adView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdViewUpdateManyAndReturnArgs>(args: SelectSubset<T, AdViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdView.
     * @param {AdViewUpsertArgs} args - Arguments to update or create a AdView.
     * @example
     * // Update or create a AdView
     * const adView = await prisma.adView.upsert({
     *   create: {
     *     // ... data to create a AdView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdView we want to update
     *   }
     * })
     */
    upsert<T extends AdViewUpsertArgs>(args: SelectSubset<T, AdViewUpsertArgs<ExtArgs>>): Prisma__AdViewClient<$Result.GetResult<Prisma.$AdViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewCountArgs} args - Arguments to filter AdViews to count.
     * @example
     * // Count the number of AdViews
     * const count = await prisma.adView.count({
     *   where: {
     *     // ... the filter for the AdViews we want to count
     *   }
     * })
    **/
    count<T extends AdViewCountArgs>(
      args?: Subset<T, AdViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdViewAggregateArgs>(args: Subset<T, AdViewAggregateArgs>): Prisma.PrismaPromise<GetAdViewAggregateType<T>>

    /**
     * Group by AdView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdViewGroupByArgs['orderBy'] }
        : { orderBy?: AdViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdView model
   */
  readonly fields: AdViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ad<T extends AdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdDefaultArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends AdView$userArgs<ExtArgs> = {}>(args?: Subset<T, AdView$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends AdView$profileArgs<ExtArgs> = {}>(args?: Subset<T, AdView$profileArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdView model
   */
  interface AdViewFieldRefs {
    readonly id: FieldRef<"AdView", 'String'>
    readonly adId: FieldRef<"AdView", 'String'>
    readonly userId: FieldRef<"AdView", 'String'>
    readonly profileId: FieldRef<"AdView", 'String'>
    readonly viewed_at: FieldRef<"AdView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdView findUnique
   */
  export type AdViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * Filter, which AdView to fetch.
     */
    where: AdViewWhereUniqueInput
  }

  /**
   * AdView findUniqueOrThrow
   */
  export type AdViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * Filter, which AdView to fetch.
     */
    where: AdViewWhereUniqueInput
  }

  /**
   * AdView findFirst
   */
  export type AdViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * Filter, which AdView to fetch.
     */
    where?: AdViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdViews to fetch.
     */
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdViews.
     */
    cursor?: AdViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdViews.
     */
    distinct?: AdViewScalarFieldEnum | AdViewScalarFieldEnum[]
  }

  /**
   * AdView findFirstOrThrow
   */
  export type AdViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * Filter, which AdView to fetch.
     */
    where?: AdViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdViews to fetch.
     */
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdViews.
     */
    cursor?: AdViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdViews.
     */
    distinct?: AdViewScalarFieldEnum | AdViewScalarFieldEnum[]
  }

  /**
   * AdView findMany
   */
  export type AdViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * Filter, which AdViews to fetch.
     */
    where?: AdViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdViews to fetch.
     */
    orderBy?: AdViewOrderByWithRelationInput | AdViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdViews.
     */
    cursor?: AdViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdViews.
     */
    skip?: number
    distinct?: AdViewScalarFieldEnum | AdViewScalarFieldEnum[]
  }

  /**
   * AdView create
   */
  export type AdViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * The data needed to create a AdView.
     */
    data: XOR<AdViewCreateInput, AdViewUncheckedCreateInput>
  }

  /**
   * AdView createMany
   */
  export type AdViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdViews.
     */
    data: AdViewCreateManyInput | AdViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdView createManyAndReturn
   */
  export type AdViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * The data used to create many AdViews.
     */
    data: AdViewCreateManyInput | AdViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdView update
   */
  export type AdViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * The data needed to update a AdView.
     */
    data: XOR<AdViewUpdateInput, AdViewUncheckedUpdateInput>
    /**
     * Choose, which AdView to update.
     */
    where: AdViewWhereUniqueInput
  }

  /**
   * AdView updateMany
   */
  export type AdViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdViews.
     */
    data: XOR<AdViewUpdateManyMutationInput, AdViewUncheckedUpdateManyInput>
    /**
     * Filter which AdViews to update
     */
    where?: AdViewWhereInput
    /**
     * Limit how many AdViews to update.
     */
    limit?: number
  }

  /**
   * AdView updateManyAndReturn
   */
  export type AdViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * The data used to update AdViews.
     */
    data: XOR<AdViewUpdateManyMutationInput, AdViewUncheckedUpdateManyInput>
    /**
     * Filter which AdViews to update
     */
    where?: AdViewWhereInput
    /**
     * Limit how many AdViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdView upsert
   */
  export type AdViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * The filter to search for the AdView to update in case it exists.
     */
    where: AdViewWhereUniqueInput
    /**
     * In case the AdView found by the `where` argument doesn't exist, create a new AdView with this data.
     */
    create: XOR<AdViewCreateInput, AdViewUncheckedCreateInput>
    /**
     * In case the AdView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdViewUpdateInput, AdViewUncheckedUpdateInput>
  }

  /**
   * AdView delete
   */
  export type AdViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
    /**
     * Filter which AdView to delete.
     */
    where: AdViewWhereUniqueInput
  }

  /**
   * AdView deleteMany
   */
  export type AdViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdViews to delete
     */
    where?: AdViewWhereInput
    /**
     * Limit how many AdViews to delete.
     */
    limit?: number
  }

  /**
   * AdView.user
   */
  export type AdView$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AdView.profile
   */
  export type AdView$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAccountUser
     */
    select?: SharedAccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAccountUser
     */
    omit?: SharedAccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAccountUserInclude<ExtArgs> | null
    where?: SharedAccountUserWhereInput
  }

  /**
   * AdView without action
   */
  export type AdViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdView
     */
    select?: AdViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdView
     */
    omit?: AdViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdViewInclude<ExtArgs> | null
  }


  /**
   * Model SharedProfileActivity
   */

  export type AggregateSharedProfileActivity = {
    _count: SharedProfileActivityCountAggregateOutputType | null
    _min: SharedProfileActivityMinAggregateOutputType | null
    _max: SharedProfileActivityMaxAggregateOutputType | null
  }

  export type SharedProfileActivityMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    action: $Enums.ProfileActivityAction | null
    performed_at: Date | null
  }

  export type SharedProfileActivityMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    action: $Enums.ProfileActivityAction | null
    performed_at: Date | null
  }

  export type SharedProfileActivityCountAggregateOutputType = {
    id: number
    profileId: number
    action: number
    details: number
    performed_at: number
    _all: number
  }


  export type SharedProfileActivityMinAggregateInputType = {
    id?: true
    profileId?: true
    action?: true
    performed_at?: true
  }

  export type SharedProfileActivityMaxAggregateInputType = {
    id?: true
    profileId?: true
    action?: true
    performed_at?: true
  }

  export type SharedProfileActivityCountAggregateInputType = {
    id?: true
    profileId?: true
    action?: true
    details?: true
    performed_at?: true
    _all?: true
  }

  export type SharedProfileActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedProfileActivity to aggregate.
     */
    where?: SharedProfileActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProfileActivities to fetch.
     */
    orderBy?: SharedProfileActivityOrderByWithRelationInput | SharedProfileActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedProfileActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProfileActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProfileActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedProfileActivities
    **/
    _count?: true | SharedProfileActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedProfileActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedProfileActivityMaxAggregateInputType
  }

  export type GetSharedProfileActivityAggregateType<T extends SharedProfileActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedProfileActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedProfileActivity[P]>
      : GetScalarType<T[P], AggregateSharedProfileActivity[P]>
  }




  export type SharedProfileActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedProfileActivityWhereInput
    orderBy?: SharedProfileActivityOrderByWithAggregationInput | SharedProfileActivityOrderByWithAggregationInput[]
    by: SharedProfileActivityScalarFieldEnum[] | SharedProfileActivityScalarFieldEnum
    having?: SharedProfileActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedProfileActivityCountAggregateInputType | true
    _min?: SharedProfileActivityMinAggregateInputType
    _max?: SharedProfileActivityMaxAggregateInputType
  }

  export type SharedProfileActivityGroupByOutputType = {
    id: string
    profileId: string
    action: $Enums.ProfileActivityAction
    details: JsonValue | null
    performed_at: Date
    _count: SharedProfileActivityCountAggregateOutputType | null
    _min: SharedProfileActivityMinAggregateOutputType | null
    _max: SharedProfileActivityMaxAggregateOutputType | null
  }

  type GetSharedProfileActivityGroupByPayload<T extends SharedProfileActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedProfileActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedProfileActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedProfileActivityGroupByOutputType[P]>
            : GetScalarType<T[P], SharedProfileActivityGroupByOutputType[P]>
        }
      >
    >


  export type SharedProfileActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    action?: boolean
    details?: boolean
    performed_at?: boolean
    profile?: boolean | SharedAccountUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedProfileActivity"]>

  export type SharedProfileActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    action?: boolean
    details?: boolean
    performed_at?: boolean
    profile?: boolean | SharedAccountUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedProfileActivity"]>

  export type SharedProfileActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    action?: boolean
    details?: boolean
    performed_at?: boolean
    profile?: boolean | SharedAccountUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedProfileActivity"]>

  export type SharedProfileActivitySelectScalar = {
    id?: boolean
    profileId?: boolean
    action?: boolean
    details?: boolean
    performed_at?: boolean
  }

  export type SharedProfileActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "action" | "details" | "performed_at", ExtArgs["result"]["sharedProfileActivity"]>
  export type SharedProfileActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | SharedAccountUserDefaultArgs<ExtArgs>
  }
  export type SharedProfileActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | SharedAccountUserDefaultArgs<ExtArgs>
  }
  export type SharedProfileActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | SharedAccountUserDefaultArgs<ExtArgs>
  }

  export type $SharedProfileActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedProfileActivity"
    objects: {
      profile: Prisma.$SharedAccountUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      action: $Enums.ProfileActivityAction
      details: Prisma.JsonValue | null
      performed_at: Date
    }, ExtArgs["result"]["sharedProfileActivity"]>
    composites: {}
  }

  type SharedProfileActivityGetPayload<S extends boolean | null | undefined | SharedProfileActivityDefaultArgs> = $Result.GetResult<Prisma.$SharedProfileActivityPayload, S>

  type SharedProfileActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedProfileActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedProfileActivityCountAggregateInputType | true
    }

  export interface SharedProfileActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedProfileActivity'], meta: { name: 'SharedProfileActivity' } }
    /**
     * Find zero or one SharedProfileActivity that matches the filter.
     * @param {SharedProfileActivityFindUniqueArgs} args - Arguments to find a SharedProfileActivity
     * @example
     * // Get one SharedProfileActivity
     * const sharedProfileActivity = await prisma.sharedProfileActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedProfileActivityFindUniqueArgs>(args: SelectSubset<T, SharedProfileActivityFindUniqueArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedProfileActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedProfileActivityFindUniqueOrThrowArgs} args - Arguments to find a SharedProfileActivity
     * @example
     * // Get one SharedProfileActivity
     * const sharedProfileActivity = await prisma.sharedProfileActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedProfileActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedProfileActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedProfileActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityFindFirstArgs} args - Arguments to find a SharedProfileActivity
     * @example
     * // Get one SharedProfileActivity
     * const sharedProfileActivity = await prisma.sharedProfileActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedProfileActivityFindFirstArgs>(args?: SelectSubset<T, SharedProfileActivityFindFirstArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedProfileActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityFindFirstOrThrowArgs} args - Arguments to find a SharedProfileActivity
     * @example
     * // Get one SharedProfileActivity
     * const sharedProfileActivity = await prisma.sharedProfileActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedProfileActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedProfileActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedProfileActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedProfileActivities
     * const sharedProfileActivities = await prisma.sharedProfileActivity.findMany()
     * 
     * // Get first 10 SharedProfileActivities
     * const sharedProfileActivities = await prisma.sharedProfileActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedProfileActivityWithIdOnly = await prisma.sharedProfileActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedProfileActivityFindManyArgs>(args?: SelectSubset<T, SharedProfileActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedProfileActivity.
     * @param {SharedProfileActivityCreateArgs} args - Arguments to create a SharedProfileActivity.
     * @example
     * // Create one SharedProfileActivity
     * const SharedProfileActivity = await prisma.sharedProfileActivity.create({
     *   data: {
     *     // ... data to create a SharedProfileActivity
     *   }
     * })
     * 
     */
    create<T extends SharedProfileActivityCreateArgs>(args: SelectSubset<T, SharedProfileActivityCreateArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedProfileActivities.
     * @param {SharedProfileActivityCreateManyArgs} args - Arguments to create many SharedProfileActivities.
     * @example
     * // Create many SharedProfileActivities
     * const sharedProfileActivity = await prisma.sharedProfileActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedProfileActivityCreateManyArgs>(args?: SelectSubset<T, SharedProfileActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedProfileActivities and returns the data saved in the database.
     * @param {SharedProfileActivityCreateManyAndReturnArgs} args - Arguments to create many SharedProfileActivities.
     * @example
     * // Create many SharedProfileActivities
     * const sharedProfileActivity = await prisma.sharedProfileActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedProfileActivities and only return the `id`
     * const sharedProfileActivityWithIdOnly = await prisma.sharedProfileActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedProfileActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedProfileActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedProfileActivity.
     * @param {SharedProfileActivityDeleteArgs} args - Arguments to delete one SharedProfileActivity.
     * @example
     * // Delete one SharedProfileActivity
     * const SharedProfileActivity = await prisma.sharedProfileActivity.delete({
     *   where: {
     *     // ... filter to delete one SharedProfileActivity
     *   }
     * })
     * 
     */
    delete<T extends SharedProfileActivityDeleteArgs>(args: SelectSubset<T, SharedProfileActivityDeleteArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedProfileActivity.
     * @param {SharedProfileActivityUpdateArgs} args - Arguments to update one SharedProfileActivity.
     * @example
     * // Update one SharedProfileActivity
     * const sharedProfileActivity = await prisma.sharedProfileActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedProfileActivityUpdateArgs>(args: SelectSubset<T, SharedProfileActivityUpdateArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedProfileActivities.
     * @param {SharedProfileActivityDeleteManyArgs} args - Arguments to filter SharedProfileActivities to delete.
     * @example
     * // Delete a few SharedProfileActivities
     * const { count } = await prisma.sharedProfileActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedProfileActivityDeleteManyArgs>(args?: SelectSubset<T, SharedProfileActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedProfileActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedProfileActivities
     * const sharedProfileActivity = await prisma.sharedProfileActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedProfileActivityUpdateManyArgs>(args: SelectSubset<T, SharedProfileActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedProfileActivities and returns the data updated in the database.
     * @param {SharedProfileActivityUpdateManyAndReturnArgs} args - Arguments to update many SharedProfileActivities.
     * @example
     * // Update many SharedProfileActivities
     * const sharedProfileActivity = await prisma.sharedProfileActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedProfileActivities and only return the `id`
     * const sharedProfileActivityWithIdOnly = await prisma.sharedProfileActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedProfileActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedProfileActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedProfileActivity.
     * @param {SharedProfileActivityUpsertArgs} args - Arguments to update or create a SharedProfileActivity.
     * @example
     * // Update or create a SharedProfileActivity
     * const sharedProfileActivity = await prisma.sharedProfileActivity.upsert({
     *   create: {
     *     // ... data to create a SharedProfileActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedProfileActivity we want to update
     *   }
     * })
     */
    upsert<T extends SharedProfileActivityUpsertArgs>(args: SelectSubset<T, SharedProfileActivityUpsertArgs<ExtArgs>>): Prisma__SharedProfileActivityClient<$Result.GetResult<Prisma.$SharedProfileActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedProfileActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityCountArgs} args - Arguments to filter SharedProfileActivities to count.
     * @example
     * // Count the number of SharedProfileActivities
     * const count = await prisma.sharedProfileActivity.count({
     *   where: {
     *     // ... the filter for the SharedProfileActivities we want to count
     *   }
     * })
    **/
    count<T extends SharedProfileActivityCountArgs>(
      args?: Subset<T, SharedProfileActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedProfileActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedProfileActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedProfileActivityAggregateArgs>(args: Subset<T, SharedProfileActivityAggregateArgs>): Prisma.PrismaPromise<GetSharedProfileActivityAggregateType<T>>

    /**
     * Group by SharedProfileActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProfileActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedProfileActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedProfileActivityGroupByArgs['orderBy'] }
        : { orderBy?: SharedProfileActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedProfileActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedProfileActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedProfileActivity model
   */
  readonly fields: SharedProfileActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedProfileActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedProfileActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends SharedAccountUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SharedAccountUserDefaultArgs<ExtArgs>>): Prisma__SharedAccountUserClient<$Result.GetResult<Prisma.$SharedAccountUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedProfileActivity model
   */
  interface SharedProfileActivityFieldRefs {
    readonly id: FieldRef<"SharedProfileActivity", 'String'>
    readonly profileId: FieldRef<"SharedProfileActivity", 'String'>
    readonly action: FieldRef<"SharedProfileActivity", 'ProfileActivityAction'>
    readonly details: FieldRef<"SharedProfileActivity", 'Json'>
    readonly performed_at: FieldRef<"SharedProfileActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedProfileActivity findUnique
   */
  export type SharedProfileActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * Filter, which SharedProfileActivity to fetch.
     */
    where: SharedProfileActivityWhereUniqueInput
  }

  /**
   * SharedProfileActivity findUniqueOrThrow
   */
  export type SharedProfileActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * Filter, which SharedProfileActivity to fetch.
     */
    where: SharedProfileActivityWhereUniqueInput
  }

  /**
   * SharedProfileActivity findFirst
   */
  export type SharedProfileActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * Filter, which SharedProfileActivity to fetch.
     */
    where?: SharedProfileActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProfileActivities to fetch.
     */
    orderBy?: SharedProfileActivityOrderByWithRelationInput | SharedProfileActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedProfileActivities.
     */
    cursor?: SharedProfileActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProfileActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProfileActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedProfileActivities.
     */
    distinct?: SharedProfileActivityScalarFieldEnum | SharedProfileActivityScalarFieldEnum[]
  }

  /**
   * SharedProfileActivity findFirstOrThrow
   */
  export type SharedProfileActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * Filter, which SharedProfileActivity to fetch.
     */
    where?: SharedProfileActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProfileActivities to fetch.
     */
    orderBy?: SharedProfileActivityOrderByWithRelationInput | SharedProfileActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedProfileActivities.
     */
    cursor?: SharedProfileActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProfileActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProfileActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedProfileActivities.
     */
    distinct?: SharedProfileActivityScalarFieldEnum | SharedProfileActivityScalarFieldEnum[]
  }

  /**
   * SharedProfileActivity findMany
   */
  export type SharedProfileActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * Filter, which SharedProfileActivities to fetch.
     */
    where?: SharedProfileActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProfileActivities to fetch.
     */
    orderBy?: SharedProfileActivityOrderByWithRelationInput | SharedProfileActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedProfileActivities.
     */
    cursor?: SharedProfileActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProfileActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProfileActivities.
     */
    skip?: number
    distinct?: SharedProfileActivityScalarFieldEnum | SharedProfileActivityScalarFieldEnum[]
  }

  /**
   * SharedProfileActivity create
   */
  export type SharedProfileActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedProfileActivity.
     */
    data: XOR<SharedProfileActivityCreateInput, SharedProfileActivityUncheckedCreateInput>
  }

  /**
   * SharedProfileActivity createMany
   */
  export type SharedProfileActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedProfileActivities.
     */
    data: SharedProfileActivityCreateManyInput | SharedProfileActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedProfileActivity createManyAndReturn
   */
  export type SharedProfileActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * The data used to create many SharedProfileActivities.
     */
    data: SharedProfileActivityCreateManyInput | SharedProfileActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedProfileActivity update
   */
  export type SharedProfileActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedProfileActivity.
     */
    data: XOR<SharedProfileActivityUpdateInput, SharedProfileActivityUncheckedUpdateInput>
    /**
     * Choose, which SharedProfileActivity to update.
     */
    where: SharedProfileActivityWhereUniqueInput
  }

  /**
   * SharedProfileActivity updateMany
   */
  export type SharedProfileActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedProfileActivities.
     */
    data: XOR<SharedProfileActivityUpdateManyMutationInput, SharedProfileActivityUncheckedUpdateManyInput>
    /**
     * Filter which SharedProfileActivities to update
     */
    where?: SharedProfileActivityWhereInput
    /**
     * Limit how many SharedProfileActivities to update.
     */
    limit?: number
  }

  /**
   * SharedProfileActivity updateManyAndReturn
   */
  export type SharedProfileActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * The data used to update SharedProfileActivities.
     */
    data: XOR<SharedProfileActivityUpdateManyMutationInput, SharedProfileActivityUncheckedUpdateManyInput>
    /**
     * Filter which SharedProfileActivities to update
     */
    where?: SharedProfileActivityWhereInput
    /**
     * Limit how many SharedProfileActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedProfileActivity upsert
   */
  export type SharedProfileActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedProfileActivity to update in case it exists.
     */
    where: SharedProfileActivityWhereUniqueInput
    /**
     * In case the SharedProfileActivity found by the `where` argument doesn't exist, create a new SharedProfileActivity with this data.
     */
    create: XOR<SharedProfileActivityCreateInput, SharedProfileActivityUncheckedCreateInput>
    /**
     * In case the SharedProfileActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedProfileActivityUpdateInput, SharedProfileActivityUncheckedUpdateInput>
  }

  /**
   * SharedProfileActivity delete
   */
  export type SharedProfileActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
    /**
     * Filter which SharedProfileActivity to delete.
     */
    where: SharedProfileActivityWhereUniqueInput
  }

  /**
   * SharedProfileActivity deleteMany
   */
  export type SharedProfileActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedProfileActivities to delete
     */
    where?: SharedProfileActivityWhereInput
    /**
     * Limit how many SharedProfileActivities to delete.
     */
    limit?: number
  }

  /**
   * SharedProfileActivity without action
   */
  export type SharedProfileActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProfileActivity
     */
    select?: SharedProfileActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedProfileActivity
     */
    omit?: SharedProfileActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProfileActivityInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    name: 'name',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt',
    isVerified: 'isVerified',
    isMainAccount: 'isMainAccount',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    maxSharedAccounts: 'maxSharedAccounts',
    videoQuality: 'videoQuality'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    start_date: 'start_date',
    end_date: 'end_date',
    renewal_status: 'renewal_status'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SharedAccountScalarFieldEnum: {
    id: 'id',
    ownerUserId: 'ownerUserId',
    sharedUserId: 'sharedUserId',
    subscriptionId: 'subscriptionId',
    shared_on: 'shared_on',
    status: 'status',
    is_active: 'is_active'
  };

  export type SharedAccountScalarFieldEnum = (typeof SharedAccountScalarFieldEnum)[keyof typeof SharedAccountScalarFieldEnum]


  export const SharedAccountUserScalarFieldEnum: {
    id: 'id',
    sharedAccountId: 'sharedAccountId',
    userId: 'userId',
    profile_name: 'profile_name',
    is_kid_profile: 'is_kid_profile',
    avatar_url: 'avatar_url',
    pin_code: 'pin_code',
    created_at: 'created_at'
  };

  export type SharedAccountUserScalarFieldEnum = (typeof SharedAccountUserScalarFieldEnum)[keyof typeof SharedAccountUserScalarFieldEnum]


  export const VideoMetadataScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnailUrl: 'thumbnailUrl',
    secondaryImage: 'secondaryImage',
    releaseDate: 'releaseDate',
    platformDate: 'platformDate',
    ageRating: 'ageRating',
    productionHouse: 'productionHouse',
    productionCountry: 'productionCountry',
    director: 'director',
    formatId: 'formatId',
    categoryId: 'categoryId',
    status: 'status'
  };

  export type VideoMetadataScalarFieldEnum = (typeof VideoMetadataScalarFieldEnum)[keyof typeof VideoMetadataScalarFieldEnum]


  export const VideoFileScalarFieldEnum: {
    id: 'id',
    filePath: 'filePath',
    trailerPath: 'trailerPath',
    duration: 'duration',
    width: 'width',
    height: 'height'
  };

  export type VideoFileScalarFieldEnum = (typeof VideoFileScalarFieldEnum)[keyof typeof VideoFileScalarFieldEnum]


  export const VideoGenreScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type VideoGenreScalarFieldEnum = (typeof VideoGenreScalarFieldEnum)[keyof typeof VideoGenreScalarFieldEnum]


  export const ActorScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ActorScalarFieldEnum = (typeof ActorScalarFieldEnum)[keyof typeof ActorScalarFieldEnum]


  export const VideoActorScalarFieldEnum: {
    videoId: 'videoId',
    actorId: 'actorId',
    role: 'role'
  };

  export type VideoActorScalarFieldEnum = (typeof VideoActorScalarFieldEnum)[keyof typeof VideoActorScalarFieldEnum]


  export const VideoLanguageScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name'
  };

  export type VideoLanguageScalarFieldEnum = (typeof VideoLanguageScalarFieldEnum)[keyof typeof VideoLanguageScalarFieldEnum]


  export const VideoFormatScalarFieldEnum: {
    id: 'id',
    format: 'format',
    description: 'description'
  };

  export type VideoFormatScalarFieldEnum = (typeof VideoFormatScalarFieldEnum)[keyof typeof VideoFormatScalarFieldEnum]


  export const VideoCategoryScalarFieldEnum: {
    id: 'id',
    category: 'category',
    description: 'description'
  };

  export type VideoCategoryScalarFieldEnum = (typeof VideoCategoryScalarFieldEnum)[keyof typeof VideoCategoryScalarFieldEnum]


  export const MovieScalarFieldEnum: {
    id: 'id',
    metadataId: 'metadataId',
    videoFileId: 'videoFileId',
    status: 'status',
    type: 'type',
    seasonCount: 'seasonCount',
    rentalPrice: 'rentalPrice'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const SeriesScalarFieldEnum: {
    id: 'id',
    metadataId: 'metadataId',
    status: 'status',
    type: 'type',
    seasonCount: 'seasonCount',
    rentalPrice: 'rentalPrice'
  };

  export type SeriesScalarFieldEnum = (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    seriesId: 'seriesId',
    number: 'number'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const EpisodeScalarFieldEnum: {
    id: 'id',
    seasonId: 'seasonId',
    number: 'number',
    videoFileId: 'videoFileId',
    metadataId: 'metadataId'
  };

  export type EpisodeScalarFieldEnum = (typeof EpisodeScalarFieldEnum)[keyof typeof EpisodeScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const MovieTagScalarFieldEnum: {
    movieId: 'movieId',
    tagId: 'tagId'
  };

  export type MovieTagScalarFieldEnum = (typeof MovieTagScalarFieldEnum)[keyof typeof MovieTagScalarFieldEnum]


  export const SeriesTagScalarFieldEnum: {
    seriesId: 'seriesId',
    tagId: 'tagId'
  };

  export type SeriesTagScalarFieldEnum = (typeof SeriesTagScalarFieldEnum)[keyof typeof SeriesTagScalarFieldEnum]


  export const SubtitleScalarFieldEnum: {
    videoId: 'videoId',
    language: 'language',
    subtitle_url: 'subtitle_url',
    videoMetadataId: 'videoMetadataId'
  };

  export type SubtitleScalarFieldEnum = (typeof SubtitleScalarFieldEnum)[keyof typeof SubtitleScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    videoId: 'videoId',
    purchase_date: 'purchase_date',
    expiration_date: 'expiration_date'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const ViewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileId: 'profileId',
    videoId: 'videoId',
    viewed_at: 'viewed_at',
    progress_seconds: 'progress_seconds'
  };

  export type ViewScalarFieldEnum = (typeof ViewScalarFieldEnum)[keyof typeof ViewScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    videoId: 'videoId',
    text: 'text',
    created_at: 'created_at',
    parentCommentId: 'parentCommentId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const AdScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image_url: 'image_url',
    video_url: 'video_url',
    start_date: 'start_date',
    end_date: 'end_date',
    is_active: 'is_active'
  };

  export type AdScalarFieldEnum = (typeof AdScalarFieldEnum)[keyof typeof AdScalarFieldEnum]


  export const AdViewScalarFieldEnum: {
    id: 'id',
    adId: 'adId',
    userId: 'userId',
    profileId: 'profileId',
    viewed_at: 'viewed_at'
  };

  export type AdViewScalarFieldEnum = (typeof AdViewScalarFieldEnum)[keyof typeof AdViewScalarFieldEnum]


  export const SharedProfileActivityScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    action: 'action',
    details: 'details',
    performed_at: 'performed_at'
  };

  export type SharedProfileActivityScalarFieldEnum = (typeof SharedProfileActivityScalarFieldEnum)[keyof typeof SharedProfileActivityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VideoQuality'
   */
  export type EnumVideoQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoQuality'>
    


  /**
   * Reference to a field of type 'VideoQuality[]'
   */
  export type ListEnumVideoQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoQuality[]'>
    


  /**
   * Reference to a field of type 'RenewalStatus'
   */
  export type EnumRenewalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RenewalStatus'>
    


  /**
   * Reference to a field of type 'RenewalStatus[]'
   */
  export type ListEnumRenewalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RenewalStatus[]'>
    


  /**
   * Reference to a field of type 'SharedAccountStatus'
   */
  export type EnumSharedAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SharedAccountStatus'>
    


  /**
   * Reference to a field of type 'SharedAccountStatus[]'
   */
  export type ListEnumSharedAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SharedAccountStatus[]'>
    


  /**
   * Reference to a field of type 'ProfileActivityAction'
   */
  export type EnumProfileActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileActivityAction'>
    


  /**
   * Reference to a field of type 'ProfileActivityAction[]'
   */
  export type ListEnumProfileActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileActivityAction[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isMainAccount?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    sessions?: SessionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    ownedSharedAccounts?: SharedAccountListRelationFilter
    sharedProfiles?: SharedAccountUserListRelationFilter
    purchases?: PurchaseListRelationFilter
    views?: ViewListRelationFilter
    comments?: CommentListRelationFilter
    SharedAccount?: SharedAccountListRelationFilter
    adViews?: AdViewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isMainAccount?: SortOrder
    role?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    ownedSharedAccounts?: SharedAccountOrderByRelationAggregateInput
    sharedProfiles?: SharedAccountUserOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    views?: ViewOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    SharedAccount?: SharedAccountOrderByRelationAggregateInput
    adViews?: AdViewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isMainAccount?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    sessions?: SessionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    ownedSharedAccounts?: SharedAccountListRelationFilter
    sharedProfiles?: SharedAccountUserListRelationFilter
    purchases?: PurchaseListRelationFilter
    views?: ViewListRelationFilter
    comments?: CommentListRelationFilter
    SharedAccount?: SharedAccountListRelationFilter
    adViews?: AdViewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isMainAccount?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isMainAccount?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    price?: FloatFilter<"SubscriptionPlan"> | number
    maxSharedAccounts?: IntFilter<"SubscriptionPlan"> | number
    videoQuality?: EnumVideoQualityFilter<"SubscriptionPlan"> | $Enums.VideoQuality
    subscriptions?: SubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    maxSharedAccounts?: SortOrder
    videoQuality?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    price?: FloatFilter<"SubscriptionPlan"> | number
    maxSharedAccounts?: IntFilter<"SubscriptionPlan"> | number
    videoQuality?: EnumVideoQualityFilter<"SubscriptionPlan"> | $Enums.VideoQuality
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "name">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    maxSharedAccounts?: SortOrder
    videoQuality?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    price?: FloatWithAggregatesFilter<"SubscriptionPlan"> | number
    maxSharedAccounts?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    videoQuality?: EnumVideoQualityWithAggregatesFilter<"SubscriptionPlan"> | $Enums.VideoQuality
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    start_date?: DateTimeFilter<"Subscription"> | Date | string
    end_date?: DateTimeFilter<"Subscription"> | Date | string
    renewal_status?: EnumRenewalStatusFilter<"Subscription"> | $Enums.RenewalStatus
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    sharedAccounts?: SharedAccountListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    renewal_status?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
    sharedAccounts?: SharedAccountOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    start_date?: DateTimeFilter<"Subscription"> | Date | string
    end_date?: DateTimeFilter<"Subscription"> | Date | string
    renewal_status?: EnumRenewalStatusFilter<"Subscription"> | $Enums.RenewalStatus
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    sharedAccounts?: SharedAccountListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    renewal_status?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    start_date?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    renewal_status?: EnumRenewalStatusWithAggregatesFilter<"Subscription"> | $Enums.RenewalStatus
  }

  export type SharedAccountWhereInput = {
    AND?: SharedAccountWhereInput | SharedAccountWhereInput[]
    OR?: SharedAccountWhereInput[]
    NOT?: SharedAccountWhereInput | SharedAccountWhereInput[]
    id?: StringFilter<"SharedAccount"> | string
    ownerUserId?: StringFilter<"SharedAccount"> | string
    sharedUserId?: StringNullableFilter<"SharedAccount"> | string | null
    subscriptionId?: StringFilter<"SharedAccount"> | string
    shared_on?: DateTimeFilter<"SharedAccount"> | Date | string
    status?: EnumSharedAccountStatusFilter<"SharedAccount"> | $Enums.SharedAccountStatus
    is_active?: BoolFilter<"SharedAccount"> | boolean
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    sharedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    profiles?: SharedAccountUserListRelationFilter
  }

  export type SharedAccountOrderByWithRelationInput = {
    id?: SortOrder
    ownerUserId?: SortOrder
    sharedUserId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrder
    shared_on?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    owner?: UserOrderByWithRelationInput
    sharedUser?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    profiles?: SharedAccountUserOrderByRelationAggregateInput
  }

  export type SharedAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharedAccountWhereInput | SharedAccountWhereInput[]
    OR?: SharedAccountWhereInput[]
    NOT?: SharedAccountWhereInput | SharedAccountWhereInput[]
    ownerUserId?: StringFilter<"SharedAccount"> | string
    sharedUserId?: StringNullableFilter<"SharedAccount"> | string | null
    subscriptionId?: StringFilter<"SharedAccount"> | string
    shared_on?: DateTimeFilter<"SharedAccount"> | Date | string
    status?: EnumSharedAccountStatusFilter<"SharedAccount"> | $Enums.SharedAccountStatus
    is_active?: BoolFilter<"SharedAccount"> | boolean
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    sharedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    profiles?: SharedAccountUserListRelationFilter
  }, "id">

  export type SharedAccountOrderByWithAggregationInput = {
    id?: SortOrder
    ownerUserId?: SortOrder
    sharedUserId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrder
    shared_on?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    _count?: SharedAccountCountOrderByAggregateInput
    _max?: SharedAccountMaxOrderByAggregateInput
    _min?: SharedAccountMinOrderByAggregateInput
  }

  export type SharedAccountScalarWhereWithAggregatesInput = {
    AND?: SharedAccountScalarWhereWithAggregatesInput | SharedAccountScalarWhereWithAggregatesInput[]
    OR?: SharedAccountScalarWhereWithAggregatesInput[]
    NOT?: SharedAccountScalarWhereWithAggregatesInput | SharedAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedAccount"> | string
    ownerUserId?: StringWithAggregatesFilter<"SharedAccount"> | string
    sharedUserId?: StringNullableWithAggregatesFilter<"SharedAccount"> | string | null
    subscriptionId?: StringWithAggregatesFilter<"SharedAccount"> | string
    shared_on?: DateTimeWithAggregatesFilter<"SharedAccount"> | Date | string
    status?: EnumSharedAccountStatusWithAggregatesFilter<"SharedAccount"> | $Enums.SharedAccountStatus
    is_active?: BoolWithAggregatesFilter<"SharedAccount"> | boolean
  }

  export type SharedAccountUserWhereInput = {
    AND?: SharedAccountUserWhereInput | SharedAccountUserWhereInput[]
    OR?: SharedAccountUserWhereInput[]
    NOT?: SharedAccountUserWhereInput | SharedAccountUserWhereInput[]
    id?: StringFilter<"SharedAccountUser"> | string
    sharedAccountId?: StringFilter<"SharedAccountUser"> | string
    userId?: StringFilter<"SharedAccountUser"> | string
    profile_name?: StringFilter<"SharedAccountUser"> | string
    is_kid_profile?: BoolFilter<"SharedAccountUser"> | boolean
    avatar_url?: StringNullableFilter<"SharedAccountUser"> | string | null
    pin_code?: StringNullableFilter<"SharedAccountUser"> | string | null
    created_at?: DateTimeFilter<"SharedAccountUser"> | Date | string
    sharedAccount?: XOR<SharedAccountScalarRelationFilter, SharedAccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    views?: ViewListRelationFilter
    adViews?: AdViewListRelationFilter
    activities?: SharedProfileActivityListRelationFilter
  }

  export type SharedAccountUserOrderByWithRelationInput = {
    id?: SortOrder
    sharedAccountId?: SortOrder
    userId?: SortOrder
    profile_name?: SortOrder
    is_kid_profile?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    pin_code?: SortOrderInput | SortOrder
    created_at?: SortOrder
    sharedAccount?: SharedAccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    views?: ViewOrderByRelationAggregateInput
    adViews?: AdViewOrderByRelationAggregateInput
    activities?: SharedProfileActivityOrderByRelationAggregateInput
  }

  export type SharedAccountUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sharedAccountId_profile_name?: SharedAccountUserSharedAccountIdProfile_nameCompoundUniqueInput
    AND?: SharedAccountUserWhereInput | SharedAccountUserWhereInput[]
    OR?: SharedAccountUserWhereInput[]
    NOT?: SharedAccountUserWhereInput | SharedAccountUserWhereInput[]
    sharedAccountId?: StringFilter<"SharedAccountUser"> | string
    userId?: StringFilter<"SharedAccountUser"> | string
    profile_name?: StringFilter<"SharedAccountUser"> | string
    is_kid_profile?: BoolFilter<"SharedAccountUser"> | boolean
    avatar_url?: StringNullableFilter<"SharedAccountUser"> | string | null
    pin_code?: StringNullableFilter<"SharedAccountUser"> | string | null
    created_at?: DateTimeFilter<"SharedAccountUser"> | Date | string
    sharedAccount?: XOR<SharedAccountScalarRelationFilter, SharedAccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    views?: ViewListRelationFilter
    adViews?: AdViewListRelationFilter
    activities?: SharedProfileActivityListRelationFilter
  }, "id" | "sharedAccountId_profile_name">

  export type SharedAccountUserOrderByWithAggregationInput = {
    id?: SortOrder
    sharedAccountId?: SortOrder
    userId?: SortOrder
    profile_name?: SortOrder
    is_kid_profile?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    pin_code?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: SharedAccountUserCountOrderByAggregateInput
    _max?: SharedAccountUserMaxOrderByAggregateInput
    _min?: SharedAccountUserMinOrderByAggregateInput
  }

  export type SharedAccountUserScalarWhereWithAggregatesInput = {
    AND?: SharedAccountUserScalarWhereWithAggregatesInput | SharedAccountUserScalarWhereWithAggregatesInput[]
    OR?: SharedAccountUserScalarWhereWithAggregatesInput[]
    NOT?: SharedAccountUserScalarWhereWithAggregatesInput | SharedAccountUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedAccountUser"> | string
    sharedAccountId?: StringWithAggregatesFilter<"SharedAccountUser"> | string
    userId?: StringWithAggregatesFilter<"SharedAccountUser"> | string
    profile_name?: StringWithAggregatesFilter<"SharedAccountUser"> | string
    is_kid_profile?: BoolWithAggregatesFilter<"SharedAccountUser"> | boolean
    avatar_url?: StringNullableWithAggregatesFilter<"SharedAccountUser"> | string | null
    pin_code?: StringNullableWithAggregatesFilter<"SharedAccountUser"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SharedAccountUser"> | Date | string
  }

  export type VideoMetadataWhereInput = {
    AND?: VideoMetadataWhereInput | VideoMetadataWhereInput[]
    OR?: VideoMetadataWhereInput[]
    NOT?: VideoMetadataWhereInput | VideoMetadataWhereInput[]
    id?: StringFilter<"VideoMetadata"> | string
    title?: StringFilter<"VideoMetadata"> | string
    description?: StringFilter<"VideoMetadata"> | string
    thumbnailUrl?: StringFilter<"VideoMetadata"> | string
    secondaryImage?: StringNullableFilter<"VideoMetadata"> | string | null
    releaseDate?: DateTimeFilter<"VideoMetadata"> | Date | string
    platformDate?: DateTimeFilter<"VideoMetadata"> | Date | string
    ageRating?: StringFilter<"VideoMetadata"> | string
    productionHouse?: StringFilter<"VideoMetadata"> | string
    productionCountry?: StringFilter<"VideoMetadata"> | string
    director?: StringFilter<"VideoMetadata"> | string
    formatId?: StringFilter<"VideoMetadata"> | string
    categoryId?: StringFilter<"VideoMetadata"> | string
    status?: StringFilter<"VideoMetadata"> | string
    format?: XOR<VideoFormatScalarRelationFilter, VideoFormatWhereInput>
    category?: XOR<VideoCategoryScalarRelationFilter, VideoCategoryWhereInput>
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
    episode?: XOR<EpisodeNullableScalarRelationFilter, EpisodeWhereInput> | null
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null
    genres?: VideoGenreListRelationFilter
    actors?: VideoActorListRelationFilter
    subtitles?: SubtitleListRelationFilter
    languages?: VideoLanguageListRelationFilter
  }

  export type VideoMetadataOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    secondaryImage?: SortOrderInput | SortOrder
    releaseDate?: SortOrder
    platformDate?: SortOrder
    ageRating?: SortOrder
    productionHouse?: SortOrder
    productionCountry?: SortOrder
    director?: SortOrder
    formatId?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
    format?: VideoFormatOrderByWithRelationInput
    category?: VideoCategoryOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
    episode?: EpisodeOrderByWithRelationInput
    series?: SeriesOrderByWithRelationInput
    genres?: VideoGenreOrderByRelationAggregateInput
    actors?: VideoActorOrderByRelationAggregateInput
    subtitles?: SubtitleOrderByRelationAggregateInput
    languages?: VideoLanguageOrderByRelationAggregateInput
  }

  export type VideoMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoMetadataWhereInput | VideoMetadataWhereInput[]
    OR?: VideoMetadataWhereInput[]
    NOT?: VideoMetadataWhereInput | VideoMetadataWhereInput[]
    title?: StringFilter<"VideoMetadata"> | string
    description?: StringFilter<"VideoMetadata"> | string
    thumbnailUrl?: StringFilter<"VideoMetadata"> | string
    secondaryImage?: StringNullableFilter<"VideoMetadata"> | string | null
    releaseDate?: DateTimeFilter<"VideoMetadata"> | Date | string
    platformDate?: DateTimeFilter<"VideoMetadata"> | Date | string
    ageRating?: StringFilter<"VideoMetadata"> | string
    productionHouse?: StringFilter<"VideoMetadata"> | string
    productionCountry?: StringFilter<"VideoMetadata"> | string
    director?: StringFilter<"VideoMetadata"> | string
    formatId?: StringFilter<"VideoMetadata"> | string
    categoryId?: StringFilter<"VideoMetadata"> | string
    status?: StringFilter<"VideoMetadata"> | string
    format?: XOR<VideoFormatScalarRelationFilter, VideoFormatWhereInput>
    category?: XOR<VideoCategoryScalarRelationFilter, VideoCategoryWhereInput>
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
    episode?: XOR<EpisodeNullableScalarRelationFilter, EpisodeWhereInput> | null
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null
    genres?: VideoGenreListRelationFilter
    actors?: VideoActorListRelationFilter
    subtitles?: SubtitleListRelationFilter
    languages?: VideoLanguageListRelationFilter
  }, "id">

  export type VideoMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    secondaryImage?: SortOrderInput | SortOrder
    releaseDate?: SortOrder
    platformDate?: SortOrder
    ageRating?: SortOrder
    productionHouse?: SortOrder
    productionCountry?: SortOrder
    director?: SortOrder
    formatId?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
    _count?: VideoMetadataCountOrderByAggregateInput
    _max?: VideoMetadataMaxOrderByAggregateInput
    _min?: VideoMetadataMinOrderByAggregateInput
  }

  export type VideoMetadataScalarWhereWithAggregatesInput = {
    AND?: VideoMetadataScalarWhereWithAggregatesInput | VideoMetadataScalarWhereWithAggregatesInput[]
    OR?: VideoMetadataScalarWhereWithAggregatesInput[]
    NOT?: VideoMetadataScalarWhereWithAggregatesInput | VideoMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoMetadata"> | string
    title?: StringWithAggregatesFilter<"VideoMetadata"> | string
    description?: StringWithAggregatesFilter<"VideoMetadata"> | string
    thumbnailUrl?: StringWithAggregatesFilter<"VideoMetadata"> | string
    secondaryImage?: StringNullableWithAggregatesFilter<"VideoMetadata"> | string | null
    releaseDate?: DateTimeWithAggregatesFilter<"VideoMetadata"> | Date | string
    platformDate?: DateTimeWithAggregatesFilter<"VideoMetadata"> | Date | string
    ageRating?: StringWithAggregatesFilter<"VideoMetadata"> | string
    productionHouse?: StringWithAggregatesFilter<"VideoMetadata"> | string
    productionCountry?: StringWithAggregatesFilter<"VideoMetadata"> | string
    director?: StringWithAggregatesFilter<"VideoMetadata"> | string
    formatId?: StringWithAggregatesFilter<"VideoMetadata"> | string
    categoryId?: StringWithAggregatesFilter<"VideoMetadata"> | string
    status?: StringWithAggregatesFilter<"VideoMetadata"> | string
  }

  export type VideoFileWhereInput = {
    AND?: VideoFileWhereInput | VideoFileWhereInput[]
    OR?: VideoFileWhereInput[]
    NOT?: VideoFileWhereInput | VideoFileWhereInput[]
    id?: StringFilter<"VideoFile"> | string
    filePath?: StringFilter<"VideoFile"> | string
    trailerPath?: StringNullableFilter<"VideoFile"> | string | null
    duration?: IntFilter<"VideoFile"> | number
    width?: IntNullableFilter<"VideoFile"> | number | null
    height?: IntNullableFilter<"VideoFile"> | number | null
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
    episode?: XOR<EpisodeNullableScalarRelationFilter, EpisodeWhereInput> | null
    subtitles?: SubtitleListRelationFilter
    purchases?: PurchaseListRelationFilter
    comments?: CommentListRelationFilter
    views?: ViewListRelationFilter
  }

  export type VideoFileOrderByWithRelationInput = {
    id?: SortOrder
    filePath?: SortOrder
    trailerPath?: SortOrderInput | SortOrder
    duration?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    movie?: MovieOrderByWithRelationInput
    episode?: EpisodeOrderByWithRelationInput
    subtitles?: SubtitleOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    views?: ViewOrderByRelationAggregateInput
  }

  export type VideoFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoFileWhereInput | VideoFileWhereInput[]
    OR?: VideoFileWhereInput[]
    NOT?: VideoFileWhereInput | VideoFileWhereInput[]
    filePath?: StringFilter<"VideoFile"> | string
    trailerPath?: StringNullableFilter<"VideoFile"> | string | null
    duration?: IntFilter<"VideoFile"> | number
    width?: IntNullableFilter<"VideoFile"> | number | null
    height?: IntNullableFilter<"VideoFile"> | number | null
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
    episode?: XOR<EpisodeNullableScalarRelationFilter, EpisodeWhereInput> | null
    subtitles?: SubtitleListRelationFilter
    purchases?: PurchaseListRelationFilter
    comments?: CommentListRelationFilter
    views?: ViewListRelationFilter
  }, "id">

  export type VideoFileOrderByWithAggregationInput = {
    id?: SortOrder
    filePath?: SortOrder
    trailerPath?: SortOrderInput | SortOrder
    duration?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    _count?: VideoFileCountOrderByAggregateInput
    _avg?: VideoFileAvgOrderByAggregateInput
    _max?: VideoFileMaxOrderByAggregateInput
    _min?: VideoFileMinOrderByAggregateInput
    _sum?: VideoFileSumOrderByAggregateInput
  }

  export type VideoFileScalarWhereWithAggregatesInput = {
    AND?: VideoFileScalarWhereWithAggregatesInput | VideoFileScalarWhereWithAggregatesInput[]
    OR?: VideoFileScalarWhereWithAggregatesInput[]
    NOT?: VideoFileScalarWhereWithAggregatesInput | VideoFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoFile"> | string
    filePath?: StringWithAggregatesFilter<"VideoFile"> | string
    trailerPath?: StringNullableWithAggregatesFilter<"VideoFile"> | string | null
    duration?: IntWithAggregatesFilter<"VideoFile"> | number
    width?: IntNullableWithAggregatesFilter<"VideoFile"> | number | null
    height?: IntNullableWithAggregatesFilter<"VideoFile"> | number | null
  }

  export type VideoGenreWhereInput = {
    AND?: VideoGenreWhereInput | VideoGenreWhereInput[]
    OR?: VideoGenreWhereInput[]
    NOT?: VideoGenreWhereInput | VideoGenreWhereInput[]
    id?: StringFilter<"VideoGenre"> | string
    name?: StringFilter<"VideoGenre"> | string
    videos?: VideoMetadataListRelationFilter
  }

  export type VideoGenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    videos?: VideoMetadataOrderByRelationAggregateInput
  }

  export type VideoGenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: VideoGenreWhereInput | VideoGenreWhereInput[]
    OR?: VideoGenreWhereInput[]
    NOT?: VideoGenreWhereInput | VideoGenreWhereInput[]
    videos?: VideoMetadataListRelationFilter
  }, "id" | "name">

  export type VideoGenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: VideoGenreCountOrderByAggregateInput
    _max?: VideoGenreMaxOrderByAggregateInput
    _min?: VideoGenreMinOrderByAggregateInput
  }

  export type VideoGenreScalarWhereWithAggregatesInput = {
    AND?: VideoGenreScalarWhereWithAggregatesInput | VideoGenreScalarWhereWithAggregatesInput[]
    OR?: VideoGenreScalarWhereWithAggregatesInput[]
    NOT?: VideoGenreScalarWhereWithAggregatesInput | VideoGenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoGenre"> | string
    name?: StringWithAggregatesFilter<"VideoGenre"> | string
  }

  export type ActorWhereInput = {
    AND?: ActorWhereInput | ActorWhereInput[]
    OR?: ActorWhereInput[]
    NOT?: ActorWhereInput | ActorWhereInput[]
    id?: StringFilter<"Actor"> | string
    name?: StringFilter<"Actor"> | string
    VideoActor?: VideoActorListRelationFilter
  }

  export type ActorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    VideoActor?: VideoActorOrderByRelationAggregateInput
  }

  export type ActorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActorWhereInput | ActorWhereInput[]
    OR?: ActorWhereInput[]
    NOT?: ActorWhereInput | ActorWhereInput[]
    name?: StringFilter<"Actor"> | string
    VideoActor?: VideoActorListRelationFilter
  }, "id">

  export type ActorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ActorCountOrderByAggregateInput
    _max?: ActorMaxOrderByAggregateInput
    _min?: ActorMinOrderByAggregateInput
  }

  export type ActorScalarWhereWithAggregatesInput = {
    AND?: ActorScalarWhereWithAggregatesInput | ActorScalarWhereWithAggregatesInput[]
    OR?: ActorScalarWhereWithAggregatesInput[]
    NOT?: ActorScalarWhereWithAggregatesInput | ActorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Actor"> | string
    name?: StringWithAggregatesFilter<"Actor"> | string
  }

  export type VideoActorWhereInput = {
    AND?: VideoActorWhereInput | VideoActorWhereInput[]
    OR?: VideoActorWhereInput[]
    NOT?: VideoActorWhereInput | VideoActorWhereInput[]
    videoId?: StringFilter<"VideoActor"> | string
    actorId?: StringFilter<"VideoActor"> | string
    role?: StringNullableFilter<"VideoActor"> | string | null
    video?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
    actor?: XOR<ActorScalarRelationFilter, ActorWhereInput>
  }

  export type VideoActorOrderByWithRelationInput = {
    videoId?: SortOrder
    actorId?: SortOrder
    role?: SortOrderInput | SortOrder
    video?: VideoMetadataOrderByWithRelationInput
    actor?: ActorOrderByWithRelationInput
  }

  export type VideoActorWhereUniqueInput = Prisma.AtLeast<{
    videoId_actorId?: VideoActorVideoIdActorIdCompoundUniqueInput
    AND?: VideoActorWhereInput | VideoActorWhereInput[]
    OR?: VideoActorWhereInput[]
    NOT?: VideoActorWhereInput | VideoActorWhereInput[]
    videoId?: StringFilter<"VideoActor"> | string
    actorId?: StringFilter<"VideoActor"> | string
    role?: StringNullableFilter<"VideoActor"> | string | null
    video?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
    actor?: XOR<ActorScalarRelationFilter, ActorWhereInput>
  }, "videoId_actorId">

  export type VideoActorOrderByWithAggregationInput = {
    videoId?: SortOrder
    actorId?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: VideoActorCountOrderByAggregateInput
    _max?: VideoActorMaxOrderByAggregateInput
    _min?: VideoActorMinOrderByAggregateInput
  }

  export type VideoActorScalarWhereWithAggregatesInput = {
    AND?: VideoActorScalarWhereWithAggregatesInput | VideoActorScalarWhereWithAggregatesInput[]
    OR?: VideoActorScalarWhereWithAggregatesInput[]
    NOT?: VideoActorScalarWhereWithAggregatesInput | VideoActorScalarWhereWithAggregatesInput[]
    videoId?: StringWithAggregatesFilter<"VideoActor"> | string
    actorId?: StringWithAggregatesFilter<"VideoActor"> | string
    role?: StringNullableWithAggregatesFilter<"VideoActor"> | string | null
  }

  export type VideoLanguageWhereInput = {
    AND?: VideoLanguageWhereInput | VideoLanguageWhereInput[]
    OR?: VideoLanguageWhereInput[]
    NOT?: VideoLanguageWhereInput | VideoLanguageWhereInput[]
    id?: StringFilter<"VideoLanguage"> | string
    code?: StringFilter<"VideoLanguage"> | string
    name?: StringFilter<"VideoLanguage"> | string
    videos?: VideoMetadataListRelationFilter
  }

  export type VideoLanguageOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    videos?: VideoMetadataOrderByRelationAggregateInput
  }

  export type VideoLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VideoLanguageWhereInput | VideoLanguageWhereInput[]
    OR?: VideoLanguageWhereInput[]
    NOT?: VideoLanguageWhereInput | VideoLanguageWhereInput[]
    name?: StringFilter<"VideoLanguage"> | string
    videos?: VideoMetadataListRelationFilter
  }, "id" | "code">

  export type VideoLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: VideoLanguageCountOrderByAggregateInput
    _max?: VideoLanguageMaxOrderByAggregateInput
    _min?: VideoLanguageMinOrderByAggregateInput
  }

  export type VideoLanguageScalarWhereWithAggregatesInput = {
    AND?: VideoLanguageScalarWhereWithAggregatesInput | VideoLanguageScalarWhereWithAggregatesInput[]
    OR?: VideoLanguageScalarWhereWithAggregatesInput[]
    NOT?: VideoLanguageScalarWhereWithAggregatesInput | VideoLanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoLanguage"> | string
    code?: StringWithAggregatesFilter<"VideoLanguage"> | string
    name?: StringWithAggregatesFilter<"VideoLanguage"> | string
  }

  export type VideoFormatWhereInput = {
    AND?: VideoFormatWhereInput | VideoFormatWhereInput[]
    OR?: VideoFormatWhereInput[]
    NOT?: VideoFormatWhereInput | VideoFormatWhereInput[]
    id?: StringFilter<"VideoFormat"> | string
    format?: StringFilter<"VideoFormat"> | string
    description?: StringNullableFilter<"VideoFormat"> | string | null
    videos?: VideoMetadataListRelationFilter
  }

  export type VideoFormatOrderByWithRelationInput = {
    id?: SortOrder
    format?: SortOrder
    description?: SortOrderInput | SortOrder
    videos?: VideoMetadataOrderByRelationAggregateInput
  }

  export type VideoFormatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    format?: string
    AND?: VideoFormatWhereInput | VideoFormatWhereInput[]
    OR?: VideoFormatWhereInput[]
    NOT?: VideoFormatWhereInput | VideoFormatWhereInput[]
    description?: StringNullableFilter<"VideoFormat"> | string | null
    videos?: VideoMetadataListRelationFilter
  }, "id" | "format">

  export type VideoFormatOrderByWithAggregationInput = {
    id?: SortOrder
    format?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: VideoFormatCountOrderByAggregateInput
    _max?: VideoFormatMaxOrderByAggregateInput
    _min?: VideoFormatMinOrderByAggregateInput
  }

  export type VideoFormatScalarWhereWithAggregatesInput = {
    AND?: VideoFormatScalarWhereWithAggregatesInput | VideoFormatScalarWhereWithAggregatesInput[]
    OR?: VideoFormatScalarWhereWithAggregatesInput[]
    NOT?: VideoFormatScalarWhereWithAggregatesInput | VideoFormatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoFormat"> | string
    format?: StringWithAggregatesFilter<"VideoFormat"> | string
    description?: StringNullableWithAggregatesFilter<"VideoFormat"> | string | null
  }

  export type VideoCategoryWhereInput = {
    AND?: VideoCategoryWhereInput | VideoCategoryWhereInput[]
    OR?: VideoCategoryWhereInput[]
    NOT?: VideoCategoryWhereInput | VideoCategoryWhereInput[]
    id?: StringFilter<"VideoCategory"> | string
    category?: StringFilter<"VideoCategory"> | string
    description?: StringNullableFilter<"VideoCategory"> | string | null
    videos?: VideoMetadataListRelationFilter
  }

  export type VideoCategoryOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    videos?: VideoMetadataOrderByRelationAggregateInput
  }

  export type VideoCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    category?: string
    AND?: VideoCategoryWhereInput | VideoCategoryWhereInput[]
    OR?: VideoCategoryWhereInput[]
    NOT?: VideoCategoryWhereInput | VideoCategoryWhereInput[]
    description?: StringNullableFilter<"VideoCategory"> | string | null
    videos?: VideoMetadataListRelationFilter
  }, "id" | "category">

  export type VideoCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: VideoCategoryCountOrderByAggregateInput
    _max?: VideoCategoryMaxOrderByAggregateInput
    _min?: VideoCategoryMinOrderByAggregateInput
  }

  export type VideoCategoryScalarWhereWithAggregatesInput = {
    AND?: VideoCategoryScalarWhereWithAggregatesInput | VideoCategoryScalarWhereWithAggregatesInput[]
    OR?: VideoCategoryScalarWhereWithAggregatesInput[]
    NOT?: VideoCategoryScalarWhereWithAggregatesInput | VideoCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoCategory"> | string
    category?: StringWithAggregatesFilter<"VideoCategory"> | string
    description?: StringNullableWithAggregatesFilter<"VideoCategory"> | string | null
  }

  export type MovieWhereInput = {
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    id?: StringFilter<"Movie"> | string
    metadataId?: StringFilter<"Movie"> | string
    videoFileId?: StringFilter<"Movie"> | string
    status?: StringFilter<"Movie"> | string
    type?: StringFilter<"Movie"> | string
    seasonCount?: IntFilter<"Movie"> | number
    rentalPrice?: FloatNullableFilter<"Movie"> | number | null
    metadata?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
    videoFile?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    tags?: MovieTagListRelationFilter
  }

  export type MovieOrderByWithRelationInput = {
    id?: SortOrder
    metadataId?: SortOrder
    videoFileId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrderInput | SortOrder
    metadata?: VideoMetadataOrderByWithRelationInput
    videoFile?: VideoFileOrderByWithRelationInput
    tags?: MovieTagOrderByRelationAggregateInput
  }

  export type MovieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    metadataId?: string
    videoFileId?: string
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    status?: StringFilter<"Movie"> | string
    type?: StringFilter<"Movie"> | string
    seasonCount?: IntFilter<"Movie"> | number
    rentalPrice?: FloatNullableFilter<"Movie"> | number | null
    metadata?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
    videoFile?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    tags?: MovieTagListRelationFilter
  }, "id" | "metadataId" | "videoFileId">

  export type MovieOrderByWithAggregationInput = {
    id?: SortOrder
    metadataId?: SortOrder
    videoFileId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrderInput | SortOrder
    _count?: MovieCountOrderByAggregateInput
    _avg?: MovieAvgOrderByAggregateInput
    _max?: MovieMaxOrderByAggregateInput
    _min?: MovieMinOrderByAggregateInput
    _sum?: MovieSumOrderByAggregateInput
  }

  export type MovieScalarWhereWithAggregatesInput = {
    AND?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    OR?: MovieScalarWhereWithAggregatesInput[]
    NOT?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Movie"> | string
    metadataId?: StringWithAggregatesFilter<"Movie"> | string
    videoFileId?: StringWithAggregatesFilter<"Movie"> | string
    status?: StringWithAggregatesFilter<"Movie"> | string
    type?: StringWithAggregatesFilter<"Movie"> | string
    seasonCount?: IntWithAggregatesFilter<"Movie"> | number
    rentalPrice?: FloatNullableWithAggregatesFilter<"Movie"> | number | null
  }

  export type SeriesWhereInput = {
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    id?: StringFilter<"Series"> | string
    metadataId?: StringFilter<"Series"> | string
    status?: StringFilter<"Series"> | string
    type?: StringFilter<"Series"> | string
    seasonCount?: IntFilter<"Series"> | number
    rentalPrice?: FloatNullableFilter<"Series"> | number | null
    metadata?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
    seasons?: SeasonListRelationFilter
    tags?: SeriesTagListRelationFilter
  }

  export type SeriesOrderByWithRelationInput = {
    id?: SortOrder
    metadataId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrderInput | SortOrder
    metadata?: VideoMetadataOrderByWithRelationInput
    seasons?: SeasonOrderByRelationAggregateInput
    tags?: SeriesTagOrderByRelationAggregateInput
  }

  export type SeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    metadataId?: string
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    status?: StringFilter<"Series"> | string
    type?: StringFilter<"Series"> | string
    seasonCount?: IntFilter<"Series"> | number
    rentalPrice?: FloatNullableFilter<"Series"> | number | null
    metadata?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
    seasons?: SeasonListRelationFilter
    tags?: SeriesTagListRelationFilter
  }, "id" | "metadataId">

  export type SeriesOrderByWithAggregationInput = {
    id?: SortOrder
    metadataId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrderInput | SortOrder
    _count?: SeriesCountOrderByAggregateInput
    _avg?: SeriesAvgOrderByAggregateInput
    _max?: SeriesMaxOrderByAggregateInput
    _min?: SeriesMinOrderByAggregateInput
    _sum?: SeriesSumOrderByAggregateInput
  }

  export type SeriesScalarWhereWithAggregatesInput = {
    AND?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    OR?: SeriesScalarWhereWithAggregatesInput[]
    NOT?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Series"> | string
    metadataId?: StringWithAggregatesFilter<"Series"> | string
    status?: StringWithAggregatesFilter<"Series"> | string
    type?: StringWithAggregatesFilter<"Series"> | string
    seasonCount?: IntWithAggregatesFilter<"Series"> | number
    rentalPrice?: FloatNullableWithAggregatesFilter<"Series"> | number | null
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: StringFilter<"Season"> | string
    seriesId?: StringFilter<"Season"> | string
    number?: IntFilter<"Season"> | number
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
    episodes?: EpisodeListRelationFilter
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    series?: SeriesOrderByWithRelationInput
    episodes?: EpisodeOrderByRelationAggregateInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seriesId_number?: SeasonSeriesIdNumberCompoundUniqueInput
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    seriesId?: StringFilter<"Season"> | string
    number?: IntFilter<"Season"> | number
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
    episodes?: EpisodeListRelationFilter
  }, "id" | "seriesId_number">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Season"> | string
    seriesId?: StringWithAggregatesFilter<"Season"> | string
    number?: IntWithAggregatesFilter<"Season"> | number
  }

  export type EpisodeWhereInput = {
    AND?: EpisodeWhereInput | EpisodeWhereInput[]
    OR?: EpisodeWhereInput[]
    NOT?: EpisodeWhereInput | EpisodeWhereInput[]
    id?: StringFilter<"Episode"> | string
    seasonId?: StringFilter<"Episode"> | string
    number?: IntFilter<"Episode"> | number
    videoFileId?: StringFilter<"Episode"> | string
    metadataId?: StringFilter<"Episode"> | string
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    videoFile?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    metadata?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
  }

  export type EpisodeOrderByWithRelationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    videoFileId?: SortOrder
    metadataId?: SortOrder
    season?: SeasonOrderByWithRelationInput
    videoFile?: VideoFileOrderByWithRelationInput
    metadata?: VideoMetadataOrderByWithRelationInput
  }

  export type EpisodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoFileId?: string
    metadataId?: string
    seasonId_number?: EpisodeSeasonIdNumberCompoundUniqueInput
    AND?: EpisodeWhereInput | EpisodeWhereInput[]
    OR?: EpisodeWhereInput[]
    NOT?: EpisodeWhereInput | EpisodeWhereInput[]
    seasonId?: StringFilter<"Episode"> | string
    number?: IntFilter<"Episode"> | number
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    videoFile?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    metadata?: XOR<VideoMetadataScalarRelationFilter, VideoMetadataWhereInput>
  }, "id" | "videoFileId" | "metadataId" | "seasonId_number">

  export type EpisodeOrderByWithAggregationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    videoFileId?: SortOrder
    metadataId?: SortOrder
    _count?: EpisodeCountOrderByAggregateInput
    _avg?: EpisodeAvgOrderByAggregateInput
    _max?: EpisodeMaxOrderByAggregateInput
    _min?: EpisodeMinOrderByAggregateInput
    _sum?: EpisodeSumOrderByAggregateInput
  }

  export type EpisodeScalarWhereWithAggregatesInput = {
    AND?: EpisodeScalarWhereWithAggregatesInput | EpisodeScalarWhereWithAggregatesInput[]
    OR?: EpisodeScalarWhereWithAggregatesInput[]
    NOT?: EpisodeScalarWhereWithAggregatesInput | EpisodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Episode"> | string
    seasonId?: StringWithAggregatesFilter<"Episode"> | string
    number?: IntWithAggregatesFilter<"Episode"> | number
    videoFileId?: StringWithAggregatesFilter<"Episode"> | string
    metadataId?: StringWithAggregatesFilter<"Episode"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    movieTags?: MovieTagListRelationFilter
    seriesTags?: SeriesTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    movieTags?: MovieTagOrderByRelationAggregateInput
    seriesTags?: SeriesTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    movieTags?: MovieTagListRelationFilter
    seriesTags?: SeriesTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type MovieTagWhereInput = {
    AND?: MovieTagWhereInput | MovieTagWhereInput[]
    OR?: MovieTagWhereInput[]
    NOT?: MovieTagWhereInput | MovieTagWhereInput[]
    movieId?: StringFilter<"MovieTag"> | string
    tagId?: StringFilter<"MovieTag"> | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type MovieTagOrderByWithRelationInput = {
    movieId?: SortOrder
    tagId?: SortOrder
    movie?: MovieOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type MovieTagWhereUniqueInput = Prisma.AtLeast<{
    movieId_tagId?: MovieTagMovieIdTagIdCompoundUniqueInput
    AND?: MovieTagWhereInput | MovieTagWhereInput[]
    OR?: MovieTagWhereInput[]
    NOT?: MovieTagWhereInput | MovieTagWhereInput[]
    movieId?: StringFilter<"MovieTag"> | string
    tagId?: StringFilter<"MovieTag"> | string
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "movieId_tagId">

  export type MovieTagOrderByWithAggregationInput = {
    movieId?: SortOrder
    tagId?: SortOrder
    _count?: MovieTagCountOrderByAggregateInput
    _max?: MovieTagMaxOrderByAggregateInput
    _min?: MovieTagMinOrderByAggregateInput
  }

  export type MovieTagScalarWhereWithAggregatesInput = {
    AND?: MovieTagScalarWhereWithAggregatesInput | MovieTagScalarWhereWithAggregatesInput[]
    OR?: MovieTagScalarWhereWithAggregatesInput[]
    NOT?: MovieTagScalarWhereWithAggregatesInput | MovieTagScalarWhereWithAggregatesInput[]
    movieId?: StringWithAggregatesFilter<"MovieTag"> | string
    tagId?: StringWithAggregatesFilter<"MovieTag"> | string
  }

  export type SeriesTagWhereInput = {
    AND?: SeriesTagWhereInput | SeriesTagWhereInput[]
    OR?: SeriesTagWhereInput[]
    NOT?: SeriesTagWhereInput | SeriesTagWhereInput[]
    seriesId?: StringFilter<"SeriesTag"> | string
    tagId?: StringFilter<"SeriesTag"> | string
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type SeriesTagOrderByWithRelationInput = {
    seriesId?: SortOrder
    tagId?: SortOrder
    series?: SeriesOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type SeriesTagWhereUniqueInput = Prisma.AtLeast<{
    seriesId_tagId?: SeriesTagSeriesIdTagIdCompoundUniqueInput
    AND?: SeriesTagWhereInput | SeriesTagWhereInput[]
    OR?: SeriesTagWhereInput[]
    NOT?: SeriesTagWhereInput | SeriesTagWhereInput[]
    seriesId?: StringFilter<"SeriesTag"> | string
    tagId?: StringFilter<"SeriesTag"> | string
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "seriesId_tagId">

  export type SeriesTagOrderByWithAggregationInput = {
    seriesId?: SortOrder
    tagId?: SortOrder
    _count?: SeriesTagCountOrderByAggregateInput
    _max?: SeriesTagMaxOrderByAggregateInput
    _min?: SeriesTagMinOrderByAggregateInput
  }

  export type SeriesTagScalarWhereWithAggregatesInput = {
    AND?: SeriesTagScalarWhereWithAggregatesInput | SeriesTagScalarWhereWithAggregatesInput[]
    OR?: SeriesTagScalarWhereWithAggregatesInput[]
    NOT?: SeriesTagScalarWhereWithAggregatesInput | SeriesTagScalarWhereWithAggregatesInput[]
    seriesId?: StringWithAggregatesFilter<"SeriesTag"> | string
    tagId?: StringWithAggregatesFilter<"SeriesTag"> | string
  }

  export type SubtitleWhereInput = {
    AND?: SubtitleWhereInput | SubtitleWhereInput[]
    OR?: SubtitleWhereInput[]
    NOT?: SubtitleWhereInput | SubtitleWhereInput[]
    videoId?: StringFilter<"Subtitle"> | string
    language?: StringFilter<"Subtitle"> | string
    subtitle_url?: StringFilter<"Subtitle"> | string
    videoMetadataId?: StringNullableFilter<"Subtitle"> | string | null
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    videoMetadata?: XOR<VideoMetadataNullableScalarRelationFilter, VideoMetadataWhereInput> | null
  }

  export type SubtitleOrderByWithRelationInput = {
    videoId?: SortOrder
    language?: SortOrder
    subtitle_url?: SortOrder
    videoMetadataId?: SortOrderInput | SortOrder
    video?: VideoFileOrderByWithRelationInput
    videoMetadata?: VideoMetadataOrderByWithRelationInput
  }

  export type SubtitleWhereUniqueInput = Prisma.AtLeast<{
    videoId_language?: SubtitleVideoIdLanguageCompoundUniqueInput
    AND?: SubtitleWhereInput | SubtitleWhereInput[]
    OR?: SubtitleWhereInput[]
    NOT?: SubtitleWhereInput | SubtitleWhereInput[]
    videoId?: StringFilter<"Subtitle"> | string
    language?: StringFilter<"Subtitle"> | string
    subtitle_url?: StringFilter<"Subtitle"> | string
    videoMetadataId?: StringNullableFilter<"Subtitle"> | string | null
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    videoMetadata?: XOR<VideoMetadataNullableScalarRelationFilter, VideoMetadataWhereInput> | null
  }, "videoId_language">

  export type SubtitleOrderByWithAggregationInput = {
    videoId?: SortOrder
    language?: SortOrder
    subtitle_url?: SortOrder
    videoMetadataId?: SortOrderInput | SortOrder
    _count?: SubtitleCountOrderByAggregateInput
    _max?: SubtitleMaxOrderByAggregateInput
    _min?: SubtitleMinOrderByAggregateInput
  }

  export type SubtitleScalarWhereWithAggregatesInput = {
    AND?: SubtitleScalarWhereWithAggregatesInput | SubtitleScalarWhereWithAggregatesInput[]
    OR?: SubtitleScalarWhereWithAggregatesInput[]
    NOT?: SubtitleScalarWhereWithAggregatesInput | SubtitleScalarWhereWithAggregatesInput[]
    videoId?: StringWithAggregatesFilter<"Subtitle"> | string
    language?: StringWithAggregatesFilter<"Subtitle"> | string
    subtitle_url?: StringWithAggregatesFilter<"Subtitle"> | string
    videoMetadataId?: StringNullableWithAggregatesFilter<"Subtitle"> | string | null
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    videoId?: StringFilter<"Purchase"> | string
    purchase_date?: DateTimeFilter<"Purchase"> | Date | string
    expiration_date?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    purchase_date?: SortOrder
    expiration_date?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    video?: VideoFileOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    userId?: StringFilter<"Purchase"> | string
    videoId?: StringFilter<"Purchase"> | string
    purchase_date?: DateTimeFilter<"Purchase"> | Date | string
    expiration_date?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    purchase_date?: SortOrder
    expiration_date?: SortOrderInput | SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    userId?: StringWithAggregatesFilter<"Purchase"> | string
    videoId?: StringWithAggregatesFilter<"Purchase"> | string
    purchase_date?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    expiration_date?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
  }

  export type ViewWhereInput = {
    AND?: ViewWhereInput | ViewWhereInput[]
    OR?: ViewWhereInput[]
    NOT?: ViewWhereInput | ViewWhereInput[]
    id?: StringFilter<"View"> | string
    userId?: StringFilter<"View"> | string
    profileId?: StringNullableFilter<"View"> | string | null
    videoId?: StringFilter<"View"> | string
    viewed_at?: DateTimeFilter<"View"> | Date | string
    progress_seconds?: IntFilter<"View"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profile?: XOR<SharedAccountUserNullableScalarRelationFilter, SharedAccountUserWhereInput> | null
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
  }

  export type ViewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrderInput | SortOrder
    videoId?: SortOrder
    viewed_at?: SortOrder
    progress_seconds?: SortOrder
    user?: UserOrderByWithRelationInput
    profile?: SharedAccountUserOrderByWithRelationInput
    video?: VideoFileOrderByWithRelationInput
  }

  export type ViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViewWhereInput | ViewWhereInput[]
    OR?: ViewWhereInput[]
    NOT?: ViewWhereInput | ViewWhereInput[]
    userId?: StringFilter<"View"> | string
    profileId?: StringNullableFilter<"View"> | string | null
    videoId?: StringFilter<"View"> | string
    viewed_at?: DateTimeFilter<"View"> | Date | string
    progress_seconds?: IntFilter<"View"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profile?: XOR<SharedAccountUserNullableScalarRelationFilter, SharedAccountUserWhereInput> | null
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
  }, "id">

  export type ViewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrderInput | SortOrder
    videoId?: SortOrder
    viewed_at?: SortOrder
    progress_seconds?: SortOrder
    _count?: ViewCountOrderByAggregateInput
    _avg?: ViewAvgOrderByAggregateInput
    _max?: ViewMaxOrderByAggregateInput
    _min?: ViewMinOrderByAggregateInput
    _sum?: ViewSumOrderByAggregateInput
  }

  export type ViewScalarWhereWithAggregatesInput = {
    AND?: ViewScalarWhereWithAggregatesInput | ViewScalarWhereWithAggregatesInput[]
    OR?: ViewScalarWhereWithAggregatesInput[]
    NOT?: ViewScalarWhereWithAggregatesInput | ViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"View"> | string
    userId?: StringWithAggregatesFilter<"View"> | string
    profileId?: StringNullableWithAggregatesFilter<"View"> | string | null
    videoId?: StringWithAggregatesFilter<"View"> | string
    viewed_at?: DateTimeWithAggregatesFilter<"View"> | Date | string
    progress_seconds?: IntWithAggregatesFilter<"View"> | number
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    videoId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    video?: VideoFileOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userId?: StringFilter<"Comment"> | string
    videoId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    video?: XOR<VideoFileScalarRelationFilter, VideoFileWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    videoId?: StringWithAggregatesFilter<"Comment"> | string
    text?: StringWithAggregatesFilter<"Comment"> | string
    created_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    parentCommentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type AdWhereInput = {
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    id?: StringFilter<"Ad"> | string
    title?: StringFilter<"Ad"> | string
    image_url?: StringFilter<"Ad"> | string
    video_url?: StringNullableFilter<"Ad"> | string | null
    start_date?: DateTimeFilter<"Ad"> | Date | string
    end_date?: DateTimeFilter<"Ad"> | Date | string
    is_active?: BoolFilter<"Ad"> | boolean
    views?: AdViewListRelationFilter
  }

  export type AdOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    video_url?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    views?: AdViewOrderByRelationAggregateInput
  }

  export type AdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    title?: StringFilter<"Ad"> | string
    image_url?: StringFilter<"Ad"> | string
    video_url?: StringNullableFilter<"Ad"> | string | null
    start_date?: DateTimeFilter<"Ad"> | Date | string
    end_date?: DateTimeFilter<"Ad"> | Date | string
    is_active?: BoolFilter<"Ad"> | boolean
    views?: AdViewListRelationFilter
  }, "id">

  export type AdOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    video_url?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    _count?: AdCountOrderByAggregateInput
    _max?: AdMaxOrderByAggregateInput
    _min?: AdMinOrderByAggregateInput
  }

  export type AdScalarWhereWithAggregatesInput = {
    AND?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    OR?: AdScalarWhereWithAggregatesInput[]
    NOT?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ad"> | string
    title?: StringWithAggregatesFilter<"Ad"> | string
    image_url?: StringWithAggregatesFilter<"Ad"> | string
    video_url?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    start_date?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    is_active?: BoolWithAggregatesFilter<"Ad"> | boolean
  }

  export type AdViewWhereInput = {
    AND?: AdViewWhereInput | AdViewWhereInput[]
    OR?: AdViewWhereInput[]
    NOT?: AdViewWhereInput | AdViewWhereInput[]
    id?: StringFilter<"AdView"> | string
    adId?: StringFilter<"AdView"> | string
    userId?: StringNullableFilter<"AdView"> | string | null
    profileId?: StringNullableFilter<"AdView"> | string | null
    viewed_at?: DateTimeFilter<"AdView"> | Date | string
    ad?: XOR<AdScalarRelationFilter, AdWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    profile?: XOR<SharedAccountUserNullableScalarRelationFilter, SharedAccountUserWhereInput> | null
  }

  export type AdViewOrderByWithRelationInput = {
    id?: SortOrder
    adId?: SortOrder
    userId?: SortOrderInput | SortOrder
    profileId?: SortOrderInput | SortOrder
    viewed_at?: SortOrder
    ad?: AdOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    profile?: SharedAccountUserOrderByWithRelationInput
  }

  export type AdViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdViewWhereInput | AdViewWhereInput[]
    OR?: AdViewWhereInput[]
    NOT?: AdViewWhereInput | AdViewWhereInput[]
    adId?: StringFilter<"AdView"> | string
    userId?: StringNullableFilter<"AdView"> | string | null
    profileId?: StringNullableFilter<"AdView"> | string | null
    viewed_at?: DateTimeFilter<"AdView"> | Date | string
    ad?: XOR<AdScalarRelationFilter, AdWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    profile?: XOR<SharedAccountUserNullableScalarRelationFilter, SharedAccountUserWhereInput> | null
  }, "id">

  export type AdViewOrderByWithAggregationInput = {
    id?: SortOrder
    adId?: SortOrder
    userId?: SortOrderInput | SortOrder
    profileId?: SortOrderInput | SortOrder
    viewed_at?: SortOrder
    _count?: AdViewCountOrderByAggregateInput
    _max?: AdViewMaxOrderByAggregateInput
    _min?: AdViewMinOrderByAggregateInput
  }

  export type AdViewScalarWhereWithAggregatesInput = {
    AND?: AdViewScalarWhereWithAggregatesInput | AdViewScalarWhereWithAggregatesInput[]
    OR?: AdViewScalarWhereWithAggregatesInput[]
    NOT?: AdViewScalarWhereWithAggregatesInput | AdViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdView"> | string
    adId?: StringWithAggregatesFilter<"AdView"> | string
    userId?: StringNullableWithAggregatesFilter<"AdView"> | string | null
    profileId?: StringNullableWithAggregatesFilter<"AdView"> | string | null
    viewed_at?: DateTimeWithAggregatesFilter<"AdView"> | Date | string
  }

  export type SharedProfileActivityWhereInput = {
    AND?: SharedProfileActivityWhereInput | SharedProfileActivityWhereInput[]
    OR?: SharedProfileActivityWhereInput[]
    NOT?: SharedProfileActivityWhereInput | SharedProfileActivityWhereInput[]
    id?: StringFilter<"SharedProfileActivity"> | string
    profileId?: StringFilter<"SharedProfileActivity"> | string
    action?: EnumProfileActivityActionFilter<"SharedProfileActivity"> | $Enums.ProfileActivityAction
    details?: JsonNullableFilter<"SharedProfileActivity">
    performed_at?: DateTimeFilter<"SharedProfileActivity"> | Date | string
    profile?: XOR<SharedAccountUserScalarRelationFilter, SharedAccountUserWhereInput>
  }

  export type SharedProfileActivityOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performed_at?: SortOrder
    profile?: SharedAccountUserOrderByWithRelationInput
  }

  export type SharedProfileActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharedProfileActivityWhereInput | SharedProfileActivityWhereInput[]
    OR?: SharedProfileActivityWhereInput[]
    NOT?: SharedProfileActivityWhereInput | SharedProfileActivityWhereInput[]
    profileId?: StringFilter<"SharedProfileActivity"> | string
    action?: EnumProfileActivityActionFilter<"SharedProfileActivity"> | $Enums.ProfileActivityAction
    details?: JsonNullableFilter<"SharedProfileActivity">
    performed_at?: DateTimeFilter<"SharedProfileActivity"> | Date | string
    profile?: XOR<SharedAccountUserScalarRelationFilter, SharedAccountUserWhereInput>
  }, "id">

  export type SharedProfileActivityOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    performed_at?: SortOrder
    _count?: SharedProfileActivityCountOrderByAggregateInput
    _max?: SharedProfileActivityMaxOrderByAggregateInput
    _min?: SharedProfileActivityMinOrderByAggregateInput
  }

  export type SharedProfileActivityScalarWhereWithAggregatesInput = {
    AND?: SharedProfileActivityScalarWhereWithAggregatesInput | SharedProfileActivityScalarWhereWithAggregatesInput[]
    OR?: SharedProfileActivityScalarWhereWithAggregatesInput[]
    NOT?: SharedProfileActivityScalarWhereWithAggregatesInput | SharedProfileActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedProfileActivity"> | string
    profileId?: StringWithAggregatesFilter<"SharedProfileActivity"> | string
    action?: EnumProfileActivityActionWithAggregatesFilter<"SharedProfileActivity"> | $Enums.ProfileActivityAction
    details?: JsonNullableWithAggregatesFilter<"SharedProfileActivity">
    performed_at?: DateTimeWithAggregatesFilter<"SharedProfileActivity"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type SessionCreateInput = {
    id?: string
    refreshToken: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshToken: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshToken: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    price: number
    maxSharedAccounts?: number
    videoQuality: $Enums.VideoQuality
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    maxSharedAccounts?: number
    videoQuality: $Enums.VideoQuality
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxSharedAccounts?: IntFieldUpdateOperationsInput | number
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxSharedAccounts?: IntFieldUpdateOperationsInput | number
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    price: number
    maxSharedAccounts?: number
    videoQuality: $Enums.VideoQuality
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxSharedAccounts?: IntFieldUpdateOperationsInput | number
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxSharedAccounts?: IntFieldUpdateOperationsInput | number
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
  }

  export type SubscriptionCreateInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    sharedAccounts?: SharedAccountCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    sharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    sharedAccounts?: SharedAccountUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    sharedAccounts?: SharedAccountUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
  }

  export type SharedAccountCreateInput = {
    id?: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    owner: UserCreateNestedOneWithoutOwnedSharedAccountsInput
    sharedUser?: UserCreateNestedOneWithoutSharedAccountInput
    subscription: SubscriptionCreateNestedOneWithoutSharedAccountsInput
    profiles?: SharedAccountUserCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountUncheckedCreateInput = {
    id?: string
    ownerUserId: string
    sharedUserId?: string | null
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    profiles?: SharedAccountUserUncheckedCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneRequiredWithoutOwnedSharedAccountsNestedInput
    sharedUser?: UserUpdateOneWithoutSharedAccountNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSharedAccountsNestedInput
    profiles?: SharedAccountUserUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    profiles?: SharedAccountUserUncheckedUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountCreateManyInput = {
    id?: string
    ownerUserId: string
    sharedUserId?: string | null
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
  }

  export type SharedAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SharedAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SharedAccountUserCreateInput = {
    id?: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    sharedAccount: SharedAccountCreateNestedOneWithoutProfilesInput
    user: UserCreateNestedOneWithoutSharedProfilesInput
    views?: ViewCreateNestedManyWithoutProfileInput
    adViews?: AdViewCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUncheckedCreateInput = {
    id?: string
    sharedAccountId: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    views?: ViewUncheckedCreateNestedManyWithoutProfileInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityUncheckedCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedAccount?: SharedAccountUpdateOneRequiredWithoutProfilesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedProfilesNestedInput
    views?: ViewUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ViewUncheckedUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserCreateManyInput = {
    id?: string
    sharedAccountId: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
  }

  export type SharedAccountUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAccountUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMetadataCreateInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataCreateManyInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
  }

  export type VideoMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VideoMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VideoFileCreateInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoInput
    purchases?: PurchaseCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    views?: ViewCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieUncheckedCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    views?: ViewUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    views?: ViewUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUncheckedUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    views?: ViewUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileCreateManyInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
  }

  export type VideoFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoGenreCreateInput = {
    id?: string
    name: string
    videos?: VideoMetadataCreateNestedManyWithoutGenresInput
  }

  export type VideoGenreUncheckedCreateInput = {
    id?: string
    name: string
    videos?: VideoMetadataUncheckedCreateNestedManyWithoutGenresInput
  }

  export type VideoGenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    videos?: VideoMetadataUpdateManyWithoutGenresNestedInput
  }

  export type VideoGenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    videos?: VideoMetadataUncheckedUpdateManyWithoutGenresNestedInput
  }

  export type VideoGenreCreateManyInput = {
    id?: string
    name: string
  }

  export type VideoGenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoGenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorCreateInput = {
    id?: string
    name: string
    VideoActor?: VideoActorCreateNestedManyWithoutActorInput
  }

  export type ActorUncheckedCreateInput = {
    id?: string
    name: string
    VideoActor?: VideoActorUncheckedCreateNestedManyWithoutActorInput
  }

  export type ActorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    VideoActor?: VideoActorUpdateManyWithoutActorNestedInput
  }

  export type ActorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    VideoActor?: VideoActorUncheckedUpdateManyWithoutActorNestedInput
  }

  export type ActorCreateManyInput = {
    id?: string
    name: string
  }

  export type ActorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoActorCreateInput = {
    role?: string | null
    video: VideoMetadataCreateNestedOneWithoutActorsInput
    actor: ActorCreateNestedOneWithoutVideoActorInput
  }

  export type VideoActorUncheckedCreateInput = {
    videoId: string
    actorId: string
    role?: string | null
  }

  export type VideoActorUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    video?: VideoMetadataUpdateOneRequiredWithoutActorsNestedInput
    actor?: ActorUpdateOneRequiredWithoutVideoActorNestedInput
  }

  export type VideoActorUncheckedUpdateInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoActorCreateManyInput = {
    videoId: string
    actorId: string
    role?: string | null
  }

  export type VideoActorUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoActorUncheckedUpdateManyInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoLanguageCreateInput = {
    id?: string
    code: string
    name: string
    videos?: VideoMetadataCreateNestedManyWithoutLanguagesInput
  }

  export type VideoLanguageUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    videos?: VideoMetadataUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type VideoLanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    videos?: VideoMetadataUpdateManyWithoutLanguagesNestedInput
  }

  export type VideoLanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    videos?: VideoMetadataUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type VideoLanguageCreateManyInput = {
    id?: string
    code: string
    name: string
  }

  export type VideoLanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoLanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoFormatCreateInput = {
    id?: string
    format: string
    description?: string | null
    videos?: VideoMetadataCreateNestedManyWithoutFormatInput
  }

  export type VideoFormatUncheckedCreateInput = {
    id?: string
    format: string
    description?: string | null
    videos?: VideoMetadataUncheckedCreateNestedManyWithoutFormatInput
  }

  export type VideoFormatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VideoMetadataUpdateManyWithoutFormatNestedInput
  }

  export type VideoFormatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VideoMetadataUncheckedUpdateManyWithoutFormatNestedInput
  }

  export type VideoFormatCreateManyInput = {
    id?: string
    format: string
    description?: string | null
  }

  export type VideoFormatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoFormatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoCategoryCreateInput = {
    id?: string
    category: string
    description?: string | null
    videos?: VideoMetadataCreateNestedManyWithoutCategoryInput
  }

  export type VideoCategoryUncheckedCreateInput = {
    id?: string
    category: string
    description?: string | null
    videos?: VideoMetadataUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type VideoCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VideoMetadataUpdateManyWithoutCategoryNestedInput
  }

  export type VideoCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VideoMetadataUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type VideoCategoryCreateManyInput = {
    id?: string
    category: string
    description?: string | null
  }

  export type VideoCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovieCreateInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    metadata: VideoMetadataCreateNestedOneWithoutMovieInput
    videoFile: VideoFileCreateNestedOneWithoutMovieInput
    tags?: MovieTagCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateInput = {
    id?: string
    metadataId: string
    videoFileId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    tags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: VideoMetadataUpdateOneRequiredWithoutMovieNestedInput
    videoFile?: VideoFileUpdateOneRequiredWithoutMovieNestedInput
    tags?: MovieTagUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    videoFileId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateManyInput = {
    id?: string
    metadataId: string
    videoFileId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
  }

  export type MovieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MovieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    videoFileId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SeriesCreateInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    metadata: VideoMetadataCreateNestedOneWithoutSeriesInput
    seasons?: SeasonCreateNestedManyWithoutSeriesInput
    tags?: SeriesTagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateInput = {
    id?: string
    metadataId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    seasons?: SeasonUncheckedCreateNestedManyWithoutSeriesInput
    tags?: SeriesTagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: VideoMetadataUpdateOneRequiredWithoutSeriesNestedInput
    seasons?: SeasonUpdateManyWithoutSeriesNestedInput
    tags?: SeriesTagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    seasons?: SeasonUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: SeriesTagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesCreateManyInput = {
    id?: string
    metadataId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
  }

  export type SeriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SeriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SeasonCreateInput = {
    id?: string
    number: number
    series: SeriesCreateNestedOneWithoutSeasonsInput
    episodes?: EpisodeCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: string
    seriesId: string
    number: number
    episodes?: EpisodeUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    series?: SeriesUpdateOneRequiredWithoutSeasonsNestedInput
    episodes?: EpisodeUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    episodes?: EpisodeUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonCreateManyInput = {
    id?: string
    seriesId: string
    number: number
  }

  export type SeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type EpisodeCreateInput = {
    id?: string
    number: number
    season: SeasonCreateNestedOneWithoutEpisodesInput
    videoFile: VideoFileCreateNestedOneWithoutEpisodeInput
    metadata: VideoMetadataCreateNestedOneWithoutEpisodeInput
  }

  export type EpisodeUncheckedCreateInput = {
    id?: string
    seasonId: string
    number: number
    videoFileId: string
    metadataId: string
  }

  export type EpisodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneRequiredWithoutEpisodesNestedInput
    videoFile?: VideoFileUpdateOneRequiredWithoutEpisodeNestedInput
    metadata?: VideoMetadataUpdateOneRequiredWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    videoFileId?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
  }

  export type EpisodeCreateManyInput = {
    id?: string
    seasonId: string
    number: number
    videoFileId: string
    metadataId: string
  }

  export type EpisodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type EpisodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    videoFileId?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    movieTags?: MovieTagCreateNestedManyWithoutTagInput
    seriesTags?: SeriesTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutTagInput
    seriesTags?: SeriesTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    movieTags?: MovieTagUpdateManyWithoutTagNestedInput
    seriesTags?: SeriesTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    movieTags?: MovieTagUncheckedUpdateManyWithoutTagNestedInput
    seriesTags?: SeriesTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MovieTagCreateInput = {
    movie: MovieCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutMovieTagsInput
  }

  export type MovieTagUncheckedCreateInput = {
    movieId: string
    tagId: string
  }

  export type MovieTagUpdateInput = {
    movie?: MovieUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutMovieTagsNestedInput
  }

  export type MovieTagUncheckedUpdateInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieTagCreateManyInput = {
    movieId: string
    tagId: string
  }

  export type MovieTagUpdateManyMutationInput = {

  }

  export type MovieTagUncheckedUpdateManyInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTagCreateInput = {
    series: SeriesCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutSeriesTagsInput
  }

  export type SeriesTagUncheckedCreateInput = {
    seriesId: string
    tagId: string
  }

  export type SeriesTagUpdateInput = {
    series?: SeriesUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutSeriesTagsNestedInput
  }

  export type SeriesTagUncheckedUpdateInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTagCreateManyInput = {
    seriesId: string
    tagId: string
  }

  export type SeriesTagUpdateManyMutationInput = {

  }

  export type SeriesTagUncheckedUpdateManyInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type SubtitleCreateInput = {
    language: string
    subtitle_url: string
    video: VideoFileCreateNestedOneWithoutSubtitlesInput
    videoMetadata?: VideoMetadataCreateNestedOneWithoutSubtitlesInput
  }

  export type SubtitleUncheckedCreateInput = {
    videoId: string
    language: string
    subtitle_url: string
    videoMetadataId?: string | null
  }

  export type SubtitleUpdateInput = {
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    video?: VideoFileUpdateOneRequiredWithoutSubtitlesNestedInput
    videoMetadata?: VideoMetadataUpdateOneWithoutSubtitlesNestedInput
  }

  export type SubtitleUncheckedUpdateInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    videoMetadataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtitleCreateManyInput = {
    videoId: string
    language: string
    subtitle_url: string
    videoMetadataId?: string | null
  }

  export type SubtitleUpdateManyMutationInput = {
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
  }

  export type SubtitleUncheckedUpdateManyInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    videoMetadataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseCreateInput = {
    id?: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
    user: UserCreateNestedOneWithoutPurchasesInput
    video: VideoFileCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    userId: string
    videoId: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    video?: VideoFileUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseCreateManyInput = {
    id?: string
    userId: string
    videoId: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewCreateInput = {
    id?: string
    viewed_at?: Date | string
    progress_seconds?: number
    user: UserCreateNestedOneWithoutViewsInput
    profile?: SharedAccountUserCreateNestedOneWithoutViewsInput
    video: VideoFileCreateNestedOneWithoutViewsInput
  }

  export type ViewUncheckedCreateInput = {
    id?: string
    userId: string
    profileId?: string | null
    videoId: string
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type ViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutViewsNestedInput
    profile?: SharedAccountUserUpdateOneWithoutViewsNestedInput
    video?: VideoFileUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type ViewCreateManyInput = {
    id?: string
    userId: string
    profileId?: string | null
    videoId: string
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type ViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type ViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateInput = {
    id?: string
    text: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    video: VideoFileCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    userId: string
    videoId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    video?: VideoFileUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    userId: string
    videoId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdCreateInput = {
    id?: string
    title: string
    image_url: string
    video_url?: string | null
    start_date: Date | string
    end_date: Date | string
    is_active?: boolean
    views?: AdViewCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateInput = {
    id?: string
    title: string
    image_url: string
    video_url?: string | null
    start_date: Date | string
    end_date: Date | string
    is_active?: boolean
    views?: AdViewUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    views?: AdViewUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    views?: AdViewUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdCreateManyInput = {
    id?: string
    title: string
    image_url: string
    video_url?: string | null
    start_date: Date | string
    end_date: Date | string
    is_active?: boolean
  }

  export type AdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdViewCreateInput = {
    id?: string
    viewed_at?: Date | string
    ad: AdCreateNestedOneWithoutViewsInput
    user?: UserCreateNestedOneWithoutAdViewsInput
    profile?: SharedAccountUserCreateNestedOneWithoutAdViewsInput
  }

  export type AdViewUncheckedCreateInput = {
    id?: string
    adId: string
    userId?: string | null
    profileId?: string | null
    viewed_at?: Date | string
  }

  export type AdViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ad?: AdUpdateOneRequiredWithoutViewsNestedInput
    user?: UserUpdateOneWithoutAdViewsNestedInput
    profile?: SharedAccountUserUpdateOneWithoutAdViewsNestedInput
  }

  export type AdViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdViewCreateManyInput = {
    id?: string
    adId: string
    userId?: string | null
    profileId?: string | null
    viewed_at?: Date | string
  }

  export type AdViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProfileActivityCreateInput = {
    id?: string
    action: $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: Date | string
    profile: SharedAccountUserCreateNestedOneWithoutActivitiesInput
  }

  export type SharedProfileActivityUncheckedCreateInput = {
    id?: string
    profileId: string
    action: $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: Date | string
  }

  export type SharedProfileActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: SharedAccountUserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type SharedProfileActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProfileActivityCreateManyInput = {
    id?: string
    profileId: string
    action: $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: Date | string
  }

  export type SharedProfileActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProfileActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SharedAccountListRelationFilter = {
    every?: SharedAccountWhereInput
    some?: SharedAccountWhereInput
    none?: SharedAccountWhereInput
  }

  export type SharedAccountUserListRelationFilter = {
    every?: SharedAccountUserWhereInput
    some?: SharedAccountUserWhereInput
    none?: SharedAccountUserWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type ViewListRelationFilter = {
    every?: ViewWhereInput
    some?: ViewWhereInput
    none?: ViewWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type AdViewListRelationFilter = {
    every?: AdViewWhereInput
    some?: AdViewWhereInput
    none?: AdViewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedAccountUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    isVerified?: SortOrder
    isMainAccount?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    isVerified?: SortOrder
    isMainAccount?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    isVerified?: SortOrder
    isMainAccount?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumVideoQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityFilter<$PrismaModel> | $Enums.VideoQuality
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    maxSharedAccounts?: SortOrder
    videoQuality?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    maxSharedAccounts?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    maxSharedAccounts?: SortOrder
    videoQuality?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    maxSharedAccounts?: SortOrder
    videoQuality?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
    maxSharedAccounts?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVideoQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityWithAggregatesFilter<$PrismaModel> | $Enums.VideoQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoQualityFilter<$PrismaModel>
    _max?: NestedEnumVideoQualityFilter<$PrismaModel>
  }

  export type EnumRenewalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalStatus | EnumRenewalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalStatusFilter<$PrismaModel> | $Enums.RenewalStatus
  }

  export type SubscriptionPlanScalarRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    renewal_status?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    renewal_status?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    renewal_status?: SortOrder
  }

  export type EnumRenewalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalStatus | EnumRenewalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalStatusWithAggregatesFilter<$PrismaModel> | $Enums.RenewalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRenewalStatusFilter<$PrismaModel>
    _max?: NestedEnumRenewalStatusFilter<$PrismaModel>
  }

  export type EnumSharedAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SharedAccountStatus | EnumSharedAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSharedAccountStatusFilter<$PrismaModel> | $Enums.SharedAccountStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type SharedAccountCountOrderByAggregateInput = {
    id?: SortOrder
    ownerUserId?: SortOrder
    sharedUserId?: SortOrder
    subscriptionId?: SortOrder
    shared_on?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
  }

  export type SharedAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerUserId?: SortOrder
    sharedUserId?: SortOrder
    subscriptionId?: SortOrder
    shared_on?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
  }

  export type SharedAccountMinOrderByAggregateInput = {
    id?: SortOrder
    ownerUserId?: SortOrder
    sharedUserId?: SortOrder
    subscriptionId?: SortOrder
    shared_on?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
  }

  export type EnumSharedAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SharedAccountStatus | EnumSharedAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSharedAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.SharedAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSharedAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumSharedAccountStatusFilter<$PrismaModel>
  }

  export type SharedAccountScalarRelationFilter = {
    is?: SharedAccountWhereInput
    isNot?: SharedAccountWhereInput
  }

  export type SharedProfileActivityListRelationFilter = {
    every?: SharedProfileActivityWhereInput
    some?: SharedProfileActivityWhereInput
    none?: SharedProfileActivityWhereInput
  }

  export type SharedProfileActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedAccountUserSharedAccountIdProfile_nameCompoundUniqueInput = {
    sharedAccountId: string
    profile_name: string
  }

  export type SharedAccountUserCountOrderByAggregateInput = {
    id?: SortOrder
    sharedAccountId?: SortOrder
    userId?: SortOrder
    profile_name?: SortOrder
    is_kid_profile?: SortOrder
    avatar_url?: SortOrder
    pin_code?: SortOrder
    created_at?: SortOrder
  }

  export type SharedAccountUserMaxOrderByAggregateInput = {
    id?: SortOrder
    sharedAccountId?: SortOrder
    userId?: SortOrder
    profile_name?: SortOrder
    is_kid_profile?: SortOrder
    avatar_url?: SortOrder
    pin_code?: SortOrder
    created_at?: SortOrder
  }

  export type SharedAccountUserMinOrderByAggregateInput = {
    id?: SortOrder
    sharedAccountId?: SortOrder
    userId?: SortOrder
    profile_name?: SortOrder
    is_kid_profile?: SortOrder
    avatar_url?: SortOrder
    pin_code?: SortOrder
    created_at?: SortOrder
  }

  export type VideoFormatScalarRelationFilter = {
    is?: VideoFormatWhereInput
    isNot?: VideoFormatWhereInput
  }

  export type VideoCategoryScalarRelationFilter = {
    is?: VideoCategoryWhereInput
    isNot?: VideoCategoryWhereInput
  }

  export type MovieNullableScalarRelationFilter = {
    is?: MovieWhereInput | null
    isNot?: MovieWhereInput | null
  }

  export type EpisodeNullableScalarRelationFilter = {
    is?: EpisodeWhereInput | null
    isNot?: EpisodeWhereInput | null
  }

  export type SeriesNullableScalarRelationFilter = {
    is?: SeriesWhereInput | null
    isNot?: SeriesWhereInput | null
  }

  export type VideoGenreListRelationFilter = {
    every?: VideoGenreWhereInput
    some?: VideoGenreWhereInput
    none?: VideoGenreWhereInput
  }

  export type VideoActorListRelationFilter = {
    every?: VideoActorWhereInput
    some?: VideoActorWhereInput
    none?: VideoActorWhereInput
  }

  export type SubtitleListRelationFilter = {
    every?: SubtitleWhereInput
    some?: SubtitleWhereInput
    none?: SubtitleWhereInput
  }

  export type VideoLanguageListRelationFilter = {
    every?: VideoLanguageWhereInput
    some?: VideoLanguageWhereInput
    none?: VideoLanguageWhereInput
  }

  export type VideoGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoActorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    secondaryImage?: SortOrder
    releaseDate?: SortOrder
    platformDate?: SortOrder
    ageRating?: SortOrder
    productionHouse?: SortOrder
    productionCountry?: SortOrder
    director?: SortOrder
    formatId?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
  }

  export type VideoMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    secondaryImage?: SortOrder
    releaseDate?: SortOrder
    platformDate?: SortOrder
    ageRating?: SortOrder
    productionHouse?: SortOrder
    productionCountry?: SortOrder
    director?: SortOrder
    formatId?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
  }

  export type VideoMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    secondaryImage?: SortOrder
    releaseDate?: SortOrder
    platformDate?: SortOrder
    ageRating?: SortOrder
    productionHouse?: SortOrder
    productionCountry?: SortOrder
    director?: SortOrder
    formatId?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VideoFileCountOrderByAggregateInput = {
    id?: SortOrder
    filePath?: SortOrder
    trailerPath?: SortOrder
    duration?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type VideoFileAvgOrderByAggregateInput = {
    duration?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type VideoFileMaxOrderByAggregateInput = {
    id?: SortOrder
    filePath?: SortOrder
    trailerPath?: SortOrder
    duration?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type VideoFileMinOrderByAggregateInput = {
    id?: SortOrder
    filePath?: SortOrder
    trailerPath?: SortOrder
    duration?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type VideoFileSumOrderByAggregateInput = {
    duration?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type VideoMetadataListRelationFilter = {
    every?: VideoMetadataWhereInput
    some?: VideoMetadataWhereInput
    none?: VideoMetadataWhereInput
  }

  export type VideoMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoGenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VideoGenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VideoGenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VideoMetadataScalarRelationFilter = {
    is?: VideoMetadataWhereInput
    isNot?: VideoMetadataWhereInput
  }

  export type ActorScalarRelationFilter = {
    is?: ActorWhereInput
    isNot?: ActorWhereInput
  }

  export type VideoActorVideoIdActorIdCompoundUniqueInput = {
    videoId: string
    actorId: string
  }

  export type VideoActorCountOrderByAggregateInput = {
    videoId?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
  }

  export type VideoActorMaxOrderByAggregateInput = {
    videoId?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
  }

  export type VideoActorMinOrderByAggregateInput = {
    videoId?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
  }

  export type VideoLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type VideoLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type VideoLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type VideoFormatCountOrderByAggregateInput = {
    id?: SortOrder
    format?: SortOrder
    description?: SortOrder
  }

  export type VideoFormatMaxOrderByAggregateInput = {
    id?: SortOrder
    format?: SortOrder
    description?: SortOrder
  }

  export type VideoFormatMinOrderByAggregateInput = {
    id?: SortOrder
    format?: SortOrder
    description?: SortOrder
  }

  export type VideoCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    description?: SortOrder
  }

  export type VideoCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    description?: SortOrder
  }

  export type VideoCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    description?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VideoFileScalarRelationFilter = {
    is?: VideoFileWhereInput
    isNot?: VideoFileWhereInput
  }

  export type MovieTagListRelationFilter = {
    every?: MovieTagWhereInput
    some?: MovieTagWhereInput
    none?: MovieTagWhereInput
  }

  export type MovieTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCountOrderByAggregateInput = {
    id?: SortOrder
    metadataId?: SortOrder
    videoFileId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type MovieAvgOrderByAggregateInput = {
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type MovieMaxOrderByAggregateInput = {
    id?: SortOrder
    metadataId?: SortOrder
    videoFileId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type MovieMinOrderByAggregateInput = {
    id?: SortOrder
    metadataId?: SortOrder
    videoFileId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type MovieSumOrderByAggregateInput = {
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SeasonListRelationFilter = {
    every?: SeasonWhereInput
    some?: SeasonWhereInput
    none?: SeasonWhereInput
  }

  export type SeriesTagListRelationFilter = {
    every?: SeriesTagWhereInput
    some?: SeriesTagWhereInput
    none?: SeriesTagWhereInput
  }

  export type SeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeriesTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeriesCountOrderByAggregateInput = {
    id?: SortOrder
    metadataId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type SeriesAvgOrderByAggregateInput = {
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type SeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    metadataId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type SeriesMinOrderByAggregateInput = {
    id?: SortOrder
    metadataId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type SeriesSumOrderByAggregateInput = {
    seasonCount?: SortOrder
    rentalPrice?: SortOrder
  }

  export type SeriesScalarRelationFilter = {
    is?: SeriesWhereInput
    isNot?: SeriesWhereInput
  }

  export type EpisodeListRelationFilter = {
    every?: EpisodeWhereInput
    some?: EpisodeWhereInput
    none?: EpisodeWhereInput
  }

  export type EpisodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonSeriesIdNumberCompoundUniqueInput = {
    seriesId: string
    number: number
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type SeasonScalarRelationFilter = {
    is?: SeasonWhereInput
    isNot?: SeasonWhereInput
  }

  export type EpisodeSeasonIdNumberCompoundUniqueInput = {
    seasonId: string
    number: number
  }

  export type EpisodeCountOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    videoFileId?: SortOrder
    metadataId?: SortOrder
  }

  export type EpisodeAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type EpisodeMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    videoFileId?: SortOrder
    metadataId?: SortOrder
  }

  export type EpisodeMinOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    videoFileId?: SortOrder
    metadataId?: SortOrder
  }

  export type EpisodeSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MovieScalarRelationFilter = {
    is?: MovieWhereInput
    isNot?: MovieWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type MovieTagMovieIdTagIdCompoundUniqueInput = {
    movieId: string
    tagId: string
  }

  export type MovieTagCountOrderByAggregateInput = {
    movieId?: SortOrder
    tagId?: SortOrder
  }

  export type MovieTagMaxOrderByAggregateInput = {
    movieId?: SortOrder
    tagId?: SortOrder
  }

  export type MovieTagMinOrderByAggregateInput = {
    movieId?: SortOrder
    tagId?: SortOrder
  }

  export type SeriesTagSeriesIdTagIdCompoundUniqueInput = {
    seriesId: string
    tagId: string
  }

  export type SeriesTagCountOrderByAggregateInput = {
    seriesId?: SortOrder
    tagId?: SortOrder
  }

  export type SeriesTagMaxOrderByAggregateInput = {
    seriesId?: SortOrder
    tagId?: SortOrder
  }

  export type SeriesTagMinOrderByAggregateInput = {
    seriesId?: SortOrder
    tagId?: SortOrder
  }

  export type VideoMetadataNullableScalarRelationFilter = {
    is?: VideoMetadataWhereInput | null
    isNot?: VideoMetadataWhereInput | null
  }

  export type SubtitleVideoIdLanguageCompoundUniqueInput = {
    videoId: string
    language: string
  }

  export type SubtitleCountOrderByAggregateInput = {
    videoId?: SortOrder
    language?: SortOrder
    subtitle_url?: SortOrder
    videoMetadataId?: SortOrder
  }

  export type SubtitleMaxOrderByAggregateInput = {
    videoId?: SortOrder
    language?: SortOrder
    subtitle_url?: SortOrder
    videoMetadataId?: SortOrder
  }

  export type SubtitleMinOrderByAggregateInput = {
    videoId?: SortOrder
    language?: SortOrder
    subtitle_url?: SortOrder
    videoMetadataId?: SortOrder
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    purchase_date?: SortOrder
    expiration_date?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    purchase_date?: SortOrder
    expiration_date?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    purchase_date?: SortOrder
    expiration_date?: SortOrder
  }

  export type SharedAccountUserNullableScalarRelationFilter = {
    is?: SharedAccountUserWhereInput | null
    isNot?: SharedAccountUserWhereInput | null
  }

  export type ViewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    videoId?: SortOrder
    viewed_at?: SortOrder
    progress_seconds?: SortOrder
  }

  export type ViewAvgOrderByAggregateInput = {
    progress_seconds?: SortOrder
  }

  export type ViewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    videoId?: SortOrder
    viewed_at?: SortOrder
    progress_seconds?: SortOrder
  }

  export type ViewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    videoId?: SortOrder
    viewed_at?: SortOrder
    progress_seconds?: SortOrder
  }

  export type ViewSumOrderByAggregateInput = {
    progress_seconds?: SortOrder
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    parentCommentId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    parentCommentId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    parentCommentId?: SortOrder
  }

  export type AdCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    video_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
  }

  export type AdMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    video_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
  }

  export type AdMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    video_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
  }

  export type AdScalarRelationFilter = {
    is?: AdWhereInput
    isNot?: AdWhereInput
  }

  export type AdViewCountOrderByAggregateInput = {
    id?: SortOrder
    adId?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    viewed_at?: SortOrder
  }

  export type AdViewMaxOrderByAggregateInput = {
    id?: SortOrder
    adId?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    viewed_at?: SortOrder
  }

  export type AdViewMinOrderByAggregateInput = {
    id?: SortOrder
    adId?: SortOrder
    userId?: SortOrder
    profileId?: SortOrder
    viewed_at?: SortOrder
  }

  export type EnumProfileActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileActivityAction | EnumProfileActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileActivityActionFilter<$PrismaModel> | $Enums.ProfileActivityAction
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SharedAccountUserScalarRelationFilter = {
    is?: SharedAccountUserWhereInput
    isNot?: SharedAccountUserWhereInput
  }

  export type SharedProfileActivityCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    performed_at?: SortOrder
  }

  export type SharedProfileActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    action?: SortOrder
    performed_at?: SortOrder
  }

  export type SharedProfileActivityMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    action?: SortOrder
    performed_at?: SortOrder
  }

  export type EnumProfileActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileActivityAction | EnumProfileActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.ProfileActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileActivityActionFilter<$PrismaModel>
    _max?: NestedEnumProfileActivityActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SharedAccountCreateNestedManyWithoutOwnerInput = {
    create?: XOR<SharedAccountCreateWithoutOwnerInput, SharedAccountUncheckedCreateWithoutOwnerInput> | SharedAccountCreateWithoutOwnerInput[] | SharedAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutOwnerInput | SharedAccountCreateOrConnectWithoutOwnerInput[]
    createMany?: SharedAccountCreateManyOwnerInputEnvelope
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
  }

  export type SharedAccountUserCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedAccountUserCreateWithoutUserInput, SharedAccountUserUncheckedCreateWithoutUserInput> | SharedAccountUserCreateWithoutUserInput[] | SharedAccountUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutUserInput | SharedAccountUserCreateOrConnectWithoutUserInput[]
    createMany?: SharedAccountUserCreateManyUserInputEnvelope
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type ViewCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewCreateWithoutUserInput, ViewUncheckedCreateWithoutUserInput> | ViewCreateWithoutUserInput[] | ViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutUserInput | ViewCreateOrConnectWithoutUserInput[]
    createMany?: ViewCreateManyUserInputEnvelope
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SharedAccountCreateNestedManyWithoutSharedUserInput = {
    create?: XOR<SharedAccountCreateWithoutSharedUserInput, SharedAccountUncheckedCreateWithoutSharedUserInput> | SharedAccountCreateWithoutSharedUserInput[] | SharedAccountUncheckedCreateWithoutSharedUserInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSharedUserInput | SharedAccountCreateOrConnectWithoutSharedUserInput[]
    createMany?: SharedAccountCreateManySharedUserInputEnvelope
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
  }

  export type AdViewCreateNestedManyWithoutUserInput = {
    create?: XOR<AdViewCreateWithoutUserInput, AdViewUncheckedCreateWithoutUserInput> | AdViewCreateWithoutUserInput[] | AdViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutUserInput | AdViewCreateOrConnectWithoutUserInput[]
    createMany?: AdViewCreateManyUserInputEnvelope
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SharedAccountUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<SharedAccountCreateWithoutOwnerInput, SharedAccountUncheckedCreateWithoutOwnerInput> | SharedAccountCreateWithoutOwnerInput[] | SharedAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutOwnerInput | SharedAccountCreateOrConnectWithoutOwnerInput[]
    createMany?: SharedAccountCreateManyOwnerInputEnvelope
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
  }

  export type SharedAccountUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedAccountUserCreateWithoutUserInput, SharedAccountUserUncheckedCreateWithoutUserInput> | SharedAccountUserCreateWithoutUserInput[] | SharedAccountUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutUserInput | SharedAccountUserCreateOrConnectWithoutUserInput[]
    createMany?: SharedAccountUserCreateManyUserInputEnvelope
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type ViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewCreateWithoutUserInput, ViewUncheckedCreateWithoutUserInput> | ViewCreateWithoutUserInput[] | ViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutUserInput | ViewCreateOrConnectWithoutUserInput[]
    createMany?: ViewCreateManyUserInputEnvelope
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput = {
    create?: XOR<SharedAccountCreateWithoutSharedUserInput, SharedAccountUncheckedCreateWithoutSharedUserInput> | SharedAccountCreateWithoutSharedUserInput[] | SharedAccountUncheckedCreateWithoutSharedUserInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSharedUserInput | SharedAccountCreateOrConnectWithoutSharedUserInput[]
    createMany?: SharedAccountCreateManySharedUserInputEnvelope
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
  }

  export type AdViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdViewCreateWithoutUserInput, AdViewUncheckedCreateWithoutUserInput> | AdViewCreateWithoutUserInput[] | AdViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutUserInput | AdViewCreateOrConnectWithoutUserInput[]
    createMany?: AdViewCreateManyUserInputEnvelope
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SharedAccountUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<SharedAccountCreateWithoutOwnerInput, SharedAccountUncheckedCreateWithoutOwnerInput> | SharedAccountCreateWithoutOwnerInput[] | SharedAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutOwnerInput | SharedAccountCreateOrConnectWithoutOwnerInput[]
    upsert?: SharedAccountUpsertWithWhereUniqueWithoutOwnerInput | SharedAccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: SharedAccountCreateManyOwnerInputEnvelope
    set?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    disconnect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    delete?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    update?: SharedAccountUpdateWithWhereUniqueWithoutOwnerInput | SharedAccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: SharedAccountUpdateManyWithWhereWithoutOwnerInput | SharedAccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
  }

  export type SharedAccountUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutUserInput, SharedAccountUserUncheckedCreateWithoutUserInput> | SharedAccountUserCreateWithoutUserInput[] | SharedAccountUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutUserInput | SharedAccountUserCreateOrConnectWithoutUserInput[]
    upsert?: SharedAccountUserUpsertWithWhereUniqueWithoutUserInput | SharedAccountUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedAccountUserCreateManyUserInputEnvelope
    set?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    disconnect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    delete?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    update?: SharedAccountUserUpdateWithWhereUniqueWithoutUserInput | SharedAccountUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedAccountUserUpdateManyWithWhereWithoutUserInput | SharedAccountUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedAccountUserScalarWhereInput | SharedAccountUserScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewCreateWithoutUserInput, ViewUncheckedCreateWithoutUserInput> | ViewCreateWithoutUserInput[] | ViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutUserInput | ViewCreateOrConnectWithoutUserInput[]
    upsert?: ViewUpsertWithWhereUniqueWithoutUserInput | ViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewCreateManyUserInputEnvelope
    set?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    disconnect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    delete?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    update?: ViewUpdateWithWhereUniqueWithoutUserInput | ViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewUpdateManyWithWhereWithoutUserInput | ViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewScalarWhereInput | ViewScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SharedAccountUpdateManyWithoutSharedUserNestedInput = {
    create?: XOR<SharedAccountCreateWithoutSharedUserInput, SharedAccountUncheckedCreateWithoutSharedUserInput> | SharedAccountCreateWithoutSharedUserInput[] | SharedAccountUncheckedCreateWithoutSharedUserInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSharedUserInput | SharedAccountCreateOrConnectWithoutSharedUserInput[]
    upsert?: SharedAccountUpsertWithWhereUniqueWithoutSharedUserInput | SharedAccountUpsertWithWhereUniqueWithoutSharedUserInput[]
    createMany?: SharedAccountCreateManySharedUserInputEnvelope
    set?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    disconnect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    delete?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    update?: SharedAccountUpdateWithWhereUniqueWithoutSharedUserInput | SharedAccountUpdateWithWhereUniqueWithoutSharedUserInput[]
    updateMany?: SharedAccountUpdateManyWithWhereWithoutSharedUserInput | SharedAccountUpdateManyWithWhereWithoutSharedUserInput[]
    deleteMany?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
  }

  export type AdViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdViewCreateWithoutUserInput, AdViewUncheckedCreateWithoutUserInput> | AdViewCreateWithoutUserInput[] | AdViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutUserInput | AdViewCreateOrConnectWithoutUserInput[]
    upsert?: AdViewUpsertWithWhereUniqueWithoutUserInput | AdViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdViewCreateManyUserInputEnvelope
    set?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    disconnect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    delete?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    update?: AdViewUpdateWithWhereUniqueWithoutUserInput | AdViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdViewUpdateManyWithWhereWithoutUserInput | AdViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<SharedAccountCreateWithoutOwnerInput, SharedAccountUncheckedCreateWithoutOwnerInput> | SharedAccountCreateWithoutOwnerInput[] | SharedAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutOwnerInput | SharedAccountCreateOrConnectWithoutOwnerInput[]
    upsert?: SharedAccountUpsertWithWhereUniqueWithoutOwnerInput | SharedAccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: SharedAccountCreateManyOwnerInputEnvelope
    set?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    disconnect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    delete?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    update?: SharedAccountUpdateWithWhereUniqueWithoutOwnerInput | SharedAccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: SharedAccountUpdateManyWithWhereWithoutOwnerInput | SharedAccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
  }

  export type SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutUserInput, SharedAccountUserUncheckedCreateWithoutUserInput> | SharedAccountUserCreateWithoutUserInput[] | SharedAccountUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutUserInput | SharedAccountUserCreateOrConnectWithoutUserInput[]
    upsert?: SharedAccountUserUpsertWithWhereUniqueWithoutUserInput | SharedAccountUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedAccountUserCreateManyUserInputEnvelope
    set?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    disconnect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    delete?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    update?: SharedAccountUserUpdateWithWhereUniqueWithoutUserInput | SharedAccountUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedAccountUserUpdateManyWithWhereWithoutUserInput | SharedAccountUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedAccountUserScalarWhereInput | SharedAccountUserScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewCreateWithoutUserInput, ViewUncheckedCreateWithoutUserInput> | ViewCreateWithoutUserInput[] | ViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutUserInput | ViewCreateOrConnectWithoutUserInput[]
    upsert?: ViewUpsertWithWhereUniqueWithoutUserInput | ViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewCreateManyUserInputEnvelope
    set?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    disconnect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    delete?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    update?: ViewUpdateWithWhereUniqueWithoutUserInput | ViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewUpdateManyWithWhereWithoutUserInput | ViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewScalarWhereInput | ViewScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput = {
    create?: XOR<SharedAccountCreateWithoutSharedUserInput, SharedAccountUncheckedCreateWithoutSharedUserInput> | SharedAccountCreateWithoutSharedUserInput[] | SharedAccountUncheckedCreateWithoutSharedUserInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSharedUserInput | SharedAccountCreateOrConnectWithoutSharedUserInput[]
    upsert?: SharedAccountUpsertWithWhereUniqueWithoutSharedUserInput | SharedAccountUpsertWithWhereUniqueWithoutSharedUserInput[]
    createMany?: SharedAccountCreateManySharedUserInputEnvelope
    set?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    disconnect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    delete?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    update?: SharedAccountUpdateWithWhereUniqueWithoutSharedUserInput | SharedAccountUpdateWithWhereUniqueWithoutSharedUserInput[]
    updateMany?: SharedAccountUpdateManyWithWhereWithoutSharedUserInput | SharedAccountUpdateManyWithWhereWithoutSharedUserInput[]
    deleteMany?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
  }

  export type AdViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdViewCreateWithoutUserInput, AdViewUncheckedCreateWithoutUserInput> | AdViewCreateWithoutUserInput[] | AdViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutUserInput | AdViewCreateOrConnectWithoutUserInput[]
    upsert?: AdViewUpsertWithWhereUniqueWithoutUserInput | AdViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdViewCreateManyUserInputEnvelope
    set?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    disconnect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    delete?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    update?: AdViewUpdateWithWhereUniqueWithoutUserInput | AdViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdViewUpdateManyWithWhereWithoutUserInput | AdViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVideoQualityFieldUpdateOperationsInput = {
    set?: $Enums.VideoQuality
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type SharedAccountCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SharedAccountCreateWithoutSubscriptionInput, SharedAccountUncheckedCreateWithoutSubscriptionInput> | SharedAccountCreateWithoutSubscriptionInput[] | SharedAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSubscriptionInput | SharedAccountCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SharedAccountCreateManySubscriptionInputEnvelope
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
  }

  export type SharedAccountUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SharedAccountCreateWithoutSubscriptionInput, SharedAccountUncheckedCreateWithoutSubscriptionInput> | SharedAccountCreateWithoutSubscriptionInput[] | SharedAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSubscriptionInput | SharedAccountCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SharedAccountCreateManySubscriptionInputEnvelope
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
  }

  export type EnumRenewalStatusFieldUpdateOperationsInput = {
    set?: $Enums.RenewalStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SharedAccountUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SharedAccountCreateWithoutSubscriptionInput, SharedAccountUncheckedCreateWithoutSubscriptionInput> | SharedAccountCreateWithoutSubscriptionInput[] | SharedAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSubscriptionInput | SharedAccountCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SharedAccountUpsertWithWhereUniqueWithoutSubscriptionInput | SharedAccountUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SharedAccountCreateManySubscriptionInputEnvelope
    set?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    disconnect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    delete?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    update?: SharedAccountUpdateWithWhereUniqueWithoutSubscriptionInput | SharedAccountUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SharedAccountUpdateManyWithWhereWithoutSubscriptionInput | SharedAccountUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
  }

  export type SharedAccountUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SharedAccountCreateWithoutSubscriptionInput, SharedAccountUncheckedCreateWithoutSubscriptionInput> | SharedAccountCreateWithoutSubscriptionInput[] | SharedAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SharedAccountCreateOrConnectWithoutSubscriptionInput | SharedAccountCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SharedAccountUpsertWithWhereUniqueWithoutSubscriptionInput | SharedAccountUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SharedAccountCreateManySubscriptionInputEnvelope
    set?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    disconnect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    delete?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    connect?: SharedAccountWhereUniqueInput | SharedAccountWhereUniqueInput[]
    update?: SharedAccountUpdateWithWhereUniqueWithoutSubscriptionInput | SharedAccountUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SharedAccountUpdateManyWithWhereWithoutSubscriptionInput | SharedAccountUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedSharedAccountsInput = {
    create?: XOR<UserCreateWithoutOwnedSharedAccountsInput, UserUncheckedCreateWithoutOwnedSharedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedSharedAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedAccountInput = {
    create?: XOR<UserCreateWithoutSharedAccountInput, UserUncheckedCreateWithoutSharedAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedAccountInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutSharedAccountsInput = {
    create?: XOR<SubscriptionCreateWithoutSharedAccountsInput, SubscriptionUncheckedCreateWithoutSharedAccountsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSharedAccountsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SharedAccountUserCreateNestedManyWithoutSharedAccountInput = {
    create?: XOR<SharedAccountUserCreateWithoutSharedAccountInput, SharedAccountUserUncheckedCreateWithoutSharedAccountInput> | SharedAccountUserCreateWithoutSharedAccountInput[] | SharedAccountUserUncheckedCreateWithoutSharedAccountInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutSharedAccountInput | SharedAccountUserCreateOrConnectWithoutSharedAccountInput[]
    createMany?: SharedAccountUserCreateManySharedAccountInputEnvelope
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
  }

  export type SharedAccountUserUncheckedCreateNestedManyWithoutSharedAccountInput = {
    create?: XOR<SharedAccountUserCreateWithoutSharedAccountInput, SharedAccountUserUncheckedCreateWithoutSharedAccountInput> | SharedAccountUserCreateWithoutSharedAccountInput[] | SharedAccountUserUncheckedCreateWithoutSharedAccountInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutSharedAccountInput | SharedAccountUserCreateOrConnectWithoutSharedAccountInput[]
    createMany?: SharedAccountUserCreateManySharedAccountInputEnvelope
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
  }

  export type EnumSharedAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.SharedAccountStatus
  }

  export type UserUpdateOneRequiredWithoutOwnedSharedAccountsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedSharedAccountsInput, UserUncheckedCreateWithoutOwnedSharedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedSharedAccountsInput
    upsert?: UserUpsertWithoutOwnedSharedAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedSharedAccountsInput, UserUpdateWithoutOwnedSharedAccountsInput>, UserUncheckedUpdateWithoutOwnedSharedAccountsInput>
  }

  export type UserUpdateOneWithoutSharedAccountNestedInput = {
    create?: XOR<UserCreateWithoutSharedAccountInput, UserUncheckedCreateWithoutSharedAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedAccountInput
    upsert?: UserUpsertWithoutSharedAccountInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedAccountInput, UserUpdateWithoutSharedAccountInput>, UserUncheckedUpdateWithoutSharedAccountInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutSharedAccountsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSharedAccountsInput, SubscriptionUncheckedCreateWithoutSharedAccountsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSharedAccountsInput
    upsert?: SubscriptionUpsertWithoutSharedAccountsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutSharedAccountsInput, SubscriptionUpdateWithoutSharedAccountsInput>, SubscriptionUncheckedUpdateWithoutSharedAccountsInput>
  }

  export type SharedAccountUserUpdateManyWithoutSharedAccountNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutSharedAccountInput, SharedAccountUserUncheckedCreateWithoutSharedAccountInput> | SharedAccountUserCreateWithoutSharedAccountInput[] | SharedAccountUserUncheckedCreateWithoutSharedAccountInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutSharedAccountInput | SharedAccountUserCreateOrConnectWithoutSharedAccountInput[]
    upsert?: SharedAccountUserUpsertWithWhereUniqueWithoutSharedAccountInput | SharedAccountUserUpsertWithWhereUniqueWithoutSharedAccountInput[]
    createMany?: SharedAccountUserCreateManySharedAccountInputEnvelope
    set?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    disconnect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    delete?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    update?: SharedAccountUserUpdateWithWhereUniqueWithoutSharedAccountInput | SharedAccountUserUpdateWithWhereUniqueWithoutSharedAccountInput[]
    updateMany?: SharedAccountUserUpdateManyWithWhereWithoutSharedAccountInput | SharedAccountUserUpdateManyWithWhereWithoutSharedAccountInput[]
    deleteMany?: SharedAccountUserScalarWhereInput | SharedAccountUserScalarWhereInput[]
  }

  export type SharedAccountUserUncheckedUpdateManyWithoutSharedAccountNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutSharedAccountInput, SharedAccountUserUncheckedCreateWithoutSharedAccountInput> | SharedAccountUserCreateWithoutSharedAccountInput[] | SharedAccountUserUncheckedCreateWithoutSharedAccountInput[]
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutSharedAccountInput | SharedAccountUserCreateOrConnectWithoutSharedAccountInput[]
    upsert?: SharedAccountUserUpsertWithWhereUniqueWithoutSharedAccountInput | SharedAccountUserUpsertWithWhereUniqueWithoutSharedAccountInput[]
    createMany?: SharedAccountUserCreateManySharedAccountInputEnvelope
    set?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    disconnect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    delete?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    connect?: SharedAccountUserWhereUniqueInput | SharedAccountUserWhereUniqueInput[]
    update?: SharedAccountUserUpdateWithWhereUniqueWithoutSharedAccountInput | SharedAccountUserUpdateWithWhereUniqueWithoutSharedAccountInput[]
    updateMany?: SharedAccountUserUpdateManyWithWhereWithoutSharedAccountInput | SharedAccountUserUpdateManyWithWhereWithoutSharedAccountInput[]
    deleteMany?: SharedAccountUserScalarWhereInput | SharedAccountUserScalarWhereInput[]
  }

  export type SharedAccountCreateNestedOneWithoutProfilesInput = {
    create?: XOR<SharedAccountCreateWithoutProfilesInput, SharedAccountUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: SharedAccountCreateOrConnectWithoutProfilesInput
    connect?: SharedAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedProfilesInput = {
    create?: XOR<UserCreateWithoutSharedProfilesInput, UserUncheckedCreateWithoutSharedProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProfilesInput
    connect?: UserWhereUniqueInput
  }

  export type ViewCreateNestedManyWithoutProfileInput = {
    create?: XOR<ViewCreateWithoutProfileInput, ViewUncheckedCreateWithoutProfileInput> | ViewCreateWithoutProfileInput[] | ViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutProfileInput | ViewCreateOrConnectWithoutProfileInput[]
    createMany?: ViewCreateManyProfileInputEnvelope
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
  }

  export type AdViewCreateNestedManyWithoutProfileInput = {
    create?: XOR<AdViewCreateWithoutProfileInput, AdViewUncheckedCreateWithoutProfileInput> | AdViewCreateWithoutProfileInput[] | AdViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutProfileInput | AdViewCreateOrConnectWithoutProfileInput[]
    createMany?: AdViewCreateManyProfileInputEnvelope
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
  }

  export type SharedProfileActivityCreateNestedManyWithoutProfileInput = {
    create?: XOR<SharedProfileActivityCreateWithoutProfileInput, SharedProfileActivityUncheckedCreateWithoutProfileInput> | SharedProfileActivityCreateWithoutProfileInput[] | SharedProfileActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SharedProfileActivityCreateOrConnectWithoutProfileInput | SharedProfileActivityCreateOrConnectWithoutProfileInput[]
    createMany?: SharedProfileActivityCreateManyProfileInputEnvelope
    connect?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
  }

  export type ViewUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ViewCreateWithoutProfileInput, ViewUncheckedCreateWithoutProfileInput> | ViewCreateWithoutProfileInput[] | ViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutProfileInput | ViewCreateOrConnectWithoutProfileInput[]
    createMany?: ViewCreateManyProfileInputEnvelope
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
  }

  export type AdViewUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<AdViewCreateWithoutProfileInput, AdViewUncheckedCreateWithoutProfileInput> | AdViewCreateWithoutProfileInput[] | AdViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutProfileInput | AdViewCreateOrConnectWithoutProfileInput[]
    createMany?: AdViewCreateManyProfileInputEnvelope
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
  }

  export type SharedProfileActivityUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<SharedProfileActivityCreateWithoutProfileInput, SharedProfileActivityUncheckedCreateWithoutProfileInput> | SharedProfileActivityCreateWithoutProfileInput[] | SharedProfileActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SharedProfileActivityCreateOrConnectWithoutProfileInput | SharedProfileActivityCreateOrConnectWithoutProfileInput[]
    createMany?: SharedProfileActivityCreateManyProfileInputEnvelope
    connect?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
  }

  export type SharedAccountUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<SharedAccountCreateWithoutProfilesInput, SharedAccountUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: SharedAccountCreateOrConnectWithoutProfilesInput
    upsert?: SharedAccountUpsertWithoutProfilesInput
    connect?: SharedAccountWhereUniqueInput
    update?: XOR<XOR<SharedAccountUpdateToOneWithWhereWithoutProfilesInput, SharedAccountUpdateWithoutProfilesInput>, SharedAccountUncheckedUpdateWithoutProfilesInput>
  }

  export type UserUpdateOneRequiredWithoutSharedProfilesNestedInput = {
    create?: XOR<UserCreateWithoutSharedProfilesInput, UserUncheckedCreateWithoutSharedProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProfilesInput
    upsert?: UserUpsertWithoutSharedProfilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedProfilesInput, UserUpdateWithoutSharedProfilesInput>, UserUncheckedUpdateWithoutSharedProfilesInput>
  }

  export type ViewUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ViewCreateWithoutProfileInput, ViewUncheckedCreateWithoutProfileInput> | ViewCreateWithoutProfileInput[] | ViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutProfileInput | ViewCreateOrConnectWithoutProfileInput[]
    upsert?: ViewUpsertWithWhereUniqueWithoutProfileInput | ViewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ViewCreateManyProfileInputEnvelope
    set?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    disconnect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    delete?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    update?: ViewUpdateWithWhereUniqueWithoutProfileInput | ViewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ViewUpdateManyWithWhereWithoutProfileInput | ViewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ViewScalarWhereInput | ViewScalarWhereInput[]
  }

  export type AdViewUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AdViewCreateWithoutProfileInput, AdViewUncheckedCreateWithoutProfileInput> | AdViewCreateWithoutProfileInput[] | AdViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutProfileInput | AdViewCreateOrConnectWithoutProfileInput[]
    upsert?: AdViewUpsertWithWhereUniqueWithoutProfileInput | AdViewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AdViewCreateManyProfileInputEnvelope
    set?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    disconnect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    delete?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    update?: AdViewUpdateWithWhereUniqueWithoutProfileInput | AdViewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AdViewUpdateManyWithWhereWithoutProfileInput | AdViewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
  }

  export type SharedProfileActivityUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SharedProfileActivityCreateWithoutProfileInput, SharedProfileActivityUncheckedCreateWithoutProfileInput> | SharedProfileActivityCreateWithoutProfileInput[] | SharedProfileActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SharedProfileActivityCreateOrConnectWithoutProfileInput | SharedProfileActivityCreateOrConnectWithoutProfileInput[]
    upsert?: SharedProfileActivityUpsertWithWhereUniqueWithoutProfileInput | SharedProfileActivityUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SharedProfileActivityCreateManyProfileInputEnvelope
    set?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    disconnect?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    delete?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    connect?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    update?: SharedProfileActivityUpdateWithWhereUniqueWithoutProfileInput | SharedProfileActivityUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SharedProfileActivityUpdateManyWithWhereWithoutProfileInput | SharedProfileActivityUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SharedProfileActivityScalarWhereInput | SharedProfileActivityScalarWhereInput[]
  }

  export type ViewUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ViewCreateWithoutProfileInput, ViewUncheckedCreateWithoutProfileInput> | ViewCreateWithoutProfileInput[] | ViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutProfileInput | ViewCreateOrConnectWithoutProfileInput[]
    upsert?: ViewUpsertWithWhereUniqueWithoutProfileInput | ViewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ViewCreateManyProfileInputEnvelope
    set?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    disconnect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    delete?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    update?: ViewUpdateWithWhereUniqueWithoutProfileInput | ViewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ViewUpdateManyWithWhereWithoutProfileInput | ViewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ViewScalarWhereInput | ViewScalarWhereInput[]
  }

  export type AdViewUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AdViewCreateWithoutProfileInput, AdViewUncheckedCreateWithoutProfileInput> | AdViewCreateWithoutProfileInput[] | AdViewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutProfileInput | AdViewCreateOrConnectWithoutProfileInput[]
    upsert?: AdViewUpsertWithWhereUniqueWithoutProfileInput | AdViewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AdViewCreateManyProfileInputEnvelope
    set?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    disconnect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    delete?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    update?: AdViewUpdateWithWhereUniqueWithoutProfileInput | AdViewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AdViewUpdateManyWithWhereWithoutProfileInput | AdViewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
  }

  export type SharedProfileActivityUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SharedProfileActivityCreateWithoutProfileInput, SharedProfileActivityUncheckedCreateWithoutProfileInput> | SharedProfileActivityCreateWithoutProfileInput[] | SharedProfileActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SharedProfileActivityCreateOrConnectWithoutProfileInput | SharedProfileActivityCreateOrConnectWithoutProfileInput[]
    upsert?: SharedProfileActivityUpsertWithWhereUniqueWithoutProfileInput | SharedProfileActivityUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SharedProfileActivityCreateManyProfileInputEnvelope
    set?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    disconnect?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    delete?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    connect?: SharedProfileActivityWhereUniqueInput | SharedProfileActivityWhereUniqueInput[]
    update?: SharedProfileActivityUpdateWithWhereUniqueWithoutProfileInput | SharedProfileActivityUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SharedProfileActivityUpdateManyWithWhereWithoutProfileInput | SharedProfileActivityUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SharedProfileActivityScalarWhereInput | SharedProfileActivityScalarWhereInput[]
  }

  export type VideoFormatCreateNestedOneWithoutVideosInput = {
    create?: XOR<VideoFormatCreateWithoutVideosInput, VideoFormatUncheckedCreateWithoutVideosInput>
    connectOrCreate?: VideoFormatCreateOrConnectWithoutVideosInput
    connect?: VideoFormatWhereUniqueInput
  }

  export type VideoCategoryCreateNestedOneWithoutVideosInput = {
    create?: XOR<VideoCategoryCreateWithoutVideosInput, VideoCategoryUncheckedCreateWithoutVideosInput>
    connectOrCreate?: VideoCategoryCreateOrConnectWithoutVideosInput
    connect?: VideoCategoryWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutMetadataInput = {
    create?: XOR<MovieCreateWithoutMetadataInput, MovieUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMetadataInput
    connect?: MovieWhereUniqueInput
  }

  export type EpisodeCreateNestedOneWithoutMetadataInput = {
    create?: XOR<EpisodeCreateWithoutMetadataInput, EpisodeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutMetadataInput
    connect?: EpisodeWhereUniqueInput
  }

  export type SeriesCreateNestedOneWithoutMetadataInput = {
    create?: XOR<SeriesCreateWithoutMetadataInput, SeriesUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutMetadataInput
    connect?: SeriesWhereUniqueInput
  }

  export type VideoGenreCreateNestedManyWithoutVideosInput = {
    create?: XOR<VideoGenreCreateWithoutVideosInput, VideoGenreUncheckedCreateWithoutVideosInput> | VideoGenreCreateWithoutVideosInput[] | VideoGenreUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoGenreCreateOrConnectWithoutVideosInput | VideoGenreCreateOrConnectWithoutVideosInput[]
    connect?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
  }

  export type VideoActorCreateNestedManyWithoutVideoInput = {
    create?: XOR<VideoActorCreateWithoutVideoInput, VideoActorUncheckedCreateWithoutVideoInput> | VideoActorCreateWithoutVideoInput[] | VideoActorUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutVideoInput | VideoActorCreateOrConnectWithoutVideoInput[]
    createMany?: VideoActorCreateManyVideoInputEnvelope
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
  }

  export type SubtitleCreateNestedManyWithoutVideoMetadataInput = {
    create?: XOR<SubtitleCreateWithoutVideoMetadataInput, SubtitleUncheckedCreateWithoutVideoMetadataInput> | SubtitleCreateWithoutVideoMetadataInput[] | SubtitleUncheckedCreateWithoutVideoMetadataInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoMetadataInput | SubtitleCreateOrConnectWithoutVideoMetadataInput[]
    createMany?: SubtitleCreateManyVideoMetadataInputEnvelope
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
  }

  export type VideoLanguageCreateNestedManyWithoutVideosInput = {
    create?: XOR<VideoLanguageCreateWithoutVideosInput, VideoLanguageUncheckedCreateWithoutVideosInput> | VideoLanguageCreateWithoutVideosInput[] | VideoLanguageUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoLanguageCreateOrConnectWithoutVideosInput | VideoLanguageCreateOrConnectWithoutVideosInput[]
    connect?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
  }

  export type MovieUncheckedCreateNestedOneWithoutMetadataInput = {
    create?: XOR<MovieCreateWithoutMetadataInput, MovieUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMetadataInput
    connect?: MovieWhereUniqueInput
  }

  export type EpisodeUncheckedCreateNestedOneWithoutMetadataInput = {
    create?: XOR<EpisodeCreateWithoutMetadataInput, EpisodeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutMetadataInput
    connect?: EpisodeWhereUniqueInput
  }

  export type SeriesUncheckedCreateNestedOneWithoutMetadataInput = {
    create?: XOR<SeriesCreateWithoutMetadataInput, SeriesUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutMetadataInput
    connect?: SeriesWhereUniqueInput
  }

  export type VideoGenreUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<VideoGenreCreateWithoutVideosInput, VideoGenreUncheckedCreateWithoutVideosInput> | VideoGenreCreateWithoutVideosInput[] | VideoGenreUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoGenreCreateOrConnectWithoutVideosInput | VideoGenreCreateOrConnectWithoutVideosInput[]
    connect?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
  }

  export type VideoActorUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<VideoActorCreateWithoutVideoInput, VideoActorUncheckedCreateWithoutVideoInput> | VideoActorCreateWithoutVideoInput[] | VideoActorUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutVideoInput | VideoActorCreateOrConnectWithoutVideoInput[]
    createMany?: VideoActorCreateManyVideoInputEnvelope
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
  }

  export type SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput = {
    create?: XOR<SubtitleCreateWithoutVideoMetadataInput, SubtitleUncheckedCreateWithoutVideoMetadataInput> | SubtitleCreateWithoutVideoMetadataInput[] | SubtitleUncheckedCreateWithoutVideoMetadataInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoMetadataInput | SubtitleCreateOrConnectWithoutVideoMetadataInput[]
    createMany?: SubtitleCreateManyVideoMetadataInputEnvelope
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
  }

  export type VideoLanguageUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<VideoLanguageCreateWithoutVideosInput, VideoLanguageUncheckedCreateWithoutVideosInput> | VideoLanguageCreateWithoutVideosInput[] | VideoLanguageUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoLanguageCreateOrConnectWithoutVideosInput | VideoLanguageCreateOrConnectWithoutVideosInput[]
    connect?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
  }

  export type VideoFormatUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<VideoFormatCreateWithoutVideosInput, VideoFormatUncheckedCreateWithoutVideosInput>
    connectOrCreate?: VideoFormatCreateOrConnectWithoutVideosInput
    upsert?: VideoFormatUpsertWithoutVideosInput
    connect?: VideoFormatWhereUniqueInput
    update?: XOR<XOR<VideoFormatUpdateToOneWithWhereWithoutVideosInput, VideoFormatUpdateWithoutVideosInput>, VideoFormatUncheckedUpdateWithoutVideosInput>
  }

  export type VideoCategoryUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<VideoCategoryCreateWithoutVideosInput, VideoCategoryUncheckedCreateWithoutVideosInput>
    connectOrCreate?: VideoCategoryCreateOrConnectWithoutVideosInput
    upsert?: VideoCategoryUpsertWithoutVideosInput
    connect?: VideoCategoryWhereUniqueInput
    update?: XOR<XOR<VideoCategoryUpdateToOneWithWhereWithoutVideosInput, VideoCategoryUpdateWithoutVideosInput>, VideoCategoryUncheckedUpdateWithoutVideosInput>
  }

  export type MovieUpdateOneWithoutMetadataNestedInput = {
    create?: XOR<MovieCreateWithoutMetadataInput, MovieUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMetadataInput
    upsert?: MovieUpsertWithoutMetadataInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMetadataInput, MovieUpdateWithoutMetadataInput>, MovieUncheckedUpdateWithoutMetadataInput>
  }

  export type EpisodeUpdateOneWithoutMetadataNestedInput = {
    create?: XOR<EpisodeCreateWithoutMetadataInput, EpisodeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutMetadataInput
    upsert?: EpisodeUpsertWithoutMetadataInput
    disconnect?: EpisodeWhereInput | boolean
    delete?: EpisodeWhereInput | boolean
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutMetadataInput, EpisodeUpdateWithoutMetadataInput>, EpisodeUncheckedUpdateWithoutMetadataInput>
  }

  export type SeriesUpdateOneWithoutMetadataNestedInput = {
    create?: XOR<SeriesCreateWithoutMetadataInput, SeriesUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutMetadataInput
    upsert?: SeriesUpsertWithoutMetadataInput
    disconnect?: SeriesWhereInput | boolean
    delete?: SeriesWhereInput | boolean
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutMetadataInput, SeriesUpdateWithoutMetadataInput>, SeriesUncheckedUpdateWithoutMetadataInput>
  }

  export type VideoGenreUpdateManyWithoutVideosNestedInput = {
    create?: XOR<VideoGenreCreateWithoutVideosInput, VideoGenreUncheckedCreateWithoutVideosInput> | VideoGenreCreateWithoutVideosInput[] | VideoGenreUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoGenreCreateOrConnectWithoutVideosInput | VideoGenreCreateOrConnectWithoutVideosInput[]
    upsert?: VideoGenreUpsertWithWhereUniqueWithoutVideosInput | VideoGenreUpsertWithWhereUniqueWithoutVideosInput[]
    set?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    disconnect?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    delete?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    connect?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    update?: VideoGenreUpdateWithWhereUniqueWithoutVideosInput | VideoGenreUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: VideoGenreUpdateManyWithWhereWithoutVideosInput | VideoGenreUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: VideoGenreScalarWhereInput | VideoGenreScalarWhereInput[]
  }

  export type VideoActorUpdateManyWithoutVideoNestedInput = {
    create?: XOR<VideoActorCreateWithoutVideoInput, VideoActorUncheckedCreateWithoutVideoInput> | VideoActorCreateWithoutVideoInput[] | VideoActorUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutVideoInput | VideoActorCreateOrConnectWithoutVideoInput[]
    upsert?: VideoActorUpsertWithWhereUniqueWithoutVideoInput | VideoActorUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: VideoActorCreateManyVideoInputEnvelope
    set?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    disconnect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    delete?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    update?: VideoActorUpdateWithWhereUniqueWithoutVideoInput | VideoActorUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: VideoActorUpdateManyWithWhereWithoutVideoInput | VideoActorUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: VideoActorScalarWhereInput | VideoActorScalarWhereInput[]
  }

  export type SubtitleUpdateManyWithoutVideoMetadataNestedInput = {
    create?: XOR<SubtitleCreateWithoutVideoMetadataInput, SubtitleUncheckedCreateWithoutVideoMetadataInput> | SubtitleCreateWithoutVideoMetadataInput[] | SubtitleUncheckedCreateWithoutVideoMetadataInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoMetadataInput | SubtitleCreateOrConnectWithoutVideoMetadataInput[]
    upsert?: SubtitleUpsertWithWhereUniqueWithoutVideoMetadataInput | SubtitleUpsertWithWhereUniqueWithoutVideoMetadataInput[]
    createMany?: SubtitleCreateManyVideoMetadataInputEnvelope
    set?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    disconnect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    delete?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    update?: SubtitleUpdateWithWhereUniqueWithoutVideoMetadataInput | SubtitleUpdateWithWhereUniqueWithoutVideoMetadataInput[]
    updateMany?: SubtitleUpdateManyWithWhereWithoutVideoMetadataInput | SubtitleUpdateManyWithWhereWithoutVideoMetadataInput[]
    deleteMany?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
  }

  export type VideoLanguageUpdateManyWithoutVideosNestedInput = {
    create?: XOR<VideoLanguageCreateWithoutVideosInput, VideoLanguageUncheckedCreateWithoutVideosInput> | VideoLanguageCreateWithoutVideosInput[] | VideoLanguageUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoLanguageCreateOrConnectWithoutVideosInput | VideoLanguageCreateOrConnectWithoutVideosInput[]
    upsert?: VideoLanguageUpsertWithWhereUniqueWithoutVideosInput | VideoLanguageUpsertWithWhereUniqueWithoutVideosInput[]
    set?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    disconnect?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    delete?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    connect?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    update?: VideoLanguageUpdateWithWhereUniqueWithoutVideosInput | VideoLanguageUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: VideoLanguageUpdateManyWithWhereWithoutVideosInput | VideoLanguageUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: VideoLanguageScalarWhereInput | VideoLanguageScalarWhereInput[]
  }

  export type MovieUncheckedUpdateOneWithoutMetadataNestedInput = {
    create?: XOR<MovieCreateWithoutMetadataInput, MovieUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMetadataInput
    upsert?: MovieUpsertWithoutMetadataInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMetadataInput, MovieUpdateWithoutMetadataInput>, MovieUncheckedUpdateWithoutMetadataInput>
  }

  export type EpisodeUncheckedUpdateOneWithoutMetadataNestedInput = {
    create?: XOR<EpisodeCreateWithoutMetadataInput, EpisodeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutMetadataInput
    upsert?: EpisodeUpsertWithoutMetadataInput
    disconnect?: EpisodeWhereInput | boolean
    delete?: EpisodeWhereInput | boolean
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutMetadataInput, EpisodeUpdateWithoutMetadataInput>, EpisodeUncheckedUpdateWithoutMetadataInput>
  }

  export type SeriesUncheckedUpdateOneWithoutMetadataNestedInput = {
    create?: XOR<SeriesCreateWithoutMetadataInput, SeriesUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutMetadataInput
    upsert?: SeriesUpsertWithoutMetadataInput
    disconnect?: SeriesWhereInput | boolean
    delete?: SeriesWhereInput | boolean
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutMetadataInput, SeriesUpdateWithoutMetadataInput>, SeriesUncheckedUpdateWithoutMetadataInput>
  }

  export type VideoGenreUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<VideoGenreCreateWithoutVideosInput, VideoGenreUncheckedCreateWithoutVideosInput> | VideoGenreCreateWithoutVideosInput[] | VideoGenreUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoGenreCreateOrConnectWithoutVideosInput | VideoGenreCreateOrConnectWithoutVideosInput[]
    upsert?: VideoGenreUpsertWithWhereUniqueWithoutVideosInput | VideoGenreUpsertWithWhereUniqueWithoutVideosInput[]
    set?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    disconnect?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    delete?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    connect?: VideoGenreWhereUniqueInput | VideoGenreWhereUniqueInput[]
    update?: VideoGenreUpdateWithWhereUniqueWithoutVideosInput | VideoGenreUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: VideoGenreUpdateManyWithWhereWithoutVideosInput | VideoGenreUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: VideoGenreScalarWhereInput | VideoGenreScalarWhereInput[]
  }

  export type VideoActorUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<VideoActorCreateWithoutVideoInput, VideoActorUncheckedCreateWithoutVideoInput> | VideoActorCreateWithoutVideoInput[] | VideoActorUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutVideoInput | VideoActorCreateOrConnectWithoutVideoInput[]
    upsert?: VideoActorUpsertWithWhereUniqueWithoutVideoInput | VideoActorUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: VideoActorCreateManyVideoInputEnvelope
    set?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    disconnect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    delete?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    update?: VideoActorUpdateWithWhereUniqueWithoutVideoInput | VideoActorUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: VideoActorUpdateManyWithWhereWithoutVideoInput | VideoActorUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: VideoActorScalarWhereInput | VideoActorScalarWhereInput[]
  }

  export type SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput = {
    create?: XOR<SubtitleCreateWithoutVideoMetadataInput, SubtitleUncheckedCreateWithoutVideoMetadataInput> | SubtitleCreateWithoutVideoMetadataInput[] | SubtitleUncheckedCreateWithoutVideoMetadataInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoMetadataInput | SubtitleCreateOrConnectWithoutVideoMetadataInput[]
    upsert?: SubtitleUpsertWithWhereUniqueWithoutVideoMetadataInput | SubtitleUpsertWithWhereUniqueWithoutVideoMetadataInput[]
    createMany?: SubtitleCreateManyVideoMetadataInputEnvelope
    set?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    disconnect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    delete?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    update?: SubtitleUpdateWithWhereUniqueWithoutVideoMetadataInput | SubtitleUpdateWithWhereUniqueWithoutVideoMetadataInput[]
    updateMany?: SubtitleUpdateManyWithWhereWithoutVideoMetadataInput | SubtitleUpdateManyWithWhereWithoutVideoMetadataInput[]
    deleteMany?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
  }

  export type VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<VideoLanguageCreateWithoutVideosInput, VideoLanguageUncheckedCreateWithoutVideosInput> | VideoLanguageCreateWithoutVideosInput[] | VideoLanguageUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: VideoLanguageCreateOrConnectWithoutVideosInput | VideoLanguageCreateOrConnectWithoutVideosInput[]
    upsert?: VideoLanguageUpsertWithWhereUniqueWithoutVideosInput | VideoLanguageUpsertWithWhereUniqueWithoutVideosInput[]
    set?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    disconnect?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    delete?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    connect?: VideoLanguageWhereUniqueInput | VideoLanguageWhereUniqueInput[]
    update?: VideoLanguageUpdateWithWhereUniqueWithoutVideosInput | VideoLanguageUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: VideoLanguageUpdateManyWithWhereWithoutVideosInput | VideoLanguageUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: VideoLanguageScalarWhereInput | VideoLanguageScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutVideoFileInput = {
    create?: XOR<MovieCreateWithoutVideoFileInput, MovieUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: MovieCreateOrConnectWithoutVideoFileInput
    connect?: MovieWhereUniqueInput
  }

  export type EpisodeCreateNestedOneWithoutVideoFileInput = {
    create?: XOR<EpisodeCreateWithoutVideoFileInput, EpisodeUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutVideoFileInput
    connect?: EpisodeWhereUniqueInput
  }

  export type SubtitleCreateNestedManyWithoutVideoInput = {
    create?: XOR<SubtitleCreateWithoutVideoInput, SubtitleUncheckedCreateWithoutVideoInput> | SubtitleCreateWithoutVideoInput[] | SubtitleUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoInput | SubtitleCreateOrConnectWithoutVideoInput[]
    createMany?: SubtitleCreateManyVideoInputEnvelope
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutVideoInput = {
    create?: XOR<PurchaseCreateWithoutVideoInput, PurchaseUncheckedCreateWithoutVideoInput> | PurchaseCreateWithoutVideoInput[] | PurchaseUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVideoInput | PurchaseCreateOrConnectWithoutVideoInput[]
    createMany?: PurchaseCreateManyVideoInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ViewCreateNestedManyWithoutVideoInput = {
    create?: XOR<ViewCreateWithoutVideoInput, ViewUncheckedCreateWithoutVideoInput> | ViewCreateWithoutVideoInput[] | ViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutVideoInput | ViewCreateOrConnectWithoutVideoInput[]
    createMany?: ViewCreateManyVideoInputEnvelope
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
  }

  export type MovieUncheckedCreateNestedOneWithoutVideoFileInput = {
    create?: XOR<MovieCreateWithoutVideoFileInput, MovieUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: MovieCreateOrConnectWithoutVideoFileInput
    connect?: MovieWhereUniqueInput
  }

  export type EpisodeUncheckedCreateNestedOneWithoutVideoFileInput = {
    create?: XOR<EpisodeCreateWithoutVideoFileInput, EpisodeUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutVideoFileInput
    connect?: EpisodeWhereUniqueInput
  }

  export type SubtitleUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<SubtitleCreateWithoutVideoInput, SubtitleUncheckedCreateWithoutVideoInput> | SubtitleCreateWithoutVideoInput[] | SubtitleUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoInput | SubtitleCreateOrConnectWithoutVideoInput[]
    createMany?: SubtitleCreateManyVideoInputEnvelope
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<PurchaseCreateWithoutVideoInput, PurchaseUncheckedCreateWithoutVideoInput> | PurchaseCreateWithoutVideoInput[] | PurchaseUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVideoInput | PurchaseCreateOrConnectWithoutVideoInput[]
    createMany?: PurchaseCreateManyVideoInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ViewUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<ViewCreateWithoutVideoInput, ViewUncheckedCreateWithoutVideoInput> | ViewCreateWithoutVideoInput[] | ViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutVideoInput | ViewCreateOrConnectWithoutVideoInput[]
    createMany?: ViewCreateManyVideoInputEnvelope
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MovieUpdateOneWithoutVideoFileNestedInput = {
    create?: XOR<MovieCreateWithoutVideoFileInput, MovieUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: MovieCreateOrConnectWithoutVideoFileInput
    upsert?: MovieUpsertWithoutVideoFileInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutVideoFileInput, MovieUpdateWithoutVideoFileInput>, MovieUncheckedUpdateWithoutVideoFileInput>
  }

  export type EpisodeUpdateOneWithoutVideoFileNestedInput = {
    create?: XOR<EpisodeCreateWithoutVideoFileInput, EpisodeUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutVideoFileInput
    upsert?: EpisodeUpsertWithoutVideoFileInput
    disconnect?: EpisodeWhereInput | boolean
    delete?: EpisodeWhereInput | boolean
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutVideoFileInput, EpisodeUpdateWithoutVideoFileInput>, EpisodeUncheckedUpdateWithoutVideoFileInput>
  }

  export type SubtitleUpdateManyWithoutVideoNestedInput = {
    create?: XOR<SubtitleCreateWithoutVideoInput, SubtitleUncheckedCreateWithoutVideoInput> | SubtitleCreateWithoutVideoInput[] | SubtitleUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoInput | SubtitleCreateOrConnectWithoutVideoInput[]
    upsert?: SubtitleUpsertWithWhereUniqueWithoutVideoInput | SubtitleUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: SubtitleCreateManyVideoInputEnvelope
    set?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    disconnect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    delete?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    update?: SubtitleUpdateWithWhereUniqueWithoutVideoInput | SubtitleUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: SubtitleUpdateManyWithWhereWithoutVideoInput | SubtitleUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutVideoNestedInput = {
    create?: XOR<PurchaseCreateWithoutVideoInput, PurchaseUncheckedCreateWithoutVideoInput> | PurchaseCreateWithoutVideoInput[] | PurchaseUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVideoInput | PurchaseCreateOrConnectWithoutVideoInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutVideoInput | PurchaseUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: PurchaseCreateManyVideoInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutVideoInput | PurchaseUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutVideoInput | PurchaseUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVideoInput | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVideoInput | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVideoInput | CommentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ViewUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ViewCreateWithoutVideoInput, ViewUncheckedCreateWithoutVideoInput> | ViewCreateWithoutVideoInput[] | ViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutVideoInput | ViewCreateOrConnectWithoutVideoInput[]
    upsert?: ViewUpsertWithWhereUniqueWithoutVideoInput | ViewUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ViewCreateManyVideoInputEnvelope
    set?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    disconnect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    delete?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    update?: ViewUpdateWithWhereUniqueWithoutVideoInput | ViewUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ViewUpdateManyWithWhereWithoutVideoInput | ViewUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ViewScalarWhereInput | ViewScalarWhereInput[]
  }

  export type MovieUncheckedUpdateOneWithoutVideoFileNestedInput = {
    create?: XOR<MovieCreateWithoutVideoFileInput, MovieUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: MovieCreateOrConnectWithoutVideoFileInput
    upsert?: MovieUpsertWithoutVideoFileInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutVideoFileInput, MovieUpdateWithoutVideoFileInput>, MovieUncheckedUpdateWithoutVideoFileInput>
  }

  export type EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput = {
    create?: XOR<EpisodeCreateWithoutVideoFileInput, EpisodeUncheckedCreateWithoutVideoFileInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutVideoFileInput
    upsert?: EpisodeUpsertWithoutVideoFileInput
    disconnect?: EpisodeWhereInput | boolean
    delete?: EpisodeWhereInput | boolean
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutVideoFileInput, EpisodeUpdateWithoutVideoFileInput>, EpisodeUncheckedUpdateWithoutVideoFileInput>
  }

  export type SubtitleUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<SubtitleCreateWithoutVideoInput, SubtitleUncheckedCreateWithoutVideoInput> | SubtitleCreateWithoutVideoInput[] | SubtitleUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoInput | SubtitleCreateOrConnectWithoutVideoInput[]
    upsert?: SubtitleUpsertWithWhereUniqueWithoutVideoInput | SubtitleUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: SubtitleCreateManyVideoInputEnvelope
    set?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    disconnect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    delete?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    update?: SubtitleUpdateWithWhereUniqueWithoutVideoInput | SubtitleUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: SubtitleUpdateManyWithWhereWithoutVideoInput | SubtitleUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<PurchaseCreateWithoutVideoInput, PurchaseUncheckedCreateWithoutVideoInput> | PurchaseCreateWithoutVideoInput[] | PurchaseUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVideoInput | PurchaseCreateOrConnectWithoutVideoInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutVideoInput | PurchaseUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: PurchaseCreateManyVideoInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutVideoInput | PurchaseUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutVideoInput | PurchaseUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVideoInput | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVideoInput | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVideoInput | CommentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ViewUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ViewCreateWithoutVideoInput, ViewUncheckedCreateWithoutVideoInput> | ViewCreateWithoutVideoInput[] | ViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ViewCreateOrConnectWithoutVideoInput | ViewCreateOrConnectWithoutVideoInput[]
    upsert?: ViewUpsertWithWhereUniqueWithoutVideoInput | ViewUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ViewCreateManyVideoInputEnvelope
    set?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    disconnect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    delete?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    connect?: ViewWhereUniqueInput | ViewWhereUniqueInput[]
    update?: ViewUpdateWithWhereUniqueWithoutVideoInput | ViewUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ViewUpdateManyWithWhereWithoutVideoInput | ViewUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ViewScalarWhereInput | ViewScalarWhereInput[]
  }

  export type VideoMetadataCreateNestedManyWithoutGenresInput = {
    create?: XOR<VideoMetadataCreateWithoutGenresInput, VideoMetadataUncheckedCreateWithoutGenresInput> | VideoMetadataCreateWithoutGenresInput[] | VideoMetadataUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutGenresInput | VideoMetadataCreateOrConnectWithoutGenresInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUncheckedCreateNestedManyWithoutGenresInput = {
    create?: XOR<VideoMetadataCreateWithoutGenresInput, VideoMetadataUncheckedCreateWithoutGenresInput> | VideoMetadataCreateWithoutGenresInput[] | VideoMetadataUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutGenresInput | VideoMetadataCreateOrConnectWithoutGenresInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUpdateManyWithoutGenresNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutGenresInput, VideoMetadataUncheckedCreateWithoutGenresInput> | VideoMetadataCreateWithoutGenresInput[] | VideoMetadataUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutGenresInput | VideoMetadataCreateOrConnectWithoutGenresInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutGenresInput | VideoMetadataUpsertWithWhereUniqueWithoutGenresInput[]
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutGenresInput | VideoMetadataUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutGenresInput | VideoMetadataUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataUncheckedUpdateManyWithoutGenresNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutGenresInput, VideoMetadataUncheckedCreateWithoutGenresInput> | VideoMetadataCreateWithoutGenresInput[] | VideoMetadataUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutGenresInput | VideoMetadataCreateOrConnectWithoutGenresInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutGenresInput | VideoMetadataUpsertWithWhereUniqueWithoutGenresInput[]
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutGenresInput | VideoMetadataUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutGenresInput | VideoMetadataUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoActorCreateNestedManyWithoutActorInput = {
    create?: XOR<VideoActorCreateWithoutActorInput, VideoActorUncheckedCreateWithoutActorInput> | VideoActorCreateWithoutActorInput[] | VideoActorUncheckedCreateWithoutActorInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutActorInput | VideoActorCreateOrConnectWithoutActorInput[]
    createMany?: VideoActorCreateManyActorInputEnvelope
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
  }

  export type VideoActorUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<VideoActorCreateWithoutActorInput, VideoActorUncheckedCreateWithoutActorInput> | VideoActorCreateWithoutActorInput[] | VideoActorUncheckedCreateWithoutActorInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutActorInput | VideoActorCreateOrConnectWithoutActorInput[]
    createMany?: VideoActorCreateManyActorInputEnvelope
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
  }

  export type VideoActorUpdateManyWithoutActorNestedInput = {
    create?: XOR<VideoActorCreateWithoutActorInput, VideoActorUncheckedCreateWithoutActorInput> | VideoActorCreateWithoutActorInput[] | VideoActorUncheckedCreateWithoutActorInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutActorInput | VideoActorCreateOrConnectWithoutActorInput[]
    upsert?: VideoActorUpsertWithWhereUniqueWithoutActorInput | VideoActorUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: VideoActorCreateManyActorInputEnvelope
    set?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    disconnect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    delete?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    update?: VideoActorUpdateWithWhereUniqueWithoutActorInput | VideoActorUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: VideoActorUpdateManyWithWhereWithoutActorInput | VideoActorUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: VideoActorScalarWhereInput | VideoActorScalarWhereInput[]
  }

  export type VideoActorUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<VideoActorCreateWithoutActorInput, VideoActorUncheckedCreateWithoutActorInput> | VideoActorCreateWithoutActorInput[] | VideoActorUncheckedCreateWithoutActorInput[]
    connectOrCreate?: VideoActorCreateOrConnectWithoutActorInput | VideoActorCreateOrConnectWithoutActorInput[]
    upsert?: VideoActorUpsertWithWhereUniqueWithoutActorInput | VideoActorUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: VideoActorCreateManyActorInputEnvelope
    set?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    disconnect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    delete?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    connect?: VideoActorWhereUniqueInput | VideoActorWhereUniqueInput[]
    update?: VideoActorUpdateWithWhereUniqueWithoutActorInput | VideoActorUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: VideoActorUpdateManyWithWhereWithoutActorInput | VideoActorUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: VideoActorScalarWhereInput | VideoActorScalarWhereInput[]
  }

  export type VideoMetadataCreateNestedOneWithoutActorsInput = {
    create?: XOR<VideoMetadataCreateWithoutActorsInput, VideoMetadataUncheckedCreateWithoutActorsInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutActorsInput
    connect?: VideoMetadataWhereUniqueInput
  }

  export type ActorCreateNestedOneWithoutVideoActorInput = {
    create?: XOR<ActorCreateWithoutVideoActorInput, ActorUncheckedCreateWithoutVideoActorInput>
    connectOrCreate?: ActorCreateOrConnectWithoutVideoActorInput
    connect?: ActorWhereUniqueInput
  }

  export type VideoMetadataUpdateOneRequiredWithoutActorsNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutActorsInput, VideoMetadataUncheckedCreateWithoutActorsInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutActorsInput
    upsert?: VideoMetadataUpsertWithoutActorsInput
    connect?: VideoMetadataWhereUniqueInput
    update?: XOR<XOR<VideoMetadataUpdateToOneWithWhereWithoutActorsInput, VideoMetadataUpdateWithoutActorsInput>, VideoMetadataUncheckedUpdateWithoutActorsInput>
  }

  export type ActorUpdateOneRequiredWithoutVideoActorNestedInput = {
    create?: XOR<ActorCreateWithoutVideoActorInput, ActorUncheckedCreateWithoutVideoActorInput>
    connectOrCreate?: ActorCreateOrConnectWithoutVideoActorInput
    upsert?: ActorUpsertWithoutVideoActorInput
    connect?: ActorWhereUniqueInput
    update?: XOR<XOR<ActorUpdateToOneWithWhereWithoutVideoActorInput, ActorUpdateWithoutVideoActorInput>, ActorUncheckedUpdateWithoutVideoActorInput>
  }

  export type VideoMetadataCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<VideoMetadataCreateWithoutLanguagesInput, VideoMetadataUncheckedCreateWithoutLanguagesInput> | VideoMetadataCreateWithoutLanguagesInput[] | VideoMetadataUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutLanguagesInput | VideoMetadataCreateOrConnectWithoutLanguagesInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<VideoMetadataCreateWithoutLanguagesInput, VideoMetadataUncheckedCreateWithoutLanguagesInput> | VideoMetadataCreateWithoutLanguagesInput[] | VideoMetadataUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutLanguagesInput | VideoMetadataCreateOrConnectWithoutLanguagesInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutLanguagesInput, VideoMetadataUncheckedCreateWithoutLanguagesInput> | VideoMetadataCreateWithoutLanguagesInput[] | VideoMetadataUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutLanguagesInput | VideoMetadataCreateOrConnectWithoutLanguagesInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutLanguagesInput | VideoMetadataUpsertWithWhereUniqueWithoutLanguagesInput[]
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutLanguagesInput | VideoMetadataUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutLanguagesInput | VideoMetadataUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutLanguagesInput, VideoMetadataUncheckedCreateWithoutLanguagesInput> | VideoMetadataCreateWithoutLanguagesInput[] | VideoMetadataUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutLanguagesInput | VideoMetadataCreateOrConnectWithoutLanguagesInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutLanguagesInput | VideoMetadataUpsertWithWhereUniqueWithoutLanguagesInput[]
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutLanguagesInput | VideoMetadataUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutLanguagesInput | VideoMetadataUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataCreateNestedManyWithoutFormatInput = {
    create?: XOR<VideoMetadataCreateWithoutFormatInput, VideoMetadataUncheckedCreateWithoutFormatInput> | VideoMetadataCreateWithoutFormatInput[] | VideoMetadataUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutFormatInput | VideoMetadataCreateOrConnectWithoutFormatInput[]
    createMany?: VideoMetadataCreateManyFormatInputEnvelope
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUncheckedCreateNestedManyWithoutFormatInput = {
    create?: XOR<VideoMetadataCreateWithoutFormatInput, VideoMetadataUncheckedCreateWithoutFormatInput> | VideoMetadataCreateWithoutFormatInput[] | VideoMetadataUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutFormatInput | VideoMetadataCreateOrConnectWithoutFormatInput[]
    createMany?: VideoMetadataCreateManyFormatInputEnvelope
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUpdateManyWithoutFormatNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutFormatInput, VideoMetadataUncheckedCreateWithoutFormatInput> | VideoMetadataCreateWithoutFormatInput[] | VideoMetadataUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutFormatInput | VideoMetadataCreateOrConnectWithoutFormatInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutFormatInput | VideoMetadataUpsertWithWhereUniqueWithoutFormatInput[]
    createMany?: VideoMetadataCreateManyFormatInputEnvelope
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutFormatInput | VideoMetadataUpdateWithWhereUniqueWithoutFormatInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutFormatInput | VideoMetadataUpdateManyWithWhereWithoutFormatInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataUncheckedUpdateManyWithoutFormatNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutFormatInput, VideoMetadataUncheckedCreateWithoutFormatInput> | VideoMetadataCreateWithoutFormatInput[] | VideoMetadataUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutFormatInput | VideoMetadataCreateOrConnectWithoutFormatInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutFormatInput | VideoMetadataUpsertWithWhereUniqueWithoutFormatInput[]
    createMany?: VideoMetadataCreateManyFormatInputEnvelope
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutFormatInput | VideoMetadataUpdateWithWhereUniqueWithoutFormatInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutFormatInput | VideoMetadataUpdateManyWithWhereWithoutFormatInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VideoMetadataCreateWithoutCategoryInput, VideoMetadataUncheckedCreateWithoutCategoryInput> | VideoMetadataCreateWithoutCategoryInput[] | VideoMetadataUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutCategoryInput | VideoMetadataCreateOrConnectWithoutCategoryInput[]
    createMany?: VideoMetadataCreateManyCategoryInputEnvelope
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VideoMetadataCreateWithoutCategoryInput, VideoMetadataUncheckedCreateWithoutCategoryInput> | VideoMetadataCreateWithoutCategoryInput[] | VideoMetadataUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutCategoryInput | VideoMetadataCreateOrConnectWithoutCategoryInput[]
    createMany?: VideoMetadataCreateManyCategoryInputEnvelope
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
  }

  export type VideoMetadataUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutCategoryInput, VideoMetadataUncheckedCreateWithoutCategoryInput> | VideoMetadataCreateWithoutCategoryInput[] | VideoMetadataUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutCategoryInput | VideoMetadataCreateOrConnectWithoutCategoryInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutCategoryInput | VideoMetadataUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VideoMetadataCreateManyCategoryInputEnvelope
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutCategoryInput | VideoMetadataUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutCategoryInput | VideoMetadataUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutCategoryInput, VideoMetadataUncheckedCreateWithoutCategoryInput> | VideoMetadataCreateWithoutCategoryInput[] | VideoMetadataUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutCategoryInput | VideoMetadataCreateOrConnectWithoutCategoryInput[]
    upsert?: VideoMetadataUpsertWithWhereUniqueWithoutCategoryInput | VideoMetadataUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VideoMetadataCreateManyCategoryInputEnvelope
    set?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    disconnect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    delete?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    connect?: VideoMetadataWhereUniqueInput | VideoMetadataWhereUniqueInput[]
    update?: VideoMetadataUpdateWithWhereUniqueWithoutCategoryInput | VideoMetadataUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VideoMetadataUpdateManyWithWhereWithoutCategoryInput | VideoMetadataUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
  }

  export type VideoMetadataCreateNestedOneWithoutMovieInput = {
    create?: XOR<VideoMetadataCreateWithoutMovieInput, VideoMetadataUncheckedCreateWithoutMovieInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutMovieInput
    connect?: VideoMetadataWhereUniqueInput
  }

  export type VideoFileCreateNestedOneWithoutMovieInput = {
    create?: XOR<VideoFileCreateWithoutMovieInput, VideoFileUncheckedCreateWithoutMovieInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutMovieInput
    connect?: VideoFileWhereUniqueInput
  }

  export type MovieTagCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type MovieTagUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VideoMetadataUpdateOneRequiredWithoutMovieNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutMovieInput, VideoMetadataUncheckedCreateWithoutMovieInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutMovieInput
    upsert?: VideoMetadataUpsertWithoutMovieInput
    connect?: VideoMetadataWhereUniqueInput
    update?: XOR<XOR<VideoMetadataUpdateToOneWithWhereWithoutMovieInput, VideoMetadataUpdateWithoutMovieInput>, VideoMetadataUncheckedUpdateWithoutMovieInput>
  }

  export type VideoFileUpdateOneRequiredWithoutMovieNestedInput = {
    create?: XOR<VideoFileCreateWithoutMovieInput, VideoFileUncheckedCreateWithoutMovieInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutMovieInput
    upsert?: VideoFileUpsertWithoutMovieInput
    connect?: VideoFileWhereUniqueInput
    update?: XOR<XOR<VideoFileUpdateToOneWithWhereWithoutMovieInput, VideoFileUpdateWithoutMovieInput>, VideoFileUncheckedUpdateWithoutMovieInput>
  }

  export type MovieTagUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutMovieInput | MovieTagUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutMovieInput | MovieTagUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutMovieInput | MovieTagUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type MovieTagUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput> | MovieTagCreateWithoutMovieInput[] | MovieTagUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutMovieInput | MovieTagCreateOrConnectWithoutMovieInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutMovieInput | MovieTagUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieTagCreateManyMovieInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutMovieInput | MovieTagUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutMovieInput | MovieTagUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type VideoMetadataCreateNestedOneWithoutSeriesInput = {
    create?: XOR<VideoMetadataCreateWithoutSeriesInput, VideoMetadataUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutSeriesInput
    connect?: VideoMetadataWhereUniqueInput
  }

  export type SeasonCreateNestedManyWithoutSeriesInput = {
    create?: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput> | SeasonCreateWithoutSeriesInput[] | SeasonUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutSeriesInput | SeasonCreateOrConnectWithoutSeriesInput[]
    createMany?: SeasonCreateManySeriesInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type SeriesTagCreateNestedManyWithoutSeriesInput = {
    create?: XOR<SeriesTagCreateWithoutSeriesInput, SeriesTagUncheckedCreateWithoutSeriesInput> | SeriesTagCreateWithoutSeriesInput[] | SeriesTagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutSeriesInput | SeriesTagCreateOrConnectWithoutSeriesInput[]
    createMany?: SeriesTagCreateManySeriesInputEnvelope
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
  }

  export type SeasonUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput> | SeasonCreateWithoutSeriesInput[] | SeasonUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutSeriesInput | SeasonCreateOrConnectWithoutSeriesInput[]
    createMany?: SeasonCreateManySeriesInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type SeriesTagUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<SeriesTagCreateWithoutSeriesInput, SeriesTagUncheckedCreateWithoutSeriesInput> | SeriesTagCreateWithoutSeriesInput[] | SeriesTagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutSeriesInput | SeriesTagCreateOrConnectWithoutSeriesInput[]
    createMany?: SeriesTagCreateManySeriesInputEnvelope
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
  }

  export type VideoMetadataUpdateOneRequiredWithoutSeriesNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutSeriesInput, VideoMetadataUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutSeriesInput
    upsert?: VideoMetadataUpsertWithoutSeriesInput
    connect?: VideoMetadataWhereUniqueInput
    update?: XOR<XOR<VideoMetadataUpdateToOneWithWhereWithoutSeriesInput, VideoMetadataUpdateWithoutSeriesInput>, VideoMetadataUncheckedUpdateWithoutSeriesInput>
  }

  export type SeasonUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput> | SeasonCreateWithoutSeriesInput[] | SeasonUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutSeriesInput | SeasonCreateOrConnectWithoutSeriesInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutSeriesInput | SeasonUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: SeasonCreateManySeriesInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutSeriesInput | SeasonUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutSeriesInput | SeasonUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type SeriesTagUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<SeriesTagCreateWithoutSeriesInput, SeriesTagUncheckedCreateWithoutSeriesInput> | SeriesTagCreateWithoutSeriesInput[] | SeriesTagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutSeriesInput | SeriesTagCreateOrConnectWithoutSeriesInput[]
    upsert?: SeriesTagUpsertWithWhereUniqueWithoutSeriesInput | SeriesTagUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: SeriesTagCreateManySeriesInputEnvelope
    set?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    disconnect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    delete?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    update?: SeriesTagUpdateWithWhereUniqueWithoutSeriesInput | SeriesTagUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: SeriesTagUpdateManyWithWhereWithoutSeriesInput | SeriesTagUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: SeriesTagScalarWhereInput | SeriesTagScalarWhereInput[]
  }

  export type SeasonUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput> | SeasonCreateWithoutSeriesInput[] | SeasonUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutSeriesInput | SeasonCreateOrConnectWithoutSeriesInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutSeriesInput | SeasonUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: SeasonCreateManySeriesInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutSeriesInput | SeasonUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutSeriesInput | SeasonUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type SeriesTagUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<SeriesTagCreateWithoutSeriesInput, SeriesTagUncheckedCreateWithoutSeriesInput> | SeriesTagCreateWithoutSeriesInput[] | SeriesTagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutSeriesInput | SeriesTagCreateOrConnectWithoutSeriesInput[]
    upsert?: SeriesTagUpsertWithWhereUniqueWithoutSeriesInput | SeriesTagUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: SeriesTagCreateManySeriesInputEnvelope
    set?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    disconnect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    delete?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    update?: SeriesTagUpdateWithWhereUniqueWithoutSeriesInput | SeriesTagUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: SeriesTagUpdateManyWithWhereWithoutSeriesInput | SeriesTagUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: SeriesTagScalarWhereInput | SeriesTagScalarWhereInput[]
  }

  export type SeriesCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<SeriesCreateWithoutSeasonsInput, SeriesUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutSeasonsInput
    connect?: SeriesWhereUniqueInput
  }

  export type EpisodeCreateNestedManyWithoutSeasonInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type EpisodeUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type SeriesUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<SeriesCreateWithoutSeasonsInput, SeriesUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutSeasonsInput
    upsert?: SeriesUpsertWithoutSeasonsInput
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutSeasonsInput, SeriesUpdateWithoutSeasonsInput>, SeriesUncheckedUpdateWithoutSeasonsInput>
  }

  export type EpisodeUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutSeasonInput | EpisodeUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutSeasonInput | EpisodeUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutSeasonInput | EpisodeUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type EpisodeUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutSeasonInput | EpisodeUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutSeasonInput | EpisodeUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutSeasonInput | EpisodeUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type SeasonCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutEpisodesInput
    connect?: SeasonWhereUniqueInput
  }

  export type VideoFileCreateNestedOneWithoutEpisodeInput = {
    create?: XOR<VideoFileCreateWithoutEpisodeInput, VideoFileUncheckedCreateWithoutEpisodeInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutEpisodeInput
    connect?: VideoFileWhereUniqueInput
  }

  export type VideoMetadataCreateNestedOneWithoutEpisodeInput = {
    create?: XOR<VideoMetadataCreateWithoutEpisodeInput, VideoMetadataUncheckedCreateWithoutEpisodeInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutEpisodeInput
    connect?: VideoMetadataWhereUniqueInput
  }

  export type SeasonUpdateOneRequiredWithoutEpisodesNestedInput = {
    create?: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutEpisodesInput
    upsert?: SeasonUpsertWithoutEpisodesInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutEpisodesInput, SeasonUpdateWithoutEpisodesInput>, SeasonUncheckedUpdateWithoutEpisodesInput>
  }

  export type VideoFileUpdateOneRequiredWithoutEpisodeNestedInput = {
    create?: XOR<VideoFileCreateWithoutEpisodeInput, VideoFileUncheckedCreateWithoutEpisodeInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutEpisodeInput
    upsert?: VideoFileUpsertWithoutEpisodeInput
    connect?: VideoFileWhereUniqueInput
    update?: XOR<XOR<VideoFileUpdateToOneWithWhereWithoutEpisodeInput, VideoFileUpdateWithoutEpisodeInput>, VideoFileUncheckedUpdateWithoutEpisodeInput>
  }

  export type VideoMetadataUpdateOneRequiredWithoutEpisodeNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutEpisodeInput, VideoMetadataUncheckedCreateWithoutEpisodeInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutEpisodeInput
    upsert?: VideoMetadataUpsertWithoutEpisodeInput
    connect?: VideoMetadataWhereUniqueInput
    update?: XOR<XOR<VideoMetadataUpdateToOneWithWhereWithoutEpisodeInput, VideoMetadataUpdateWithoutEpisodeInput>, VideoMetadataUncheckedUpdateWithoutEpisodeInput>
  }

  export type MovieTagCreateNestedManyWithoutTagInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type SeriesTagCreateNestedManyWithoutTagInput = {
    create?: XOR<SeriesTagCreateWithoutTagInput, SeriesTagUncheckedCreateWithoutTagInput> | SeriesTagCreateWithoutTagInput[] | SeriesTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutTagInput | SeriesTagCreateOrConnectWithoutTagInput[]
    createMany?: SeriesTagCreateManyTagInputEnvelope
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
  }

  export type MovieTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
  }

  export type SeriesTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<SeriesTagCreateWithoutTagInput, SeriesTagUncheckedCreateWithoutTagInput> | SeriesTagCreateWithoutTagInput[] | SeriesTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutTagInput | SeriesTagCreateOrConnectWithoutTagInput[]
    createMany?: SeriesTagCreateManyTagInputEnvelope
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
  }

  export type MovieTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutTagInput | MovieTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutTagInput | MovieTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutTagInput | MovieTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type SeriesTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<SeriesTagCreateWithoutTagInput, SeriesTagUncheckedCreateWithoutTagInput> | SeriesTagCreateWithoutTagInput[] | SeriesTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutTagInput | SeriesTagCreateOrConnectWithoutTagInput[]
    upsert?: SeriesTagUpsertWithWhereUniqueWithoutTagInput | SeriesTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: SeriesTagCreateManyTagInputEnvelope
    set?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    disconnect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    delete?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    update?: SeriesTagUpdateWithWhereUniqueWithoutTagInput | SeriesTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: SeriesTagUpdateManyWithWhereWithoutTagInput | SeriesTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: SeriesTagScalarWhereInput | SeriesTagScalarWhereInput[]
  }

  export type MovieTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput> | MovieTagCreateWithoutTagInput[] | MovieTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: MovieTagCreateOrConnectWithoutTagInput | MovieTagCreateOrConnectWithoutTagInput[]
    upsert?: MovieTagUpsertWithWhereUniqueWithoutTagInput | MovieTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: MovieTagCreateManyTagInputEnvelope
    set?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    disconnect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    delete?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    connect?: MovieTagWhereUniqueInput | MovieTagWhereUniqueInput[]
    update?: MovieTagUpdateWithWhereUniqueWithoutTagInput | MovieTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: MovieTagUpdateManyWithWhereWithoutTagInput | MovieTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
  }

  export type SeriesTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<SeriesTagCreateWithoutTagInput, SeriesTagUncheckedCreateWithoutTagInput> | SeriesTagCreateWithoutTagInput[] | SeriesTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SeriesTagCreateOrConnectWithoutTagInput | SeriesTagCreateOrConnectWithoutTagInput[]
    upsert?: SeriesTagUpsertWithWhereUniqueWithoutTagInput | SeriesTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: SeriesTagCreateManyTagInputEnvelope
    set?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    disconnect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    delete?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    connect?: SeriesTagWhereUniqueInput | SeriesTagWhereUniqueInput[]
    update?: SeriesTagUpdateWithWhereUniqueWithoutTagInput | SeriesTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: SeriesTagUpdateManyWithWhereWithoutTagInput | SeriesTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: SeriesTagScalarWhereInput | SeriesTagScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutTagsInput = {
    create?: XOR<MovieCreateWithoutTagsInput, MovieUncheckedCreateWithoutTagsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutTagsInput
    connect?: MovieWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutMovieTagsInput = {
    create?: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMovieTagsInput
    connect?: TagWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<MovieCreateWithoutTagsInput, MovieUncheckedCreateWithoutTagsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutTagsInput
    upsert?: MovieUpsertWithoutTagsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutTagsInput, MovieUpdateWithoutTagsInput>, MovieUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutMovieTagsNestedInput = {
    create?: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutMovieTagsInput
    upsert?: TagUpsertWithoutMovieTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutMovieTagsInput, TagUpdateWithoutMovieTagsInput>, TagUncheckedUpdateWithoutMovieTagsInput>
  }

  export type SeriesCreateNestedOneWithoutTagsInput = {
    create?: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutTagsInput
    connect?: SeriesWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutSeriesTagsInput = {
    create?: XOR<TagCreateWithoutSeriesTagsInput, TagUncheckedCreateWithoutSeriesTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutSeriesTagsInput
    connect?: TagWhereUniqueInput
  }

  export type SeriesUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutTagsInput
    upsert?: SeriesUpsertWithoutTagsInput
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutTagsInput, SeriesUpdateWithoutTagsInput>, SeriesUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutSeriesTagsNestedInput = {
    create?: XOR<TagCreateWithoutSeriesTagsInput, TagUncheckedCreateWithoutSeriesTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutSeriesTagsInput
    upsert?: TagUpsertWithoutSeriesTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutSeriesTagsInput, TagUpdateWithoutSeriesTagsInput>, TagUncheckedUpdateWithoutSeriesTagsInput>
  }

  export type VideoFileCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<VideoFileCreateWithoutSubtitlesInput, VideoFileUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutSubtitlesInput
    connect?: VideoFileWhereUniqueInput
  }

  export type VideoMetadataCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<VideoMetadataCreateWithoutSubtitlesInput, VideoMetadataUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutSubtitlesInput
    connect?: VideoMetadataWhereUniqueInput
  }

  export type VideoFileUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<VideoFileCreateWithoutSubtitlesInput, VideoFileUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutSubtitlesInput
    upsert?: VideoFileUpsertWithoutSubtitlesInput
    connect?: VideoFileWhereUniqueInput
    update?: XOR<XOR<VideoFileUpdateToOneWithWhereWithoutSubtitlesInput, VideoFileUpdateWithoutSubtitlesInput>, VideoFileUncheckedUpdateWithoutSubtitlesInput>
  }

  export type VideoMetadataUpdateOneWithoutSubtitlesNestedInput = {
    create?: XOR<VideoMetadataCreateWithoutSubtitlesInput, VideoMetadataUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: VideoMetadataCreateOrConnectWithoutSubtitlesInput
    upsert?: VideoMetadataUpsertWithoutSubtitlesInput
    disconnect?: VideoMetadataWhereInput | boolean
    delete?: VideoMetadataWhereInput | boolean
    connect?: VideoMetadataWhereUniqueInput
    update?: XOR<XOR<VideoMetadataUpdateToOneWithWhereWithoutSubtitlesInput, VideoMetadataUpdateWithoutSubtitlesInput>, VideoMetadataUncheckedUpdateWithoutSubtitlesInput>
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type VideoFileCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<VideoFileCreateWithoutPurchasesInput, VideoFileUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutPurchasesInput
    connect?: VideoFileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type VideoFileUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<VideoFileCreateWithoutPurchasesInput, VideoFileUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutPurchasesInput
    upsert?: VideoFileUpsertWithoutPurchasesInput
    connect?: VideoFileWhereUniqueInput
    update?: XOR<XOR<VideoFileUpdateToOneWithWhereWithoutPurchasesInput, VideoFileUpdateWithoutPurchasesInput>, VideoFileUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserCreateNestedOneWithoutViewsInput = {
    create?: XOR<UserCreateWithoutViewsInput, UserUncheckedCreateWithoutViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewsInput
    connect?: UserWhereUniqueInput
  }

  export type SharedAccountUserCreateNestedOneWithoutViewsInput = {
    create?: XOR<SharedAccountUserCreateWithoutViewsInput, SharedAccountUserUncheckedCreateWithoutViewsInput>
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutViewsInput
    connect?: SharedAccountUserWhereUniqueInput
  }

  export type VideoFileCreateNestedOneWithoutViewsInput = {
    create?: XOR<VideoFileCreateWithoutViewsInput, VideoFileUncheckedCreateWithoutViewsInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutViewsInput
    connect?: VideoFileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<UserCreateWithoutViewsInput, UserUncheckedCreateWithoutViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewsInput
    upsert?: UserUpsertWithoutViewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewsInput, UserUpdateWithoutViewsInput>, UserUncheckedUpdateWithoutViewsInput>
  }

  export type SharedAccountUserUpdateOneWithoutViewsNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutViewsInput, SharedAccountUserUncheckedCreateWithoutViewsInput>
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutViewsInput
    upsert?: SharedAccountUserUpsertWithoutViewsInput
    disconnect?: SharedAccountUserWhereInput | boolean
    delete?: SharedAccountUserWhereInput | boolean
    connect?: SharedAccountUserWhereUniqueInput
    update?: XOR<XOR<SharedAccountUserUpdateToOneWithWhereWithoutViewsInput, SharedAccountUserUpdateWithoutViewsInput>, SharedAccountUserUncheckedUpdateWithoutViewsInput>
  }

  export type VideoFileUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<VideoFileCreateWithoutViewsInput, VideoFileUncheckedCreateWithoutViewsInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutViewsInput
    upsert?: VideoFileUpsertWithoutViewsInput
    connect?: VideoFileWhereUniqueInput
    update?: XOR<XOR<VideoFileUpdateToOneWithWhereWithoutViewsInput, VideoFileUpdateWithoutViewsInput>, VideoFileUncheckedUpdateWithoutViewsInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoFileCreateNestedOneWithoutCommentsInput = {
    create?: XOR<VideoFileCreateWithoutCommentsInput, VideoFileUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutCommentsInput
    connect?: VideoFileWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type VideoFileUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<VideoFileCreateWithoutCommentsInput, VideoFileUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoFileCreateOrConnectWithoutCommentsInput
    upsert?: VideoFileUpsertWithoutCommentsInput
    connect?: VideoFileWhereUniqueInput
    update?: XOR<XOR<VideoFileUpdateToOneWithWhereWithoutCommentsInput, VideoFileUpdateWithoutCommentsInput>, VideoFileUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AdViewCreateNestedManyWithoutAdInput = {
    create?: XOR<AdViewCreateWithoutAdInput, AdViewUncheckedCreateWithoutAdInput> | AdViewCreateWithoutAdInput[] | AdViewUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutAdInput | AdViewCreateOrConnectWithoutAdInput[]
    createMany?: AdViewCreateManyAdInputEnvelope
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
  }

  export type AdViewUncheckedCreateNestedManyWithoutAdInput = {
    create?: XOR<AdViewCreateWithoutAdInput, AdViewUncheckedCreateWithoutAdInput> | AdViewCreateWithoutAdInput[] | AdViewUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutAdInput | AdViewCreateOrConnectWithoutAdInput[]
    createMany?: AdViewCreateManyAdInputEnvelope
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
  }

  export type AdViewUpdateManyWithoutAdNestedInput = {
    create?: XOR<AdViewCreateWithoutAdInput, AdViewUncheckedCreateWithoutAdInput> | AdViewCreateWithoutAdInput[] | AdViewUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutAdInput | AdViewCreateOrConnectWithoutAdInput[]
    upsert?: AdViewUpsertWithWhereUniqueWithoutAdInput | AdViewUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: AdViewCreateManyAdInputEnvelope
    set?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    disconnect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    delete?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    update?: AdViewUpdateWithWhereUniqueWithoutAdInput | AdViewUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: AdViewUpdateManyWithWhereWithoutAdInput | AdViewUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
  }

  export type AdViewUncheckedUpdateManyWithoutAdNestedInput = {
    create?: XOR<AdViewCreateWithoutAdInput, AdViewUncheckedCreateWithoutAdInput> | AdViewCreateWithoutAdInput[] | AdViewUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdViewCreateOrConnectWithoutAdInput | AdViewCreateOrConnectWithoutAdInput[]
    upsert?: AdViewUpsertWithWhereUniqueWithoutAdInput | AdViewUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: AdViewCreateManyAdInputEnvelope
    set?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    disconnect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    delete?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    connect?: AdViewWhereUniqueInput | AdViewWhereUniqueInput[]
    update?: AdViewUpdateWithWhereUniqueWithoutAdInput | AdViewUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: AdViewUpdateManyWithWhereWithoutAdInput | AdViewUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
  }

  export type AdCreateNestedOneWithoutViewsInput = {
    create?: XOR<AdCreateWithoutViewsInput, AdUncheckedCreateWithoutViewsInput>
    connectOrCreate?: AdCreateOrConnectWithoutViewsInput
    connect?: AdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdViewsInput = {
    create?: XOR<UserCreateWithoutAdViewsInput, UserUncheckedCreateWithoutAdViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdViewsInput
    connect?: UserWhereUniqueInput
  }

  export type SharedAccountUserCreateNestedOneWithoutAdViewsInput = {
    create?: XOR<SharedAccountUserCreateWithoutAdViewsInput, SharedAccountUserUncheckedCreateWithoutAdViewsInput>
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutAdViewsInput
    connect?: SharedAccountUserWhereUniqueInput
  }

  export type AdUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<AdCreateWithoutViewsInput, AdUncheckedCreateWithoutViewsInput>
    connectOrCreate?: AdCreateOrConnectWithoutViewsInput
    upsert?: AdUpsertWithoutViewsInput
    connect?: AdWhereUniqueInput
    update?: XOR<XOR<AdUpdateToOneWithWhereWithoutViewsInput, AdUpdateWithoutViewsInput>, AdUncheckedUpdateWithoutViewsInput>
  }

  export type UserUpdateOneWithoutAdViewsNestedInput = {
    create?: XOR<UserCreateWithoutAdViewsInput, UserUncheckedCreateWithoutAdViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdViewsInput
    upsert?: UserUpsertWithoutAdViewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdViewsInput, UserUpdateWithoutAdViewsInput>, UserUncheckedUpdateWithoutAdViewsInput>
  }

  export type SharedAccountUserUpdateOneWithoutAdViewsNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutAdViewsInput, SharedAccountUserUncheckedCreateWithoutAdViewsInput>
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutAdViewsInput
    upsert?: SharedAccountUserUpsertWithoutAdViewsInput
    disconnect?: SharedAccountUserWhereInput | boolean
    delete?: SharedAccountUserWhereInput | boolean
    connect?: SharedAccountUserWhereUniqueInput
    update?: XOR<XOR<SharedAccountUserUpdateToOneWithWhereWithoutAdViewsInput, SharedAccountUserUpdateWithoutAdViewsInput>, SharedAccountUserUncheckedUpdateWithoutAdViewsInput>
  }

  export type SharedAccountUserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<SharedAccountUserCreateWithoutActivitiesInput, SharedAccountUserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutActivitiesInput
    connect?: SharedAccountUserWhereUniqueInput
  }

  export type EnumProfileActivityActionFieldUpdateOperationsInput = {
    set?: $Enums.ProfileActivityAction
  }

  export type SharedAccountUserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<SharedAccountUserCreateWithoutActivitiesInput, SharedAccountUserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: SharedAccountUserCreateOrConnectWithoutActivitiesInput
    upsert?: SharedAccountUserUpsertWithoutActivitiesInput
    connect?: SharedAccountUserWhereUniqueInput
    update?: XOR<XOR<SharedAccountUserUpdateToOneWithWhereWithoutActivitiesInput, SharedAccountUserUpdateWithoutActivitiesInput>, SharedAccountUserUncheckedUpdateWithoutActivitiesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVideoQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityFilter<$PrismaModel> | $Enums.VideoQuality
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumVideoQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityWithAggregatesFilter<$PrismaModel> | $Enums.VideoQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoQualityFilter<$PrismaModel>
    _max?: NestedEnumVideoQualityFilter<$PrismaModel>
  }

  export type NestedEnumRenewalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalStatus | EnumRenewalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalStatusFilter<$PrismaModel> | $Enums.RenewalStatus
  }

  export type NestedEnumRenewalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalStatus | EnumRenewalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalStatus[] | ListEnumRenewalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalStatusWithAggregatesFilter<$PrismaModel> | $Enums.RenewalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRenewalStatusFilter<$PrismaModel>
    _max?: NestedEnumRenewalStatusFilter<$PrismaModel>
  }

  export type NestedEnumSharedAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SharedAccountStatus | EnumSharedAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSharedAccountStatusFilter<$PrismaModel> | $Enums.SharedAccountStatus
  }

  export type NestedEnumSharedAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SharedAccountStatus | EnumSharedAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharedAccountStatus[] | ListEnumSharedAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSharedAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.SharedAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSharedAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumSharedAccountStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumProfileActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileActivityAction | EnumProfileActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileActivityActionFilter<$PrismaModel> | $Enums.ProfileActivityAction
  }

  export type NestedEnumProfileActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileActivityAction | EnumProfileActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileActivityAction[] | ListEnumProfileActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.ProfileActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileActivityActionFilter<$PrismaModel>
    _max?: NestedEnumProfileActivityActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    sharedAccounts?: SharedAccountCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    sharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedAccountCreateWithoutOwnerInput = {
    id?: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    sharedUser?: UserCreateNestedOneWithoutSharedAccountInput
    subscription: SubscriptionCreateNestedOneWithoutSharedAccountsInput
    profiles?: SharedAccountUserCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountUncheckedCreateWithoutOwnerInput = {
    id?: string
    sharedUserId?: string | null
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    profiles?: SharedAccountUserUncheckedCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountCreateOrConnectWithoutOwnerInput = {
    where: SharedAccountWhereUniqueInput
    create: XOR<SharedAccountCreateWithoutOwnerInput, SharedAccountUncheckedCreateWithoutOwnerInput>
  }

  export type SharedAccountCreateManyOwnerInputEnvelope = {
    data: SharedAccountCreateManyOwnerInput | SharedAccountCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type SharedAccountUserCreateWithoutUserInput = {
    id?: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    sharedAccount: SharedAccountCreateNestedOneWithoutProfilesInput
    views?: ViewCreateNestedManyWithoutProfileInput
    adViews?: AdViewCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUncheckedCreateWithoutUserInput = {
    id?: string
    sharedAccountId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    views?: ViewUncheckedCreateNestedManyWithoutProfileInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityUncheckedCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserCreateOrConnectWithoutUserInput = {
    where: SharedAccountUserWhereUniqueInput
    create: XOR<SharedAccountUserCreateWithoutUserInput, SharedAccountUserUncheckedCreateWithoutUserInput>
  }

  export type SharedAccountUserCreateManyUserInputEnvelope = {
    data: SharedAccountUserCreateManyUserInput | SharedAccountUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutUserInput = {
    id?: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
    video: VideoFileCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutUserInput = {
    id?: string
    videoId: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
  }

  export type PurchaseCreateOrConnectWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseCreateManyUserInputEnvelope = {
    data: PurchaseCreateManyUserInput | PurchaseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewCreateWithoutUserInput = {
    id?: string
    viewed_at?: Date | string
    progress_seconds?: number
    profile?: SharedAccountUserCreateNestedOneWithoutViewsInput
    video: VideoFileCreateNestedOneWithoutViewsInput
  }

  export type ViewUncheckedCreateWithoutUserInput = {
    id?: string
    profileId?: string | null
    videoId: string
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type ViewCreateOrConnectWithoutUserInput = {
    where: ViewWhereUniqueInput
    create: XOR<ViewCreateWithoutUserInput, ViewUncheckedCreateWithoutUserInput>
  }

  export type ViewCreateManyUserInputEnvelope = {
    data: ViewCreateManyUserInput | ViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    text: string
    created_at?: Date | string
    video: VideoFileCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    videoId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedAccountCreateWithoutSharedUserInput = {
    id?: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    owner: UserCreateNestedOneWithoutOwnedSharedAccountsInput
    subscription: SubscriptionCreateNestedOneWithoutSharedAccountsInput
    profiles?: SharedAccountUserCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountUncheckedCreateWithoutSharedUserInput = {
    id?: string
    ownerUserId: string
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    profiles?: SharedAccountUserUncheckedCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountCreateOrConnectWithoutSharedUserInput = {
    where: SharedAccountWhereUniqueInput
    create: XOR<SharedAccountCreateWithoutSharedUserInput, SharedAccountUncheckedCreateWithoutSharedUserInput>
  }

  export type SharedAccountCreateManySharedUserInputEnvelope = {
    data: SharedAccountCreateManySharedUserInput | SharedAccountCreateManySharedUserInput[]
    skipDuplicates?: boolean
  }

  export type AdViewCreateWithoutUserInput = {
    id?: string
    viewed_at?: Date | string
    ad: AdCreateNestedOneWithoutViewsInput
    profile?: SharedAccountUserCreateNestedOneWithoutAdViewsInput
  }

  export type AdViewUncheckedCreateWithoutUserInput = {
    id?: string
    adId: string
    profileId?: string | null
    viewed_at?: Date | string
  }

  export type AdViewCreateOrConnectWithoutUserInput = {
    where: AdViewWhereUniqueInput
    create: XOR<AdViewCreateWithoutUserInput, AdViewUncheckedCreateWithoutUserInput>
  }

  export type AdViewCreateManyUserInputEnvelope = {
    data: AdViewCreateManyUserInput | AdViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    start_date?: DateTimeFilter<"Subscription"> | Date | string
    end_date?: DateTimeFilter<"Subscription"> | Date | string
    renewal_status?: EnumRenewalStatusFilter<"Subscription"> | $Enums.RenewalStatus
  }

  export type SharedAccountUpsertWithWhereUniqueWithoutOwnerInput = {
    where: SharedAccountWhereUniqueInput
    update: XOR<SharedAccountUpdateWithoutOwnerInput, SharedAccountUncheckedUpdateWithoutOwnerInput>
    create: XOR<SharedAccountCreateWithoutOwnerInput, SharedAccountUncheckedCreateWithoutOwnerInput>
  }

  export type SharedAccountUpdateWithWhereUniqueWithoutOwnerInput = {
    where: SharedAccountWhereUniqueInput
    data: XOR<SharedAccountUpdateWithoutOwnerInput, SharedAccountUncheckedUpdateWithoutOwnerInput>
  }

  export type SharedAccountUpdateManyWithWhereWithoutOwnerInput = {
    where: SharedAccountScalarWhereInput
    data: XOR<SharedAccountUpdateManyMutationInput, SharedAccountUncheckedUpdateManyWithoutOwnerInput>
  }

  export type SharedAccountScalarWhereInput = {
    AND?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
    OR?: SharedAccountScalarWhereInput[]
    NOT?: SharedAccountScalarWhereInput | SharedAccountScalarWhereInput[]
    id?: StringFilter<"SharedAccount"> | string
    ownerUserId?: StringFilter<"SharedAccount"> | string
    sharedUserId?: StringNullableFilter<"SharedAccount"> | string | null
    subscriptionId?: StringFilter<"SharedAccount"> | string
    shared_on?: DateTimeFilter<"SharedAccount"> | Date | string
    status?: EnumSharedAccountStatusFilter<"SharedAccount"> | $Enums.SharedAccountStatus
    is_active?: BoolFilter<"SharedAccount"> | boolean
  }

  export type SharedAccountUserUpsertWithWhereUniqueWithoutUserInput = {
    where: SharedAccountUserWhereUniqueInput
    update: XOR<SharedAccountUserUpdateWithoutUserInput, SharedAccountUserUncheckedUpdateWithoutUserInput>
    create: XOR<SharedAccountUserCreateWithoutUserInput, SharedAccountUserUncheckedCreateWithoutUserInput>
  }

  export type SharedAccountUserUpdateWithWhereUniqueWithoutUserInput = {
    where: SharedAccountUserWhereUniqueInput
    data: XOR<SharedAccountUserUpdateWithoutUserInput, SharedAccountUserUncheckedUpdateWithoutUserInput>
  }

  export type SharedAccountUserUpdateManyWithWhereWithoutUserInput = {
    where: SharedAccountUserScalarWhereInput
    data: XOR<SharedAccountUserUpdateManyMutationInput, SharedAccountUserUncheckedUpdateManyWithoutUserInput>
  }

  export type SharedAccountUserScalarWhereInput = {
    AND?: SharedAccountUserScalarWhereInput | SharedAccountUserScalarWhereInput[]
    OR?: SharedAccountUserScalarWhereInput[]
    NOT?: SharedAccountUserScalarWhereInput | SharedAccountUserScalarWhereInput[]
    id?: StringFilter<"SharedAccountUser"> | string
    sharedAccountId?: StringFilter<"SharedAccountUser"> | string
    userId?: StringFilter<"SharedAccountUser"> | string
    profile_name?: StringFilter<"SharedAccountUser"> | string
    is_kid_profile?: BoolFilter<"SharedAccountUser"> | boolean
    avatar_url?: StringNullableFilter<"SharedAccountUser"> | string | null
    pin_code?: StringNullableFilter<"SharedAccountUser"> | string | null
    created_at?: DateTimeFilter<"SharedAccountUser"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    videoId?: StringFilter<"Purchase"> | string
    purchase_date?: DateTimeFilter<"Purchase"> | Date | string
    expiration_date?: DateTimeNullableFilter<"Purchase"> | Date | string | null
  }

  export type ViewUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewWhereUniqueInput
    update: XOR<ViewUpdateWithoutUserInput, ViewUncheckedUpdateWithoutUserInput>
    create: XOR<ViewCreateWithoutUserInput, ViewUncheckedCreateWithoutUserInput>
  }

  export type ViewUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewWhereUniqueInput
    data: XOR<ViewUpdateWithoutUserInput, ViewUncheckedUpdateWithoutUserInput>
  }

  export type ViewUpdateManyWithWhereWithoutUserInput = {
    where: ViewScalarWhereInput
    data: XOR<ViewUpdateManyMutationInput, ViewUncheckedUpdateManyWithoutUserInput>
  }

  export type ViewScalarWhereInput = {
    AND?: ViewScalarWhereInput | ViewScalarWhereInput[]
    OR?: ViewScalarWhereInput[]
    NOT?: ViewScalarWhereInput | ViewScalarWhereInput[]
    id?: StringFilter<"View"> | string
    userId?: StringFilter<"View"> | string
    profileId?: StringNullableFilter<"View"> | string | null
    videoId?: StringFilter<"View"> | string
    viewed_at?: DateTimeFilter<"View"> | Date | string
    progress_seconds?: IntFilter<"View"> | number
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    videoId?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
  }

  export type SharedAccountUpsertWithWhereUniqueWithoutSharedUserInput = {
    where: SharedAccountWhereUniqueInput
    update: XOR<SharedAccountUpdateWithoutSharedUserInput, SharedAccountUncheckedUpdateWithoutSharedUserInput>
    create: XOR<SharedAccountCreateWithoutSharedUserInput, SharedAccountUncheckedCreateWithoutSharedUserInput>
  }

  export type SharedAccountUpdateWithWhereUniqueWithoutSharedUserInput = {
    where: SharedAccountWhereUniqueInput
    data: XOR<SharedAccountUpdateWithoutSharedUserInput, SharedAccountUncheckedUpdateWithoutSharedUserInput>
  }

  export type SharedAccountUpdateManyWithWhereWithoutSharedUserInput = {
    where: SharedAccountScalarWhereInput
    data: XOR<SharedAccountUpdateManyMutationInput, SharedAccountUncheckedUpdateManyWithoutSharedUserInput>
  }

  export type AdViewUpsertWithWhereUniqueWithoutUserInput = {
    where: AdViewWhereUniqueInput
    update: XOR<AdViewUpdateWithoutUserInput, AdViewUncheckedUpdateWithoutUserInput>
    create: XOR<AdViewCreateWithoutUserInput, AdViewUncheckedCreateWithoutUserInput>
  }

  export type AdViewUpdateWithWhereUniqueWithoutUserInput = {
    where: AdViewWhereUniqueInput
    data: XOR<AdViewUpdateWithoutUserInput, AdViewUncheckedUpdateWithoutUserInput>
  }

  export type AdViewUpdateManyWithWhereWithoutUserInput = {
    where: AdViewScalarWhereInput
    data: XOR<AdViewUpdateManyMutationInput, AdViewUncheckedUpdateManyWithoutUserInput>
  }

  export type AdViewScalarWhereInput = {
    AND?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
    OR?: AdViewScalarWhereInput[]
    NOT?: AdViewScalarWhereInput | AdViewScalarWhereInput[]
    id?: StringFilter<"AdView"> | string
    adId?: StringFilter<"AdView"> | string
    userId?: StringNullableFilter<"AdView"> | string | null
    profileId?: StringNullableFilter<"AdView"> | string | null
    viewed_at?: DateTimeFilter<"AdView"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    user: UserCreateNestedOneWithoutSubscriptionsInput
    sharedAccounts?: SharedAccountCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    sharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: number
    maxSharedAccounts?: number
    videoQuality: $Enums.VideoQuality
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: number
    maxSharedAccounts?: number
    videoQuality: $Enums.VideoQuality
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SharedAccountCreateWithoutSubscriptionInput = {
    id?: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    owner: UserCreateNestedOneWithoutOwnedSharedAccountsInput
    sharedUser?: UserCreateNestedOneWithoutSharedAccountInput
    profiles?: SharedAccountUserCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    ownerUserId: string
    sharedUserId?: string | null
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    profiles?: SharedAccountUserUncheckedCreateNestedManyWithoutSharedAccountInput
  }

  export type SharedAccountCreateOrConnectWithoutSubscriptionInput = {
    where: SharedAccountWhereUniqueInput
    create: XOR<SharedAccountCreateWithoutSubscriptionInput, SharedAccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type SharedAccountCreateManySubscriptionInputEnvelope = {
    data: SharedAccountCreateManySubscriptionInput | SharedAccountCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxSharedAccounts?: IntFieldUpdateOperationsInput | number
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxSharedAccounts?: IntFieldUpdateOperationsInput | number
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
  }

  export type SharedAccountUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SharedAccountWhereUniqueInput
    update: XOR<SharedAccountUpdateWithoutSubscriptionInput, SharedAccountUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SharedAccountCreateWithoutSubscriptionInput, SharedAccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type SharedAccountUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SharedAccountWhereUniqueInput
    data: XOR<SharedAccountUpdateWithoutSubscriptionInput, SharedAccountUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SharedAccountUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SharedAccountScalarWhereInput
    data: XOR<SharedAccountUpdateManyMutationInput, SharedAccountUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserCreateWithoutOwnedSharedAccountsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedSharedAccountsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedSharedAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedSharedAccountsInput, UserUncheckedCreateWithoutOwnedSharedAccountsInput>
  }

  export type UserCreateWithoutSharedAccountInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedAccountInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedAccountInput, UserUncheckedCreateWithoutSharedAccountInput>
  }

  export type SubscriptionCreateWithoutSharedAccountsInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutSharedAccountsInput = {
    id?: string
    userId: string
    planId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
  }

  export type SubscriptionCreateOrConnectWithoutSharedAccountsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutSharedAccountsInput, SubscriptionUncheckedCreateWithoutSharedAccountsInput>
  }

  export type SharedAccountUserCreateWithoutSharedAccountInput = {
    id?: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    user: UserCreateNestedOneWithoutSharedProfilesInput
    views?: ViewCreateNestedManyWithoutProfileInput
    adViews?: AdViewCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUncheckedCreateWithoutSharedAccountInput = {
    id?: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    views?: ViewUncheckedCreateNestedManyWithoutProfileInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityUncheckedCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserCreateOrConnectWithoutSharedAccountInput = {
    where: SharedAccountUserWhereUniqueInput
    create: XOR<SharedAccountUserCreateWithoutSharedAccountInput, SharedAccountUserUncheckedCreateWithoutSharedAccountInput>
  }

  export type SharedAccountUserCreateManySharedAccountInputEnvelope = {
    data: SharedAccountUserCreateManySharedAccountInput | SharedAccountUserCreateManySharedAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedSharedAccountsInput = {
    update: XOR<UserUpdateWithoutOwnedSharedAccountsInput, UserUncheckedUpdateWithoutOwnedSharedAccountsInput>
    create: XOR<UserCreateWithoutOwnedSharedAccountsInput, UserUncheckedCreateWithoutOwnedSharedAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedSharedAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedSharedAccountsInput, UserUncheckedUpdateWithoutOwnedSharedAccountsInput>
  }

  export type UserUpdateWithoutOwnedSharedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedSharedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSharedAccountInput = {
    update: XOR<UserUpdateWithoutSharedAccountInput, UserUncheckedUpdateWithoutSharedAccountInput>
    create: XOR<UserCreateWithoutSharedAccountInput, UserUncheckedCreateWithoutSharedAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedAccountInput, UserUncheckedUpdateWithoutSharedAccountInput>
  }

  export type UserUpdateWithoutSharedAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutSharedAccountsInput = {
    update: XOR<SubscriptionUpdateWithoutSharedAccountsInput, SubscriptionUncheckedUpdateWithoutSharedAccountsInput>
    create: XOR<SubscriptionCreateWithoutSharedAccountsInput, SubscriptionUncheckedCreateWithoutSharedAccountsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutSharedAccountsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutSharedAccountsInput, SubscriptionUncheckedUpdateWithoutSharedAccountsInput>
  }

  export type SubscriptionUpdateWithoutSharedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutSharedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
  }

  export type SharedAccountUserUpsertWithWhereUniqueWithoutSharedAccountInput = {
    where: SharedAccountUserWhereUniqueInput
    update: XOR<SharedAccountUserUpdateWithoutSharedAccountInput, SharedAccountUserUncheckedUpdateWithoutSharedAccountInput>
    create: XOR<SharedAccountUserCreateWithoutSharedAccountInput, SharedAccountUserUncheckedCreateWithoutSharedAccountInput>
  }

  export type SharedAccountUserUpdateWithWhereUniqueWithoutSharedAccountInput = {
    where: SharedAccountUserWhereUniqueInput
    data: XOR<SharedAccountUserUpdateWithoutSharedAccountInput, SharedAccountUserUncheckedUpdateWithoutSharedAccountInput>
  }

  export type SharedAccountUserUpdateManyWithWhereWithoutSharedAccountInput = {
    where: SharedAccountUserScalarWhereInput
    data: XOR<SharedAccountUserUpdateManyMutationInput, SharedAccountUserUncheckedUpdateManyWithoutSharedAccountInput>
  }

  export type SharedAccountCreateWithoutProfilesInput = {
    id?: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
    owner: UserCreateNestedOneWithoutOwnedSharedAccountsInput
    sharedUser?: UserCreateNestedOneWithoutSharedAccountInput
    subscription: SubscriptionCreateNestedOneWithoutSharedAccountsInput
  }

  export type SharedAccountUncheckedCreateWithoutProfilesInput = {
    id?: string
    ownerUserId: string
    sharedUserId?: string | null
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
  }

  export type SharedAccountCreateOrConnectWithoutProfilesInput = {
    where: SharedAccountWhereUniqueInput
    create: XOR<SharedAccountCreateWithoutProfilesInput, SharedAccountUncheckedCreateWithoutProfilesInput>
  }

  export type UserCreateWithoutSharedProfilesInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedProfilesInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedProfilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedProfilesInput, UserUncheckedCreateWithoutSharedProfilesInput>
  }

  export type ViewCreateWithoutProfileInput = {
    id?: string
    viewed_at?: Date | string
    progress_seconds?: number
    user: UserCreateNestedOneWithoutViewsInput
    video: VideoFileCreateNestedOneWithoutViewsInput
  }

  export type ViewUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    videoId: string
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type ViewCreateOrConnectWithoutProfileInput = {
    where: ViewWhereUniqueInput
    create: XOR<ViewCreateWithoutProfileInput, ViewUncheckedCreateWithoutProfileInput>
  }

  export type ViewCreateManyProfileInputEnvelope = {
    data: ViewCreateManyProfileInput | ViewCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type AdViewCreateWithoutProfileInput = {
    id?: string
    viewed_at?: Date | string
    ad: AdCreateNestedOneWithoutViewsInput
    user?: UserCreateNestedOneWithoutAdViewsInput
  }

  export type AdViewUncheckedCreateWithoutProfileInput = {
    id?: string
    adId: string
    userId?: string | null
    viewed_at?: Date | string
  }

  export type AdViewCreateOrConnectWithoutProfileInput = {
    where: AdViewWhereUniqueInput
    create: XOR<AdViewCreateWithoutProfileInput, AdViewUncheckedCreateWithoutProfileInput>
  }

  export type AdViewCreateManyProfileInputEnvelope = {
    data: AdViewCreateManyProfileInput | AdViewCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type SharedProfileActivityCreateWithoutProfileInput = {
    id?: string
    action: $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: Date | string
  }

  export type SharedProfileActivityUncheckedCreateWithoutProfileInput = {
    id?: string
    action: $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: Date | string
  }

  export type SharedProfileActivityCreateOrConnectWithoutProfileInput = {
    where: SharedProfileActivityWhereUniqueInput
    create: XOR<SharedProfileActivityCreateWithoutProfileInput, SharedProfileActivityUncheckedCreateWithoutProfileInput>
  }

  export type SharedProfileActivityCreateManyProfileInputEnvelope = {
    data: SharedProfileActivityCreateManyProfileInput | SharedProfileActivityCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type SharedAccountUpsertWithoutProfilesInput = {
    update: XOR<SharedAccountUpdateWithoutProfilesInput, SharedAccountUncheckedUpdateWithoutProfilesInput>
    create: XOR<SharedAccountCreateWithoutProfilesInput, SharedAccountUncheckedCreateWithoutProfilesInput>
    where?: SharedAccountWhereInput
  }

  export type SharedAccountUpdateToOneWithWhereWithoutProfilesInput = {
    where?: SharedAccountWhereInput
    data: XOR<SharedAccountUpdateWithoutProfilesInput, SharedAccountUncheckedUpdateWithoutProfilesInput>
  }

  export type SharedAccountUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneRequiredWithoutOwnedSharedAccountsNestedInput
    sharedUser?: UserUpdateOneWithoutSharedAccountNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSharedAccountsNestedInput
  }

  export type SharedAccountUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutSharedProfilesInput = {
    update: XOR<UserUpdateWithoutSharedProfilesInput, UserUncheckedUpdateWithoutSharedProfilesInput>
    create: XOR<UserCreateWithoutSharedProfilesInput, UserUncheckedCreateWithoutSharedProfilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedProfilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedProfilesInput, UserUncheckedUpdateWithoutSharedProfilesInput>
  }

  export type UserUpdateWithoutSharedProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ViewUpsertWithWhereUniqueWithoutProfileInput = {
    where: ViewWhereUniqueInput
    update: XOR<ViewUpdateWithoutProfileInput, ViewUncheckedUpdateWithoutProfileInput>
    create: XOR<ViewCreateWithoutProfileInput, ViewUncheckedCreateWithoutProfileInput>
  }

  export type ViewUpdateWithWhereUniqueWithoutProfileInput = {
    where: ViewWhereUniqueInput
    data: XOR<ViewUpdateWithoutProfileInput, ViewUncheckedUpdateWithoutProfileInput>
  }

  export type ViewUpdateManyWithWhereWithoutProfileInput = {
    where: ViewScalarWhereInput
    data: XOR<ViewUpdateManyMutationInput, ViewUncheckedUpdateManyWithoutProfileInput>
  }

  export type AdViewUpsertWithWhereUniqueWithoutProfileInput = {
    where: AdViewWhereUniqueInput
    update: XOR<AdViewUpdateWithoutProfileInput, AdViewUncheckedUpdateWithoutProfileInput>
    create: XOR<AdViewCreateWithoutProfileInput, AdViewUncheckedCreateWithoutProfileInput>
  }

  export type AdViewUpdateWithWhereUniqueWithoutProfileInput = {
    where: AdViewWhereUniqueInput
    data: XOR<AdViewUpdateWithoutProfileInput, AdViewUncheckedUpdateWithoutProfileInput>
  }

  export type AdViewUpdateManyWithWhereWithoutProfileInput = {
    where: AdViewScalarWhereInput
    data: XOR<AdViewUpdateManyMutationInput, AdViewUncheckedUpdateManyWithoutProfileInput>
  }

  export type SharedProfileActivityUpsertWithWhereUniqueWithoutProfileInput = {
    where: SharedProfileActivityWhereUniqueInput
    update: XOR<SharedProfileActivityUpdateWithoutProfileInput, SharedProfileActivityUncheckedUpdateWithoutProfileInput>
    create: XOR<SharedProfileActivityCreateWithoutProfileInput, SharedProfileActivityUncheckedCreateWithoutProfileInput>
  }

  export type SharedProfileActivityUpdateWithWhereUniqueWithoutProfileInput = {
    where: SharedProfileActivityWhereUniqueInput
    data: XOR<SharedProfileActivityUpdateWithoutProfileInput, SharedProfileActivityUncheckedUpdateWithoutProfileInput>
  }

  export type SharedProfileActivityUpdateManyWithWhereWithoutProfileInput = {
    where: SharedProfileActivityScalarWhereInput
    data: XOR<SharedProfileActivityUpdateManyMutationInput, SharedProfileActivityUncheckedUpdateManyWithoutProfileInput>
  }

  export type SharedProfileActivityScalarWhereInput = {
    AND?: SharedProfileActivityScalarWhereInput | SharedProfileActivityScalarWhereInput[]
    OR?: SharedProfileActivityScalarWhereInput[]
    NOT?: SharedProfileActivityScalarWhereInput | SharedProfileActivityScalarWhereInput[]
    id?: StringFilter<"SharedProfileActivity"> | string
    profileId?: StringFilter<"SharedProfileActivity"> | string
    action?: EnumProfileActivityActionFilter<"SharedProfileActivity"> | $Enums.ProfileActivityAction
    details?: JsonNullableFilter<"SharedProfileActivity">
    performed_at?: DateTimeFilter<"SharedProfileActivity"> | Date | string
  }

  export type VideoFormatCreateWithoutVideosInput = {
    id?: string
    format: string
    description?: string | null
  }

  export type VideoFormatUncheckedCreateWithoutVideosInput = {
    id?: string
    format: string
    description?: string | null
  }

  export type VideoFormatCreateOrConnectWithoutVideosInput = {
    where: VideoFormatWhereUniqueInput
    create: XOR<VideoFormatCreateWithoutVideosInput, VideoFormatUncheckedCreateWithoutVideosInput>
  }

  export type VideoCategoryCreateWithoutVideosInput = {
    id?: string
    category: string
    description?: string | null
  }

  export type VideoCategoryUncheckedCreateWithoutVideosInput = {
    id?: string
    category: string
    description?: string | null
  }

  export type VideoCategoryCreateOrConnectWithoutVideosInput = {
    where: VideoCategoryWhereUniqueInput
    create: XOR<VideoCategoryCreateWithoutVideosInput, VideoCategoryUncheckedCreateWithoutVideosInput>
  }

  export type MovieCreateWithoutMetadataInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    videoFile: VideoFileCreateNestedOneWithoutMovieInput
    tags?: MovieTagCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMetadataInput = {
    id?: string
    videoFileId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    tags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMetadataInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMetadataInput, MovieUncheckedCreateWithoutMetadataInput>
  }

  export type EpisodeCreateWithoutMetadataInput = {
    id?: string
    number: number
    season: SeasonCreateNestedOneWithoutEpisodesInput
    videoFile: VideoFileCreateNestedOneWithoutEpisodeInput
  }

  export type EpisodeUncheckedCreateWithoutMetadataInput = {
    id?: string
    seasonId: string
    number: number
    videoFileId: string
  }

  export type EpisodeCreateOrConnectWithoutMetadataInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutMetadataInput, EpisodeUncheckedCreateWithoutMetadataInput>
  }

  export type SeriesCreateWithoutMetadataInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    seasons?: SeasonCreateNestedManyWithoutSeriesInput
    tags?: SeriesTagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutMetadataInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    seasons?: SeasonUncheckedCreateNestedManyWithoutSeriesInput
    tags?: SeriesTagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutMetadataInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutMetadataInput, SeriesUncheckedCreateWithoutMetadataInput>
  }

  export type VideoGenreCreateWithoutVideosInput = {
    id?: string
    name: string
  }

  export type VideoGenreUncheckedCreateWithoutVideosInput = {
    id?: string
    name: string
  }

  export type VideoGenreCreateOrConnectWithoutVideosInput = {
    where: VideoGenreWhereUniqueInput
    create: XOR<VideoGenreCreateWithoutVideosInput, VideoGenreUncheckedCreateWithoutVideosInput>
  }

  export type VideoActorCreateWithoutVideoInput = {
    role?: string | null
    actor: ActorCreateNestedOneWithoutVideoActorInput
  }

  export type VideoActorUncheckedCreateWithoutVideoInput = {
    actorId: string
    role?: string | null
  }

  export type VideoActorCreateOrConnectWithoutVideoInput = {
    where: VideoActorWhereUniqueInput
    create: XOR<VideoActorCreateWithoutVideoInput, VideoActorUncheckedCreateWithoutVideoInput>
  }

  export type VideoActorCreateManyVideoInputEnvelope = {
    data: VideoActorCreateManyVideoInput | VideoActorCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type SubtitleCreateWithoutVideoMetadataInput = {
    language: string
    subtitle_url: string
    video: VideoFileCreateNestedOneWithoutSubtitlesInput
  }

  export type SubtitleUncheckedCreateWithoutVideoMetadataInput = {
    videoId: string
    language: string
    subtitle_url: string
  }

  export type SubtitleCreateOrConnectWithoutVideoMetadataInput = {
    where: SubtitleWhereUniqueInput
    create: XOR<SubtitleCreateWithoutVideoMetadataInput, SubtitleUncheckedCreateWithoutVideoMetadataInput>
  }

  export type SubtitleCreateManyVideoMetadataInputEnvelope = {
    data: SubtitleCreateManyVideoMetadataInput | SubtitleCreateManyVideoMetadataInput[]
    skipDuplicates?: boolean
  }

  export type VideoLanguageCreateWithoutVideosInput = {
    id?: string
    code: string
    name: string
  }

  export type VideoLanguageUncheckedCreateWithoutVideosInput = {
    id?: string
    code: string
    name: string
  }

  export type VideoLanguageCreateOrConnectWithoutVideosInput = {
    where: VideoLanguageWhereUniqueInput
    create: XOR<VideoLanguageCreateWithoutVideosInput, VideoLanguageUncheckedCreateWithoutVideosInput>
  }

  export type VideoFormatUpsertWithoutVideosInput = {
    update: XOR<VideoFormatUpdateWithoutVideosInput, VideoFormatUncheckedUpdateWithoutVideosInput>
    create: XOR<VideoFormatCreateWithoutVideosInput, VideoFormatUncheckedCreateWithoutVideosInput>
    where?: VideoFormatWhereInput
  }

  export type VideoFormatUpdateToOneWithWhereWithoutVideosInput = {
    where?: VideoFormatWhereInput
    data: XOR<VideoFormatUpdateWithoutVideosInput, VideoFormatUncheckedUpdateWithoutVideosInput>
  }

  export type VideoFormatUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoFormatUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoCategoryUpsertWithoutVideosInput = {
    update: XOR<VideoCategoryUpdateWithoutVideosInput, VideoCategoryUncheckedUpdateWithoutVideosInput>
    create: XOR<VideoCategoryCreateWithoutVideosInput, VideoCategoryUncheckedCreateWithoutVideosInput>
    where?: VideoCategoryWhereInput
  }

  export type VideoCategoryUpdateToOneWithWhereWithoutVideosInput = {
    where?: VideoCategoryWhereInput
    data: XOR<VideoCategoryUpdateWithoutVideosInput, VideoCategoryUncheckedUpdateWithoutVideosInput>
  }

  export type VideoCategoryUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoCategoryUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovieUpsertWithoutMetadataInput = {
    update: XOR<MovieUpdateWithoutMetadataInput, MovieUncheckedUpdateWithoutMetadataInput>
    create: XOR<MovieCreateWithoutMetadataInput, MovieUncheckedCreateWithoutMetadataInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMetadataInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMetadataInput, MovieUncheckedUpdateWithoutMetadataInput>
  }

  export type MovieUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    videoFile?: VideoFileUpdateOneRequiredWithoutMovieNestedInput
    tags?: MovieTagUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoFileId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type EpisodeUpsertWithoutMetadataInput = {
    update: XOR<EpisodeUpdateWithoutMetadataInput, EpisodeUncheckedUpdateWithoutMetadataInput>
    create: XOR<EpisodeCreateWithoutMetadataInput, EpisodeUncheckedCreateWithoutMetadataInput>
    where?: EpisodeWhereInput
  }

  export type EpisodeUpdateToOneWithWhereWithoutMetadataInput = {
    where?: EpisodeWhereInput
    data: XOR<EpisodeUpdateWithoutMetadataInput, EpisodeUncheckedUpdateWithoutMetadataInput>
  }

  export type EpisodeUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneRequiredWithoutEpisodesNestedInput
    videoFile?: VideoFileUpdateOneRequiredWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    videoFileId?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesUpsertWithoutMetadataInput = {
    update: XOR<SeriesUpdateWithoutMetadataInput, SeriesUncheckedUpdateWithoutMetadataInput>
    create: XOR<SeriesCreateWithoutMetadataInput, SeriesUncheckedCreateWithoutMetadataInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutMetadataInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutMetadataInput, SeriesUncheckedUpdateWithoutMetadataInput>
  }

  export type SeriesUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    seasons?: SeasonUpdateManyWithoutSeriesNestedInput
    tags?: SeriesTagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    seasons?: SeasonUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: SeriesTagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type VideoGenreUpsertWithWhereUniqueWithoutVideosInput = {
    where: VideoGenreWhereUniqueInput
    update: XOR<VideoGenreUpdateWithoutVideosInput, VideoGenreUncheckedUpdateWithoutVideosInput>
    create: XOR<VideoGenreCreateWithoutVideosInput, VideoGenreUncheckedCreateWithoutVideosInput>
  }

  export type VideoGenreUpdateWithWhereUniqueWithoutVideosInput = {
    where: VideoGenreWhereUniqueInput
    data: XOR<VideoGenreUpdateWithoutVideosInput, VideoGenreUncheckedUpdateWithoutVideosInput>
  }

  export type VideoGenreUpdateManyWithWhereWithoutVideosInput = {
    where: VideoGenreScalarWhereInput
    data: XOR<VideoGenreUpdateManyMutationInput, VideoGenreUncheckedUpdateManyWithoutVideosInput>
  }

  export type VideoGenreScalarWhereInput = {
    AND?: VideoGenreScalarWhereInput | VideoGenreScalarWhereInput[]
    OR?: VideoGenreScalarWhereInput[]
    NOT?: VideoGenreScalarWhereInput | VideoGenreScalarWhereInput[]
    id?: StringFilter<"VideoGenre"> | string
    name?: StringFilter<"VideoGenre"> | string
  }

  export type VideoActorUpsertWithWhereUniqueWithoutVideoInput = {
    where: VideoActorWhereUniqueInput
    update: XOR<VideoActorUpdateWithoutVideoInput, VideoActorUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoActorCreateWithoutVideoInput, VideoActorUncheckedCreateWithoutVideoInput>
  }

  export type VideoActorUpdateWithWhereUniqueWithoutVideoInput = {
    where: VideoActorWhereUniqueInput
    data: XOR<VideoActorUpdateWithoutVideoInput, VideoActorUncheckedUpdateWithoutVideoInput>
  }

  export type VideoActorUpdateManyWithWhereWithoutVideoInput = {
    where: VideoActorScalarWhereInput
    data: XOR<VideoActorUpdateManyMutationInput, VideoActorUncheckedUpdateManyWithoutVideoInput>
  }

  export type VideoActorScalarWhereInput = {
    AND?: VideoActorScalarWhereInput | VideoActorScalarWhereInput[]
    OR?: VideoActorScalarWhereInput[]
    NOT?: VideoActorScalarWhereInput | VideoActorScalarWhereInput[]
    videoId?: StringFilter<"VideoActor"> | string
    actorId?: StringFilter<"VideoActor"> | string
    role?: StringNullableFilter<"VideoActor"> | string | null
  }

  export type SubtitleUpsertWithWhereUniqueWithoutVideoMetadataInput = {
    where: SubtitleWhereUniqueInput
    update: XOR<SubtitleUpdateWithoutVideoMetadataInput, SubtitleUncheckedUpdateWithoutVideoMetadataInput>
    create: XOR<SubtitleCreateWithoutVideoMetadataInput, SubtitleUncheckedCreateWithoutVideoMetadataInput>
  }

  export type SubtitleUpdateWithWhereUniqueWithoutVideoMetadataInput = {
    where: SubtitleWhereUniqueInput
    data: XOR<SubtitleUpdateWithoutVideoMetadataInput, SubtitleUncheckedUpdateWithoutVideoMetadataInput>
  }

  export type SubtitleUpdateManyWithWhereWithoutVideoMetadataInput = {
    where: SubtitleScalarWhereInput
    data: XOR<SubtitleUpdateManyMutationInput, SubtitleUncheckedUpdateManyWithoutVideoMetadataInput>
  }

  export type SubtitleScalarWhereInput = {
    AND?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
    OR?: SubtitleScalarWhereInput[]
    NOT?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
    videoId?: StringFilter<"Subtitle"> | string
    language?: StringFilter<"Subtitle"> | string
    subtitle_url?: StringFilter<"Subtitle"> | string
    videoMetadataId?: StringNullableFilter<"Subtitle"> | string | null
  }

  export type VideoLanguageUpsertWithWhereUniqueWithoutVideosInput = {
    where: VideoLanguageWhereUniqueInput
    update: XOR<VideoLanguageUpdateWithoutVideosInput, VideoLanguageUncheckedUpdateWithoutVideosInput>
    create: XOR<VideoLanguageCreateWithoutVideosInput, VideoLanguageUncheckedCreateWithoutVideosInput>
  }

  export type VideoLanguageUpdateWithWhereUniqueWithoutVideosInput = {
    where: VideoLanguageWhereUniqueInput
    data: XOR<VideoLanguageUpdateWithoutVideosInput, VideoLanguageUncheckedUpdateWithoutVideosInput>
  }

  export type VideoLanguageUpdateManyWithWhereWithoutVideosInput = {
    where: VideoLanguageScalarWhereInput
    data: XOR<VideoLanguageUpdateManyMutationInput, VideoLanguageUncheckedUpdateManyWithoutVideosInput>
  }

  export type VideoLanguageScalarWhereInput = {
    AND?: VideoLanguageScalarWhereInput | VideoLanguageScalarWhereInput[]
    OR?: VideoLanguageScalarWhereInput[]
    NOT?: VideoLanguageScalarWhereInput | VideoLanguageScalarWhereInput[]
    id?: StringFilter<"VideoLanguage"> | string
    code?: StringFilter<"VideoLanguage"> | string
    name?: StringFilter<"VideoLanguage"> | string
  }

  export type MovieCreateWithoutVideoFileInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    metadata: VideoMetadataCreateNestedOneWithoutMovieInput
    tags?: MovieTagCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutVideoFileInput = {
    id?: string
    metadataId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    tags?: MovieTagUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutVideoFileInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutVideoFileInput, MovieUncheckedCreateWithoutVideoFileInput>
  }

  export type EpisodeCreateWithoutVideoFileInput = {
    id?: string
    number: number
    season: SeasonCreateNestedOneWithoutEpisodesInput
    metadata: VideoMetadataCreateNestedOneWithoutEpisodeInput
  }

  export type EpisodeUncheckedCreateWithoutVideoFileInput = {
    id?: string
    seasonId: string
    number: number
    metadataId: string
  }

  export type EpisodeCreateOrConnectWithoutVideoFileInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutVideoFileInput, EpisodeUncheckedCreateWithoutVideoFileInput>
  }

  export type SubtitleCreateWithoutVideoInput = {
    language: string
    subtitle_url: string
    videoMetadata?: VideoMetadataCreateNestedOneWithoutSubtitlesInput
  }

  export type SubtitleUncheckedCreateWithoutVideoInput = {
    language: string
    subtitle_url: string
    videoMetadataId?: string | null
  }

  export type SubtitleCreateOrConnectWithoutVideoInput = {
    where: SubtitleWhereUniqueInput
    create: XOR<SubtitleCreateWithoutVideoInput, SubtitleUncheckedCreateWithoutVideoInput>
  }

  export type SubtitleCreateManyVideoInputEnvelope = {
    data: SubtitleCreateManyVideoInput | SubtitleCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutVideoInput = {
    id?: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
    user: UserCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
  }

  export type PurchaseCreateOrConnectWithoutVideoInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutVideoInput, PurchaseUncheckedCreateWithoutVideoInput>
  }

  export type PurchaseCreateManyVideoInputEnvelope = {
    data: PurchaseCreateManyVideoInput | PurchaseCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutVideoInput = {
    id?: string
    text: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutVideoInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput>
  }

  export type CommentCreateManyVideoInputEnvelope = {
    data: CommentCreateManyVideoInput | CommentCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type ViewCreateWithoutVideoInput = {
    id?: string
    viewed_at?: Date | string
    progress_seconds?: number
    user: UserCreateNestedOneWithoutViewsInput
    profile?: SharedAccountUserCreateNestedOneWithoutViewsInput
  }

  export type ViewUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    profileId?: string | null
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type ViewCreateOrConnectWithoutVideoInput = {
    where: ViewWhereUniqueInput
    create: XOR<ViewCreateWithoutVideoInput, ViewUncheckedCreateWithoutVideoInput>
  }

  export type ViewCreateManyVideoInputEnvelope = {
    data: ViewCreateManyVideoInput | ViewCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type MovieUpsertWithoutVideoFileInput = {
    update: XOR<MovieUpdateWithoutVideoFileInput, MovieUncheckedUpdateWithoutVideoFileInput>
    create: XOR<MovieCreateWithoutVideoFileInput, MovieUncheckedCreateWithoutVideoFileInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutVideoFileInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutVideoFileInput, MovieUncheckedUpdateWithoutVideoFileInput>
  }

  export type MovieUpdateWithoutVideoFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: VideoMetadataUpdateOneRequiredWithoutMovieNestedInput
    tags?: MovieTagUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutVideoFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: MovieTagUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type EpisodeUpsertWithoutVideoFileInput = {
    update: XOR<EpisodeUpdateWithoutVideoFileInput, EpisodeUncheckedUpdateWithoutVideoFileInput>
    create: XOR<EpisodeCreateWithoutVideoFileInput, EpisodeUncheckedCreateWithoutVideoFileInput>
    where?: EpisodeWhereInput
  }

  export type EpisodeUpdateToOneWithWhereWithoutVideoFileInput = {
    where?: EpisodeWhereInput
    data: XOR<EpisodeUpdateWithoutVideoFileInput, EpisodeUncheckedUpdateWithoutVideoFileInput>
  }

  export type EpisodeUpdateWithoutVideoFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneRequiredWithoutEpisodesNestedInput
    metadata?: VideoMetadataUpdateOneRequiredWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutVideoFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    metadataId?: StringFieldUpdateOperationsInput | string
  }

  export type SubtitleUpsertWithWhereUniqueWithoutVideoInput = {
    where: SubtitleWhereUniqueInput
    update: XOR<SubtitleUpdateWithoutVideoInput, SubtitleUncheckedUpdateWithoutVideoInput>
    create: XOR<SubtitleCreateWithoutVideoInput, SubtitleUncheckedCreateWithoutVideoInput>
  }

  export type SubtitleUpdateWithWhereUniqueWithoutVideoInput = {
    where: SubtitleWhereUniqueInput
    data: XOR<SubtitleUpdateWithoutVideoInput, SubtitleUncheckedUpdateWithoutVideoInput>
  }

  export type SubtitleUpdateManyWithWhereWithoutVideoInput = {
    where: SubtitleScalarWhereInput
    data: XOR<SubtitleUpdateManyMutationInput, SubtitleUncheckedUpdateManyWithoutVideoInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutVideoInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutVideoInput, PurchaseUncheckedUpdateWithoutVideoInput>
    create: XOR<PurchaseCreateWithoutVideoInput, PurchaseUncheckedCreateWithoutVideoInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutVideoInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutVideoInput, PurchaseUncheckedUpdateWithoutVideoInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutVideoInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutVideoInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutVideoInput, CommentUncheckedUpdateWithoutVideoInput>
    create: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutVideoInput, CommentUncheckedUpdateWithoutVideoInput>
  }

  export type CommentUpdateManyWithWhereWithoutVideoInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutVideoInput>
  }

  export type ViewUpsertWithWhereUniqueWithoutVideoInput = {
    where: ViewWhereUniqueInput
    update: XOR<ViewUpdateWithoutVideoInput, ViewUncheckedUpdateWithoutVideoInput>
    create: XOR<ViewCreateWithoutVideoInput, ViewUncheckedCreateWithoutVideoInput>
  }

  export type ViewUpdateWithWhereUniqueWithoutVideoInput = {
    where: ViewWhereUniqueInput
    data: XOR<ViewUpdateWithoutVideoInput, ViewUncheckedUpdateWithoutVideoInput>
  }

  export type ViewUpdateManyWithWhereWithoutVideoInput = {
    where: ViewScalarWhereInput
    data: XOR<ViewUpdateManyMutationInput, ViewUncheckedUpdateManyWithoutVideoInput>
  }

  export type VideoMetadataCreateWithoutGenresInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutGenresInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutGenresInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutGenresInput, VideoMetadataUncheckedCreateWithoutGenresInput>
  }

  export type VideoMetadataUpsertWithWhereUniqueWithoutGenresInput = {
    where: VideoMetadataWhereUniqueInput
    update: XOR<VideoMetadataUpdateWithoutGenresInput, VideoMetadataUncheckedUpdateWithoutGenresInput>
    create: XOR<VideoMetadataCreateWithoutGenresInput, VideoMetadataUncheckedCreateWithoutGenresInput>
  }

  export type VideoMetadataUpdateWithWhereUniqueWithoutGenresInput = {
    where: VideoMetadataWhereUniqueInput
    data: XOR<VideoMetadataUpdateWithoutGenresInput, VideoMetadataUncheckedUpdateWithoutGenresInput>
  }

  export type VideoMetadataUpdateManyWithWhereWithoutGenresInput = {
    where: VideoMetadataScalarWhereInput
    data: XOR<VideoMetadataUpdateManyMutationInput, VideoMetadataUncheckedUpdateManyWithoutGenresInput>
  }

  export type VideoMetadataScalarWhereInput = {
    AND?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
    OR?: VideoMetadataScalarWhereInput[]
    NOT?: VideoMetadataScalarWhereInput | VideoMetadataScalarWhereInput[]
    id?: StringFilter<"VideoMetadata"> | string
    title?: StringFilter<"VideoMetadata"> | string
    description?: StringFilter<"VideoMetadata"> | string
    thumbnailUrl?: StringFilter<"VideoMetadata"> | string
    secondaryImage?: StringNullableFilter<"VideoMetadata"> | string | null
    releaseDate?: DateTimeFilter<"VideoMetadata"> | Date | string
    platformDate?: DateTimeFilter<"VideoMetadata"> | Date | string
    ageRating?: StringFilter<"VideoMetadata"> | string
    productionHouse?: StringFilter<"VideoMetadata"> | string
    productionCountry?: StringFilter<"VideoMetadata"> | string
    director?: StringFilter<"VideoMetadata"> | string
    formatId?: StringFilter<"VideoMetadata"> | string
    categoryId?: StringFilter<"VideoMetadata"> | string
    status?: StringFilter<"VideoMetadata"> | string
  }

  export type VideoActorCreateWithoutActorInput = {
    role?: string | null
    video: VideoMetadataCreateNestedOneWithoutActorsInput
  }

  export type VideoActorUncheckedCreateWithoutActorInput = {
    videoId: string
    role?: string | null
  }

  export type VideoActorCreateOrConnectWithoutActorInput = {
    where: VideoActorWhereUniqueInput
    create: XOR<VideoActorCreateWithoutActorInput, VideoActorUncheckedCreateWithoutActorInput>
  }

  export type VideoActorCreateManyActorInputEnvelope = {
    data: VideoActorCreateManyActorInput | VideoActorCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type VideoActorUpsertWithWhereUniqueWithoutActorInput = {
    where: VideoActorWhereUniqueInput
    update: XOR<VideoActorUpdateWithoutActorInput, VideoActorUncheckedUpdateWithoutActorInput>
    create: XOR<VideoActorCreateWithoutActorInput, VideoActorUncheckedCreateWithoutActorInput>
  }

  export type VideoActorUpdateWithWhereUniqueWithoutActorInput = {
    where: VideoActorWhereUniqueInput
    data: XOR<VideoActorUpdateWithoutActorInput, VideoActorUncheckedUpdateWithoutActorInput>
  }

  export type VideoActorUpdateManyWithWhereWithoutActorInput = {
    where: VideoActorScalarWhereInput
    data: XOR<VideoActorUpdateManyMutationInput, VideoActorUncheckedUpdateManyWithoutActorInput>
  }

  export type VideoMetadataCreateWithoutActorsInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutActorsInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutActorsInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutActorsInput, VideoMetadataUncheckedCreateWithoutActorsInput>
  }

  export type ActorCreateWithoutVideoActorInput = {
    id?: string
    name: string
  }

  export type ActorUncheckedCreateWithoutVideoActorInput = {
    id?: string
    name: string
  }

  export type ActorCreateOrConnectWithoutVideoActorInput = {
    where: ActorWhereUniqueInput
    create: XOR<ActorCreateWithoutVideoActorInput, ActorUncheckedCreateWithoutVideoActorInput>
  }

  export type VideoMetadataUpsertWithoutActorsInput = {
    update: XOR<VideoMetadataUpdateWithoutActorsInput, VideoMetadataUncheckedUpdateWithoutActorsInput>
    create: XOR<VideoMetadataCreateWithoutActorsInput, VideoMetadataUncheckedCreateWithoutActorsInput>
    where?: VideoMetadataWhereInput
  }

  export type VideoMetadataUpdateToOneWithWhereWithoutActorsInput = {
    where?: VideoMetadataWhereInput
    data: XOR<VideoMetadataUpdateWithoutActorsInput, VideoMetadataUncheckedUpdateWithoutActorsInput>
  }

  export type VideoMetadataUpdateWithoutActorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutActorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type ActorUpsertWithoutVideoActorInput = {
    update: XOR<ActorUpdateWithoutVideoActorInput, ActorUncheckedUpdateWithoutVideoActorInput>
    create: XOR<ActorCreateWithoutVideoActorInput, ActorUncheckedCreateWithoutVideoActorInput>
    where?: ActorWhereInput
  }

  export type ActorUpdateToOneWithWhereWithoutVideoActorInput = {
    where?: ActorWhereInput
    data: XOR<ActorUpdateWithoutVideoActorInput, ActorUncheckedUpdateWithoutVideoActorInput>
  }

  export type ActorUpdateWithoutVideoActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorUncheckedUpdateWithoutVideoActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoMetadataCreateWithoutLanguagesInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
  }

  export type VideoMetadataUncheckedCreateWithoutLanguagesInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
  }

  export type VideoMetadataCreateOrConnectWithoutLanguagesInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutLanguagesInput, VideoMetadataUncheckedCreateWithoutLanguagesInput>
  }

  export type VideoMetadataUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: VideoMetadataWhereUniqueInput
    update: XOR<VideoMetadataUpdateWithoutLanguagesInput, VideoMetadataUncheckedUpdateWithoutLanguagesInput>
    create: XOR<VideoMetadataCreateWithoutLanguagesInput, VideoMetadataUncheckedCreateWithoutLanguagesInput>
  }

  export type VideoMetadataUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: VideoMetadataWhereUniqueInput
    data: XOR<VideoMetadataUpdateWithoutLanguagesInput, VideoMetadataUncheckedUpdateWithoutLanguagesInput>
  }

  export type VideoMetadataUpdateManyWithWhereWithoutLanguagesInput = {
    where: VideoMetadataScalarWhereInput
    data: XOR<VideoMetadataUpdateManyMutationInput, VideoMetadataUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type VideoMetadataCreateWithoutFormatInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutFormatInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutFormatInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutFormatInput, VideoMetadataUncheckedCreateWithoutFormatInput>
  }

  export type VideoMetadataCreateManyFormatInputEnvelope = {
    data: VideoMetadataCreateManyFormatInput | VideoMetadataCreateManyFormatInput[]
    skipDuplicates?: boolean
  }

  export type VideoMetadataUpsertWithWhereUniqueWithoutFormatInput = {
    where: VideoMetadataWhereUniqueInput
    update: XOR<VideoMetadataUpdateWithoutFormatInput, VideoMetadataUncheckedUpdateWithoutFormatInput>
    create: XOR<VideoMetadataCreateWithoutFormatInput, VideoMetadataUncheckedCreateWithoutFormatInput>
  }

  export type VideoMetadataUpdateWithWhereUniqueWithoutFormatInput = {
    where: VideoMetadataWhereUniqueInput
    data: XOR<VideoMetadataUpdateWithoutFormatInput, VideoMetadataUncheckedUpdateWithoutFormatInput>
  }

  export type VideoMetadataUpdateManyWithWhereWithoutFormatInput = {
    where: VideoMetadataScalarWhereInput
    data: XOR<VideoMetadataUpdateManyMutationInput, VideoMetadataUncheckedUpdateManyWithoutFormatInput>
  }

  export type VideoMetadataCreateWithoutCategoryInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutCategoryInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutCategoryInput, VideoMetadataUncheckedCreateWithoutCategoryInput>
  }

  export type VideoMetadataCreateManyCategoryInputEnvelope = {
    data: VideoMetadataCreateManyCategoryInput | VideoMetadataCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type VideoMetadataUpsertWithWhereUniqueWithoutCategoryInput = {
    where: VideoMetadataWhereUniqueInput
    update: XOR<VideoMetadataUpdateWithoutCategoryInput, VideoMetadataUncheckedUpdateWithoutCategoryInput>
    create: XOR<VideoMetadataCreateWithoutCategoryInput, VideoMetadataUncheckedCreateWithoutCategoryInput>
  }

  export type VideoMetadataUpdateWithWhereUniqueWithoutCategoryInput = {
    where: VideoMetadataWhereUniqueInput
    data: XOR<VideoMetadataUpdateWithoutCategoryInput, VideoMetadataUncheckedUpdateWithoutCategoryInput>
  }

  export type VideoMetadataUpdateManyWithWhereWithoutCategoryInput = {
    where: VideoMetadataScalarWhereInput
    data: XOR<VideoMetadataUpdateManyMutationInput, VideoMetadataUncheckedUpdateManyWithoutCategoryInput>
  }

  export type VideoMetadataCreateWithoutMovieInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutMovieInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutMovieInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutMovieInput, VideoMetadataUncheckedCreateWithoutMovieInput>
  }

  export type VideoFileCreateWithoutMovieInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    episode?: EpisodeCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoInput
    purchases?: PurchaseCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    views?: ViewCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateWithoutMovieInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    episode?: EpisodeUncheckedCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    views?: ViewUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileCreateOrConnectWithoutMovieInput = {
    where: VideoFileWhereUniqueInput
    create: XOR<VideoFileCreateWithoutMovieInput, VideoFileUncheckedCreateWithoutMovieInput>
  }

  export type MovieTagCreateWithoutMovieInput = {
    tag: TagCreateNestedOneWithoutMovieTagsInput
  }

  export type MovieTagUncheckedCreateWithoutMovieInput = {
    tagId: string
  }

  export type MovieTagCreateOrConnectWithoutMovieInput = {
    where: MovieTagWhereUniqueInput
    create: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput>
  }

  export type MovieTagCreateManyMovieInputEnvelope = {
    data: MovieTagCreateManyMovieInput | MovieTagCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type VideoMetadataUpsertWithoutMovieInput = {
    update: XOR<VideoMetadataUpdateWithoutMovieInput, VideoMetadataUncheckedUpdateWithoutMovieInput>
    create: XOR<VideoMetadataCreateWithoutMovieInput, VideoMetadataUncheckedCreateWithoutMovieInput>
    where?: VideoMetadataWhereInput
  }

  export type VideoMetadataUpdateToOneWithWhereWithoutMovieInput = {
    where?: VideoMetadataWhereInput
    data: XOR<VideoMetadataUpdateWithoutMovieInput, VideoMetadataUncheckedUpdateWithoutMovieInput>
  }

  export type VideoMetadataUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideoFileUpsertWithoutMovieInput = {
    update: XOR<VideoFileUpdateWithoutMovieInput, VideoFileUncheckedUpdateWithoutMovieInput>
    create: XOR<VideoFileCreateWithoutMovieInput, VideoFileUncheckedCreateWithoutMovieInput>
    where?: VideoFileWhereInput
  }

  export type VideoFileUpdateToOneWithWhereWithoutMovieInput = {
    where?: VideoFileWhereInput
    data: XOR<VideoFileUpdateWithoutMovieInput, VideoFileUncheckedUpdateWithoutMovieInput>
  }

  export type VideoFileUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: EpisodeUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    views?: ViewUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    views?: ViewUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type MovieTagUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieTagWhereUniqueInput
    update: XOR<MovieTagUpdateWithoutMovieInput, MovieTagUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieTagCreateWithoutMovieInput, MovieTagUncheckedCreateWithoutMovieInput>
  }

  export type MovieTagUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieTagWhereUniqueInput
    data: XOR<MovieTagUpdateWithoutMovieInput, MovieTagUncheckedUpdateWithoutMovieInput>
  }

  export type MovieTagUpdateManyWithWhereWithoutMovieInput = {
    where: MovieTagScalarWhereInput
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieTagScalarWhereInput = {
    AND?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
    OR?: MovieTagScalarWhereInput[]
    NOT?: MovieTagScalarWhereInput | MovieTagScalarWhereInput[]
    movieId?: StringFilter<"MovieTag"> | string
    tagId?: StringFilter<"MovieTag"> | string
  }

  export type VideoMetadataCreateWithoutSeriesInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutSeriesInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutSeriesInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutSeriesInput, VideoMetadataUncheckedCreateWithoutSeriesInput>
  }

  export type SeasonCreateWithoutSeriesInput = {
    id?: string
    number: number
    episodes?: EpisodeCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutSeriesInput = {
    id?: string
    number: number
    episodes?: EpisodeUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutSeriesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput>
  }

  export type SeasonCreateManySeriesInputEnvelope = {
    data: SeasonCreateManySeriesInput | SeasonCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type SeriesTagCreateWithoutSeriesInput = {
    tag: TagCreateNestedOneWithoutSeriesTagsInput
  }

  export type SeriesTagUncheckedCreateWithoutSeriesInput = {
    tagId: string
  }

  export type SeriesTagCreateOrConnectWithoutSeriesInput = {
    where: SeriesTagWhereUniqueInput
    create: XOR<SeriesTagCreateWithoutSeriesInput, SeriesTagUncheckedCreateWithoutSeriesInput>
  }

  export type SeriesTagCreateManySeriesInputEnvelope = {
    data: SeriesTagCreateManySeriesInput | SeriesTagCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type VideoMetadataUpsertWithoutSeriesInput = {
    update: XOR<VideoMetadataUpdateWithoutSeriesInput, VideoMetadataUncheckedUpdateWithoutSeriesInput>
    create: XOR<VideoMetadataCreateWithoutSeriesInput, VideoMetadataUncheckedCreateWithoutSeriesInput>
    where?: VideoMetadataWhereInput
  }

  export type VideoMetadataUpdateToOneWithWhereWithoutSeriesInput = {
    where?: VideoMetadataWhereInput
    data: XOR<VideoMetadataUpdateWithoutSeriesInput, VideoMetadataUncheckedUpdateWithoutSeriesInput>
  }

  export type VideoMetadataUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type SeasonUpsertWithWhereUniqueWithoutSeriesInput = {
    where: SeasonWhereUniqueInput
    update: XOR<SeasonUpdateWithoutSeriesInput, SeasonUncheckedUpdateWithoutSeriesInput>
    create: XOR<SeasonCreateWithoutSeriesInput, SeasonUncheckedCreateWithoutSeriesInput>
  }

  export type SeasonUpdateWithWhereUniqueWithoutSeriesInput = {
    where: SeasonWhereUniqueInput
    data: XOR<SeasonUpdateWithoutSeriesInput, SeasonUncheckedUpdateWithoutSeriesInput>
  }

  export type SeasonUpdateManyWithWhereWithoutSeriesInput = {
    where: SeasonScalarWhereInput
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyWithoutSeriesInput>
  }

  export type SeasonScalarWhereInput = {
    AND?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    OR?: SeasonScalarWhereInput[]
    NOT?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    id?: StringFilter<"Season"> | string
    seriesId?: StringFilter<"Season"> | string
    number?: IntFilter<"Season"> | number
  }

  export type SeriesTagUpsertWithWhereUniqueWithoutSeriesInput = {
    where: SeriesTagWhereUniqueInput
    update: XOR<SeriesTagUpdateWithoutSeriesInput, SeriesTagUncheckedUpdateWithoutSeriesInput>
    create: XOR<SeriesTagCreateWithoutSeriesInput, SeriesTagUncheckedCreateWithoutSeriesInput>
  }

  export type SeriesTagUpdateWithWhereUniqueWithoutSeriesInput = {
    where: SeriesTagWhereUniqueInput
    data: XOR<SeriesTagUpdateWithoutSeriesInput, SeriesTagUncheckedUpdateWithoutSeriesInput>
  }

  export type SeriesTagUpdateManyWithWhereWithoutSeriesInput = {
    where: SeriesTagScalarWhereInput
    data: XOR<SeriesTagUpdateManyMutationInput, SeriesTagUncheckedUpdateManyWithoutSeriesInput>
  }

  export type SeriesTagScalarWhereInput = {
    AND?: SeriesTagScalarWhereInput | SeriesTagScalarWhereInput[]
    OR?: SeriesTagScalarWhereInput[]
    NOT?: SeriesTagScalarWhereInput | SeriesTagScalarWhereInput[]
    seriesId?: StringFilter<"SeriesTag"> | string
    tagId?: StringFilter<"SeriesTag"> | string
  }

  export type SeriesCreateWithoutSeasonsInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    metadata: VideoMetadataCreateNestedOneWithoutSeriesInput
    tags?: SeriesTagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutSeasonsInput = {
    id?: string
    metadataId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    tags?: SeriesTagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutSeasonsInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutSeasonsInput, SeriesUncheckedCreateWithoutSeasonsInput>
  }

  export type EpisodeCreateWithoutSeasonInput = {
    id?: string
    number: number
    videoFile: VideoFileCreateNestedOneWithoutEpisodeInput
    metadata: VideoMetadataCreateNestedOneWithoutEpisodeInput
  }

  export type EpisodeUncheckedCreateWithoutSeasonInput = {
    id?: string
    number: number
    videoFileId: string
    metadataId: string
  }

  export type EpisodeCreateOrConnectWithoutSeasonInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput>
  }

  export type EpisodeCreateManySeasonInputEnvelope = {
    data: EpisodeCreateManySeasonInput | EpisodeCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type SeriesUpsertWithoutSeasonsInput = {
    update: XOR<SeriesUpdateWithoutSeasonsInput, SeriesUncheckedUpdateWithoutSeasonsInput>
    create: XOR<SeriesCreateWithoutSeasonsInput, SeriesUncheckedCreateWithoutSeasonsInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutSeasonsInput, SeriesUncheckedUpdateWithoutSeasonsInput>
  }

  export type SeriesUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: VideoMetadataUpdateOneRequiredWithoutSeriesNestedInput
    tags?: SeriesTagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: SeriesTagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type EpisodeUpsertWithWhereUniqueWithoutSeasonInput = {
    where: EpisodeWhereUniqueInput
    update: XOR<EpisodeUpdateWithoutSeasonInput, EpisodeUncheckedUpdateWithoutSeasonInput>
    create: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput>
  }

  export type EpisodeUpdateWithWhereUniqueWithoutSeasonInput = {
    where: EpisodeWhereUniqueInput
    data: XOR<EpisodeUpdateWithoutSeasonInput, EpisodeUncheckedUpdateWithoutSeasonInput>
  }

  export type EpisodeUpdateManyWithWhereWithoutSeasonInput = {
    where: EpisodeScalarWhereInput
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyWithoutSeasonInput>
  }

  export type EpisodeScalarWhereInput = {
    AND?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
    OR?: EpisodeScalarWhereInput[]
    NOT?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
    id?: StringFilter<"Episode"> | string
    seasonId?: StringFilter<"Episode"> | string
    number?: IntFilter<"Episode"> | number
    videoFileId?: StringFilter<"Episode"> | string
    metadataId?: StringFilter<"Episode"> | string
  }

  export type SeasonCreateWithoutEpisodesInput = {
    id?: string
    number: number
    series: SeriesCreateNestedOneWithoutSeasonsInput
  }

  export type SeasonUncheckedCreateWithoutEpisodesInput = {
    id?: string
    seriesId: string
    number: number
  }

  export type SeasonCreateOrConnectWithoutEpisodesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
  }

  export type VideoFileCreateWithoutEpisodeInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoInput
    purchases?: PurchaseCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    views?: ViewCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateWithoutEpisodeInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieUncheckedCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    views?: ViewUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileCreateOrConnectWithoutEpisodeInput = {
    where: VideoFileWhereUniqueInput
    create: XOR<VideoFileCreateWithoutEpisodeInput, VideoFileUncheckedCreateWithoutEpisodeInput>
  }

  export type VideoMetadataCreateWithoutEpisodeInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutEpisodeInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoMetadataInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutEpisodeInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutEpisodeInput, VideoMetadataUncheckedCreateWithoutEpisodeInput>
  }

  export type SeasonUpsertWithoutEpisodesInput = {
    update: XOR<SeasonUpdateWithoutEpisodesInput, SeasonUncheckedUpdateWithoutEpisodesInput>
    create: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutEpisodesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutEpisodesInput, SeasonUncheckedUpdateWithoutEpisodesInput>
  }

  export type SeasonUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    series?: SeriesUpdateOneRequiredWithoutSeasonsNestedInput
  }

  export type SeasonUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type VideoFileUpsertWithoutEpisodeInput = {
    update: XOR<VideoFileUpdateWithoutEpisodeInput, VideoFileUncheckedUpdateWithoutEpisodeInput>
    create: XOR<VideoFileCreateWithoutEpisodeInput, VideoFileUncheckedCreateWithoutEpisodeInput>
    where?: VideoFileWhereInput
  }

  export type VideoFileUpdateToOneWithWhereWithoutEpisodeInput = {
    where?: VideoFileWhereInput
    data: XOR<VideoFileUpdateWithoutEpisodeInput, VideoFileUncheckedUpdateWithoutEpisodeInput>
  }

  export type VideoFileUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    views?: ViewUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUncheckedUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    views?: ViewUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoMetadataUpsertWithoutEpisodeInput = {
    update: XOR<VideoMetadataUpdateWithoutEpisodeInput, VideoMetadataUncheckedUpdateWithoutEpisodeInput>
    create: XOR<VideoMetadataCreateWithoutEpisodeInput, VideoMetadataUncheckedCreateWithoutEpisodeInput>
    where?: VideoMetadataWhereInput
  }

  export type VideoMetadataUpdateToOneWithWhereWithoutEpisodeInput = {
    where?: VideoMetadataWhereInput
    data: XOR<VideoMetadataUpdateWithoutEpisodeInput, VideoMetadataUncheckedUpdateWithoutEpisodeInput>
  }

  export type VideoMetadataUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type MovieTagCreateWithoutTagInput = {
    movie: MovieCreateNestedOneWithoutTagsInput
  }

  export type MovieTagUncheckedCreateWithoutTagInput = {
    movieId: string
  }

  export type MovieTagCreateOrConnectWithoutTagInput = {
    where: MovieTagWhereUniqueInput
    create: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput>
  }

  export type MovieTagCreateManyTagInputEnvelope = {
    data: MovieTagCreateManyTagInput | MovieTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type SeriesTagCreateWithoutTagInput = {
    series: SeriesCreateNestedOneWithoutTagsInput
  }

  export type SeriesTagUncheckedCreateWithoutTagInput = {
    seriesId: string
  }

  export type SeriesTagCreateOrConnectWithoutTagInput = {
    where: SeriesTagWhereUniqueInput
    create: XOR<SeriesTagCreateWithoutTagInput, SeriesTagUncheckedCreateWithoutTagInput>
  }

  export type SeriesTagCreateManyTagInputEnvelope = {
    data: SeriesTagCreateManyTagInput | SeriesTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type MovieTagUpsertWithWhereUniqueWithoutTagInput = {
    where: MovieTagWhereUniqueInput
    update: XOR<MovieTagUpdateWithoutTagInput, MovieTagUncheckedUpdateWithoutTagInput>
    create: XOR<MovieTagCreateWithoutTagInput, MovieTagUncheckedCreateWithoutTagInput>
  }

  export type MovieTagUpdateWithWhereUniqueWithoutTagInput = {
    where: MovieTagWhereUniqueInput
    data: XOR<MovieTagUpdateWithoutTagInput, MovieTagUncheckedUpdateWithoutTagInput>
  }

  export type MovieTagUpdateManyWithWhereWithoutTagInput = {
    where: MovieTagScalarWhereInput
    data: XOR<MovieTagUpdateManyMutationInput, MovieTagUncheckedUpdateManyWithoutTagInput>
  }

  export type SeriesTagUpsertWithWhereUniqueWithoutTagInput = {
    where: SeriesTagWhereUniqueInput
    update: XOR<SeriesTagUpdateWithoutTagInput, SeriesTagUncheckedUpdateWithoutTagInput>
    create: XOR<SeriesTagCreateWithoutTagInput, SeriesTagUncheckedCreateWithoutTagInput>
  }

  export type SeriesTagUpdateWithWhereUniqueWithoutTagInput = {
    where: SeriesTagWhereUniqueInput
    data: XOR<SeriesTagUpdateWithoutTagInput, SeriesTagUncheckedUpdateWithoutTagInput>
  }

  export type SeriesTagUpdateManyWithWhereWithoutTagInput = {
    where: SeriesTagScalarWhereInput
    data: XOR<SeriesTagUpdateManyMutationInput, SeriesTagUncheckedUpdateManyWithoutTagInput>
  }

  export type MovieCreateWithoutTagsInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    metadata: VideoMetadataCreateNestedOneWithoutMovieInput
    videoFile: VideoFileCreateNestedOneWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutTagsInput = {
    id?: string
    metadataId: string
    videoFileId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
  }

  export type MovieCreateOrConnectWithoutTagsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutTagsInput, MovieUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutMovieTagsInput = {
    id?: string
    name: string
    seriesTags?: SeriesTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutMovieTagsInput = {
    id?: string
    name: string
    seriesTags?: SeriesTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutMovieTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
  }

  export type MovieUpsertWithoutTagsInput = {
    update: XOR<MovieUpdateWithoutTagsInput, MovieUncheckedUpdateWithoutTagsInput>
    create: XOR<MovieCreateWithoutTagsInput, MovieUncheckedCreateWithoutTagsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutTagsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutTagsInput, MovieUncheckedUpdateWithoutTagsInput>
  }

  export type MovieUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: VideoMetadataUpdateOneRequiredWithoutMovieNestedInput
    videoFile?: VideoFileUpdateOneRequiredWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    videoFileId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TagUpsertWithoutMovieTagsInput = {
    update: XOR<TagUpdateWithoutMovieTagsInput, TagUncheckedUpdateWithoutMovieTagsInput>
    create: XOR<TagCreateWithoutMovieTagsInput, TagUncheckedCreateWithoutMovieTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutMovieTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutMovieTagsInput, TagUncheckedUpdateWithoutMovieTagsInput>
  }

  export type TagUpdateWithoutMovieTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    seriesTags?: SeriesTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutMovieTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    seriesTags?: SeriesTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type SeriesCreateWithoutTagsInput = {
    id?: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    metadata: VideoMetadataCreateNestedOneWithoutSeriesInput
    seasons?: SeasonCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutTagsInput = {
    id?: string
    metadataId: string
    status?: string
    type?: string
    seasonCount?: number
    rentalPrice?: number | null
    seasons?: SeasonUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutTagsInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutSeriesTagsInput = {
    id?: string
    name: string
    movieTags?: MovieTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutSeriesTagsInput = {
    id?: string
    name: string
    movieTags?: MovieTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutSeriesTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSeriesTagsInput, TagUncheckedCreateWithoutSeriesTagsInput>
  }

  export type SeriesUpsertWithoutTagsInput = {
    update: XOR<SeriesUpdateWithoutTagsInput, SeriesUncheckedUpdateWithoutTagsInput>
    create: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutTagsInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutTagsInput, SeriesUncheckedUpdateWithoutTagsInput>
  }

  export type SeriesUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: VideoMetadataUpdateOneRequiredWithoutSeriesNestedInput
    seasons?: SeasonUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasonCount?: IntFieldUpdateOperationsInput | number
    rentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    seasons?: SeasonUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type TagUpsertWithoutSeriesTagsInput = {
    update: XOR<TagUpdateWithoutSeriesTagsInput, TagUncheckedUpdateWithoutSeriesTagsInput>
    create: XOR<TagCreateWithoutSeriesTagsInput, TagUncheckedCreateWithoutSeriesTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutSeriesTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutSeriesTagsInput, TagUncheckedUpdateWithoutSeriesTagsInput>
  }

  export type TagUpdateWithoutSeriesTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    movieTags?: MovieTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutSeriesTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    movieTags?: MovieTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type VideoFileCreateWithoutSubtitlesInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeCreateNestedOneWithoutVideoFileInput
    purchases?: PurchaseCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    views?: ViewCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateWithoutSubtitlesInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieUncheckedCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutVideoFileInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    views?: ViewUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileCreateOrConnectWithoutSubtitlesInput = {
    where: VideoFileWhereUniqueInput
    create: XOR<VideoFileCreateWithoutSubtitlesInput, VideoFileUncheckedCreateWithoutSubtitlesInput>
  }

  export type VideoMetadataCreateWithoutSubtitlesInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    status?: string
    format: VideoFormatCreateNestedOneWithoutVideosInput
    category: VideoCategoryCreateNestedOneWithoutVideosInput
    movie?: MovieCreateNestedOneWithoutMetadataInput
    episode?: EpisodeCreateNestedOneWithoutMetadataInput
    series?: SeriesCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreCreateNestedManyWithoutVideosInput
    actors?: VideoActorCreateNestedManyWithoutVideoInput
    languages?: VideoLanguageCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataUncheckedCreateWithoutSubtitlesInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    categoryId: string
    status?: string
    movie?: MovieUncheckedCreateNestedOneWithoutMetadataInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutMetadataInput
    series?: SeriesUncheckedCreateNestedOneWithoutMetadataInput
    genres?: VideoGenreUncheckedCreateNestedManyWithoutVideosInput
    actors?: VideoActorUncheckedCreateNestedManyWithoutVideoInput
    languages?: VideoLanguageUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideoMetadataCreateOrConnectWithoutSubtitlesInput = {
    where: VideoMetadataWhereUniqueInput
    create: XOR<VideoMetadataCreateWithoutSubtitlesInput, VideoMetadataUncheckedCreateWithoutSubtitlesInput>
  }

  export type VideoFileUpsertWithoutSubtitlesInput = {
    update: XOR<VideoFileUpdateWithoutSubtitlesInput, VideoFileUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<VideoFileCreateWithoutSubtitlesInput, VideoFileUncheckedCreateWithoutSubtitlesInput>
    where?: VideoFileWhereInput
  }

  export type VideoFileUpdateToOneWithWhereWithoutSubtitlesInput = {
    where?: VideoFileWhereInput
    data: XOR<VideoFileUpdateWithoutSubtitlesInput, VideoFileUncheckedUpdateWithoutSubtitlesInput>
  }

  export type VideoFileUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUpdateOneWithoutVideoFileNestedInput
    purchases?: PurchaseUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    views?: ViewUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUncheckedUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    views?: ViewUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoMetadataUpsertWithoutSubtitlesInput = {
    update: XOR<VideoMetadataUpdateWithoutSubtitlesInput, VideoMetadataUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<VideoMetadataCreateWithoutSubtitlesInput, VideoMetadataUncheckedCreateWithoutSubtitlesInput>
    where?: VideoMetadataWhereInput
  }

  export type VideoMetadataUpdateToOneWithWhereWithoutSubtitlesInput = {
    where?: VideoMetadataWhereInput
    data: XOR<VideoMetadataUpdateWithoutSubtitlesInput, VideoMetadataUncheckedUpdateWithoutSubtitlesInput>
  }

  export type VideoMetadataUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type UserCreateWithoutPurchasesInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type VideoFileCreateWithoutPurchasesInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    views?: ViewCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateWithoutPurchasesInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieUncheckedCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    views?: ViewUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileCreateOrConnectWithoutPurchasesInput = {
    where: VideoFileWhereUniqueInput
    create: XOR<VideoFileCreateWithoutPurchasesInput, VideoFileUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VideoFileUpsertWithoutPurchasesInput = {
    update: XOR<VideoFileUpdateWithoutPurchasesInput, VideoFileUncheckedUpdateWithoutPurchasesInput>
    create: XOR<VideoFileCreateWithoutPurchasesInput, VideoFileUncheckedCreateWithoutPurchasesInput>
    where?: VideoFileWhereInput
  }

  export type VideoFileUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: VideoFileWhereInput
    data: XOR<VideoFileUpdateWithoutPurchasesInput, VideoFileUncheckedUpdateWithoutPurchasesInput>
  }

  export type VideoFileUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    views?: ViewUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUncheckedUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    views?: ViewUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserCreateWithoutViewsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViewsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewsInput, UserUncheckedCreateWithoutViewsInput>
  }

  export type SharedAccountUserCreateWithoutViewsInput = {
    id?: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    sharedAccount: SharedAccountCreateNestedOneWithoutProfilesInput
    user: UserCreateNestedOneWithoutSharedProfilesInput
    adViews?: AdViewCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUncheckedCreateWithoutViewsInput = {
    id?: string
    sharedAccountId: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    adViews?: AdViewUncheckedCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityUncheckedCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserCreateOrConnectWithoutViewsInput = {
    where: SharedAccountUserWhereUniqueInput
    create: XOR<SharedAccountUserCreateWithoutViewsInput, SharedAccountUserUncheckedCreateWithoutViewsInput>
  }

  export type VideoFileCreateWithoutViewsInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoInput
    purchases?: PurchaseCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateWithoutViewsInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieUncheckedCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileCreateOrConnectWithoutViewsInput = {
    where: VideoFileWhereUniqueInput
    create: XOR<VideoFileCreateWithoutViewsInput, VideoFileUncheckedCreateWithoutViewsInput>
  }

  export type UserUpsertWithoutViewsInput = {
    update: XOR<UserUpdateWithoutViewsInput, UserUncheckedUpdateWithoutViewsInput>
    create: XOR<UserCreateWithoutViewsInput, UserUncheckedCreateWithoutViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewsInput, UserUncheckedUpdateWithoutViewsInput>
  }

  export type UserUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SharedAccountUserUpsertWithoutViewsInput = {
    update: XOR<SharedAccountUserUpdateWithoutViewsInput, SharedAccountUserUncheckedUpdateWithoutViewsInput>
    create: XOR<SharedAccountUserCreateWithoutViewsInput, SharedAccountUserUncheckedCreateWithoutViewsInput>
    where?: SharedAccountUserWhereInput
  }

  export type SharedAccountUserUpdateToOneWithWhereWithoutViewsInput = {
    where?: SharedAccountUserWhereInput
    data: XOR<SharedAccountUserUpdateWithoutViewsInput, SharedAccountUserUncheckedUpdateWithoutViewsInput>
  }

  export type SharedAccountUserUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedAccount?: SharedAccountUpdateOneRequiredWithoutProfilesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedProfilesNestedInput
    adViews?: AdViewUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    adViews?: AdViewUncheckedUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type VideoFileUpsertWithoutViewsInput = {
    update: XOR<VideoFileUpdateWithoutViewsInput, VideoFileUncheckedUpdateWithoutViewsInput>
    create: XOR<VideoFileCreateWithoutViewsInput, VideoFileUncheckedCreateWithoutViewsInput>
    where?: VideoFileWhereInput
  }

  export type VideoFileUpdateToOneWithWhereWithoutViewsInput = {
    where?: VideoFileWhereInput
    data: XOR<VideoFileUpdateWithoutViewsInput, VideoFileUncheckedUpdateWithoutViewsInput>
  }

  export type VideoFileUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUncheckedUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type VideoFileCreateWithoutCommentsInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoInput
    purchases?: PurchaseCreateNestedManyWithoutVideoInput
    views?: ViewCreateNestedManyWithoutVideoInput
  }

  export type VideoFileUncheckedCreateWithoutCommentsInput = {
    id?: string
    filePath: string
    trailerPath?: string | null
    duration: number
    width?: number | null
    height?: number | null
    movie?: MovieUncheckedCreateNestedOneWithoutVideoFileInput
    episode?: EpisodeUncheckedCreateNestedOneWithoutVideoFileInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVideoInput
    views?: ViewUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoFileCreateOrConnectWithoutCommentsInput = {
    where: VideoFileWhereUniqueInput
    create: XOR<VideoFileCreateWithoutCommentsInput, VideoFileUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    text: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    video: VideoFileCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    userId: string
    videoId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    text: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    video: VideoFileCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    userId: string
    videoId: string
    text: string
    created_at?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VideoFileUpsertWithoutCommentsInput = {
    update: XOR<VideoFileUpdateWithoutCommentsInput, VideoFileUncheckedUpdateWithoutCommentsInput>
    create: XOR<VideoFileCreateWithoutCommentsInput, VideoFileUncheckedCreateWithoutCommentsInput>
    where?: VideoFileWhereInput
  }

  export type VideoFileUpdateToOneWithWhereWithoutCommentsInput = {
    where?: VideoFileWhereInput
    data: XOR<VideoFileUpdateWithoutCommentsInput, VideoFileUncheckedUpdateWithoutCommentsInput>
  }

  export type VideoFileUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUpdateManyWithoutVideoNestedInput
    views?: ViewUpdateManyWithoutVideoNestedInput
  }

  export type VideoFileUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    trailerPath?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: MovieUncheckedUpdateOneWithoutVideoFileNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutVideoFileNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutVideoNestedInput
    views?: ViewUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    video?: VideoFileUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type AdViewCreateWithoutAdInput = {
    id?: string
    viewed_at?: Date | string
    user?: UserCreateNestedOneWithoutAdViewsInput
    profile?: SharedAccountUserCreateNestedOneWithoutAdViewsInput
  }

  export type AdViewUncheckedCreateWithoutAdInput = {
    id?: string
    userId?: string | null
    profileId?: string | null
    viewed_at?: Date | string
  }

  export type AdViewCreateOrConnectWithoutAdInput = {
    where: AdViewWhereUniqueInput
    create: XOR<AdViewCreateWithoutAdInput, AdViewUncheckedCreateWithoutAdInput>
  }

  export type AdViewCreateManyAdInputEnvelope = {
    data: AdViewCreateManyAdInput | AdViewCreateManyAdInput[]
    skipDuplicates?: boolean
  }

  export type AdViewUpsertWithWhereUniqueWithoutAdInput = {
    where: AdViewWhereUniqueInput
    update: XOR<AdViewUpdateWithoutAdInput, AdViewUncheckedUpdateWithoutAdInput>
    create: XOR<AdViewCreateWithoutAdInput, AdViewUncheckedCreateWithoutAdInput>
  }

  export type AdViewUpdateWithWhereUniqueWithoutAdInput = {
    where: AdViewWhereUniqueInput
    data: XOR<AdViewUpdateWithoutAdInput, AdViewUncheckedUpdateWithoutAdInput>
  }

  export type AdViewUpdateManyWithWhereWithoutAdInput = {
    where: AdViewScalarWhereInput
    data: XOR<AdViewUpdateManyMutationInput, AdViewUncheckedUpdateManyWithoutAdInput>
  }

  export type AdCreateWithoutViewsInput = {
    id?: string
    title: string
    image_url: string
    video_url?: string | null
    start_date: Date | string
    end_date: Date | string
    is_active?: boolean
  }

  export type AdUncheckedCreateWithoutViewsInput = {
    id?: string
    title: string
    image_url: string
    video_url?: string | null
    start_date: Date | string
    end_date: Date | string
    is_active?: boolean
  }

  export type AdCreateOrConnectWithoutViewsInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutViewsInput, AdUncheckedCreateWithoutViewsInput>
  }

  export type UserCreateWithoutAdViewsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    views?: ViewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountCreateNestedManyWithoutSharedUserInput
  }

  export type UserUncheckedCreateWithoutAdViewsInput = {
    id?: string
    email: string
    password_hash: string
    name?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    isVerified?: boolean
    isMainAccount?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    ownedSharedAccounts?: SharedAccountUncheckedCreateNestedManyWithoutOwnerInput
    sharedProfiles?: SharedAccountUserUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    views?: ViewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    SharedAccount?: SharedAccountUncheckedCreateNestedManyWithoutSharedUserInput
  }

  export type UserCreateOrConnectWithoutAdViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdViewsInput, UserUncheckedCreateWithoutAdViewsInput>
  }

  export type SharedAccountUserCreateWithoutAdViewsInput = {
    id?: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    sharedAccount: SharedAccountCreateNestedOneWithoutProfilesInput
    user: UserCreateNestedOneWithoutSharedProfilesInput
    views?: ViewCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUncheckedCreateWithoutAdViewsInput = {
    id?: string
    sharedAccountId: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    views?: ViewUncheckedCreateNestedManyWithoutProfileInput
    activities?: SharedProfileActivityUncheckedCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserCreateOrConnectWithoutAdViewsInput = {
    where: SharedAccountUserWhereUniqueInput
    create: XOR<SharedAccountUserCreateWithoutAdViewsInput, SharedAccountUserUncheckedCreateWithoutAdViewsInput>
  }

  export type AdUpsertWithoutViewsInput = {
    update: XOR<AdUpdateWithoutViewsInput, AdUncheckedUpdateWithoutViewsInput>
    create: XOR<AdCreateWithoutViewsInput, AdUncheckedCreateWithoutViewsInput>
    where?: AdWhereInput
  }

  export type AdUpdateToOneWithWhereWithoutViewsInput = {
    where?: AdWhereInput
    data: XOR<AdUpdateWithoutViewsInput, AdUncheckedUpdateWithoutViewsInput>
  }

  export type AdUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutAdViewsInput = {
    update: XOR<UserUpdateWithoutAdViewsInput, UserUncheckedUpdateWithoutAdViewsInput>
    create: XOR<UserCreateWithoutAdViewsInput, UserUncheckedCreateWithoutAdViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdViewsInput, UserUncheckedUpdateWithoutAdViewsInput>
  }

  export type UserUpdateWithoutAdViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    views?: ViewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUpdateManyWithoutSharedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAccount?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    ownedSharedAccounts?: SharedAccountUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProfiles?: SharedAccountUserUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    views?: ViewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    SharedAccount?: SharedAccountUncheckedUpdateManyWithoutSharedUserNestedInput
  }

  export type SharedAccountUserUpsertWithoutAdViewsInput = {
    update: XOR<SharedAccountUserUpdateWithoutAdViewsInput, SharedAccountUserUncheckedUpdateWithoutAdViewsInput>
    create: XOR<SharedAccountUserCreateWithoutAdViewsInput, SharedAccountUserUncheckedCreateWithoutAdViewsInput>
    where?: SharedAccountUserWhereInput
  }

  export type SharedAccountUserUpdateToOneWithWhereWithoutAdViewsInput = {
    where?: SharedAccountUserWhereInput
    data: XOR<SharedAccountUserUpdateWithoutAdViewsInput, SharedAccountUserUncheckedUpdateWithoutAdViewsInput>
  }

  export type SharedAccountUserUpdateWithoutAdViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedAccount?: SharedAccountUpdateOneRequiredWithoutProfilesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedProfilesNestedInput
    views?: ViewUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateWithoutAdViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ViewUncheckedUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserCreateWithoutActivitiesInput = {
    id?: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    sharedAccount: SharedAccountCreateNestedOneWithoutProfilesInput
    user: UserCreateNestedOneWithoutSharedProfilesInput
    views?: ViewCreateNestedManyWithoutProfileInput
    adViews?: AdViewCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    sharedAccountId: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
    views?: ViewUncheckedCreateNestedManyWithoutProfileInput
    adViews?: AdViewUncheckedCreateNestedManyWithoutProfileInput
  }

  export type SharedAccountUserCreateOrConnectWithoutActivitiesInput = {
    where: SharedAccountUserWhereUniqueInput
    create: XOR<SharedAccountUserCreateWithoutActivitiesInput, SharedAccountUserUncheckedCreateWithoutActivitiesInput>
  }

  export type SharedAccountUserUpsertWithoutActivitiesInput = {
    update: XOR<SharedAccountUserUpdateWithoutActivitiesInput, SharedAccountUserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<SharedAccountUserCreateWithoutActivitiesInput, SharedAccountUserUncheckedCreateWithoutActivitiesInput>
    where?: SharedAccountUserWhereInput
  }

  export type SharedAccountUserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: SharedAccountUserWhereInput
    data: XOR<SharedAccountUserUpdateWithoutActivitiesInput, SharedAccountUserUncheckedUpdateWithoutActivitiesInput>
  }

  export type SharedAccountUserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedAccount?: SharedAccountUpdateOneRequiredWithoutProfilesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedProfilesNestedInput
    views?: ViewUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ViewUncheckedUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    planId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
  }

  export type SharedAccountCreateManyOwnerInput = {
    id?: string
    sharedUserId?: string | null
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
  }

  export type SharedAccountUserCreateManyUserInput = {
    id?: string
    sharedAccountId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
  }

  export type PurchaseCreateManyUserInput = {
    id?: string
    videoId: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
  }

  export type ViewCreateManyUserInput = {
    id?: string
    profileId?: string | null
    videoId: string
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type CommentCreateManyUserInput = {
    id?: string
    videoId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
  }

  export type SharedAccountCreateManySharedUserInput = {
    id?: string
    ownerUserId: string
    subscriptionId: string
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
  }

  export type AdViewCreateManyUserInput = {
    id?: string
    adId: string
    profileId?: string | null
    viewed_at?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    sharedAccounts?: SharedAccountUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    sharedAccounts?: SharedAccountUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
  }

  export type SharedAccountUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sharedUser?: UserUpdateOneWithoutSharedAccountNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSharedAccountsNestedInput
    profiles?: SharedAccountUserUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    profiles?: SharedAccountUserUncheckedUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SharedAccountUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedAccount?: SharedAccountUpdateOneRequiredWithoutProfilesNestedInput
    views?: ViewUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ViewUncheckedUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedAccountId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    video?: VideoFileUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
    profile?: SharedAccountUserUpdateOneWithoutViewsNestedInput
    video?: VideoFileUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type ViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoFileUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharedAccountUpdateWithoutSharedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneRequiredWithoutOwnedSharedAccountsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutSharedAccountsNestedInput
    profiles?: SharedAccountUserUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateWithoutSharedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    profiles?: SharedAccountUserUncheckedUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateManyWithoutSharedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ad?: AdUpdateOneRequiredWithoutViewsNestedInput
    profile?: SharedAccountUserUpdateOneWithoutAdViewsNestedInput
  }

  export type AdViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    start_date: Date | string
    end_date: Date | string
    renewal_status?: $Enums.RenewalStatus
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    sharedAccounts?: SharedAccountUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
    sharedAccounts?: SharedAccountUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal_status?: EnumRenewalStatusFieldUpdateOperationsInput | $Enums.RenewalStatus
  }

  export type SharedAccountCreateManySubscriptionInput = {
    id?: string
    ownerUserId: string
    sharedUserId?: string | null
    shared_on?: Date | string
    status?: $Enums.SharedAccountStatus
    is_active?: boolean
  }

  export type SharedAccountUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneRequiredWithoutOwnedSharedAccountsNestedInput
    sharedUser?: UserUpdateOneWithoutSharedAccountNestedInput
    profiles?: SharedAccountUserUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    profiles?: SharedAccountUserUncheckedUpdateManyWithoutSharedAccountNestedInput
  }

  export type SharedAccountUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: StringFieldUpdateOperationsInput | string
    sharedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    shared_on?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSharedAccountStatusFieldUpdateOperationsInput | $Enums.SharedAccountStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SharedAccountUserCreateManySharedAccountInput = {
    id?: string
    userId: string
    profile_name: string
    is_kid_profile?: boolean
    avatar_url?: string | null
    pin_code?: string | null
    created_at?: Date | string
  }

  export type SharedAccountUserUpdateWithoutSharedAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedProfilesNestedInput
    views?: ViewUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateWithoutSharedAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ViewUncheckedUpdateManyWithoutProfileNestedInput
    adViews?: AdViewUncheckedUpdateManyWithoutProfileNestedInput
    activities?: SharedProfileActivityUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type SharedAccountUserUncheckedUpdateManyWithoutSharedAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile_name?: StringFieldUpdateOperationsInput | string
    is_kid_profile?: BoolFieldUpdateOperationsInput | boolean
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewCreateManyProfileInput = {
    id?: string
    userId: string
    videoId: string
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type AdViewCreateManyProfileInput = {
    id?: string
    adId: string
    userId?: string | null
    viewed_at?: Date | string
  }

  export type SharedProfileActivityCreateManyProfileInput = {
    id?: string
    action: $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: Date | string
  }

  export type ViewUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutViewsNestedInput
    video?: VideoFileUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ViewUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type ViewUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type AdViewUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ad?: AdUpdateOneRequiredWithoutViewsNestedInput
    user?: UserUpdateOneWithoutAdViewsNestedInput
  }

  export type AdViewUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdViewUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProfileActivityUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProfileActivityUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProfileActivityUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumProfileActivityActionFieldUpdateOperationsInput | $Enums.ProfileActivityAction
    details?: NullableJsonNullValueInput | InputJsonValue
    performed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoActorCreateManyVideoInput = {
    actorId: string
    role?: string | null
  }

  export type SubtitleCreateManyVideoMetadataInput = {
    videoId: string
    language: string
    subtitle_url: string
  }

  export type VideoGenreUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoGenreUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoGenreUncheckedUpdateManyWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoActorUpdateWithoutVideoInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: ActorUpdateOneRequiredWithoutVideoActorNestedInput
  }

  export type VideoActorUncheckedUpdateWithoutVideoInput = {
    actorId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoActorUncheckedUpdateManyWithoutVideoInput = {
    actorId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtitleUpdateWithoutVideoMetadataInput = {
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    video?: VideoFileUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type SubtitleUncheckedUpdateWithoutVideoMetadataInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
  }

  export type SubtitleUncheckedUpdateManyWithoutVideoMetadataInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
  }

  export type VideoLanguageUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoLanguageUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VideoLanguageUncheckedUpdateManyWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SubtitleCreateManyVideoInput = {
    language: string
    subtitle_url: string
    videoMetadataId?: string | null
  }

  export type PurchaseCreateManyVideoInput = {
    id?: string
    userId: string
    purchase_date?: Date | string
    expiration_date?: Date | string | null
  }

  export type CommentCreateManyVideoInput = {
    id?: string
    userId: string
    text: string
    created_at?: Date | string
    parentCommentId?: string | null
  }

  export type ViewCreateManyVideoInput = {
    id?: string
    userId: string
    profileId?: string | null
    viewed_at?: Date | string
    progress_seconds?: number
  }

  export type SubtitleUpdateWithoutVideoInput = {
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    videoMetadata?: VideoMetadataUpdateOneWithoutSubtitlesNestedInput
  }

  export type SubtitleUncheckedUpdateWithoutVideoInput = {
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    videoMetadataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtitleUncheckedUpdateManyWithoutVideoInput = {
    language?: StringFieldUpdateOperationsInput | string
    subtitle_url?: StringFieldUpdateOperationsInput | string
    videoMetadataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purchase_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutViewsNestedInput
    profile?: SharedAccountUserUpdateOneWithoutViewsNestedInput
  }

  export type ViewUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type ViewUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    progress_seconds?: IntFieldUpdateOperationsInput | number
  }

  export type VideoMetadataUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateManyWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VideoActorCreateManyActorInput = {
    videoId: string
    role?: string | null
  }

  export type VideoActorUpdateWithoutActorInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    video?: VideoMetadataUpdateOneRequiredWithoutActorsNestedInput
  }

  export type VideoActorUncheckedUpdateWithoutActorInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoActorUncheckedUpdateManyWithoutActorInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoMetadataUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
  }

  export type VideoMetadataUncheckedUpdateManyWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VideoMetadataCreateManyFormatInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    categoryId: string
    status?: string
  }

  export type VideoMetadataUpdateWithoutFormatInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: VideoCategoryUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutFormatInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateManyWithoutFormatInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VideoMetadataCreateManyCategoryInput = {
    id?: string
    title: string
    description: string
    thumbnailUrl: string
    secondaryImage?: string | null
    releaseDate: Date | string
    platformDate: Date | string
    ageRating: string
    productionHouse: string
    productionCountry: string
    director: string
    formatId: string
    status?: string
  }

  export type VideoMetadataUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: VideoFormatUpdateOneRequiredWithoutVideosNestedInput
    movie?: MovieUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUpdateOneWithoutMetadataNestedInput
    series?: SeriesUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    movie?: MovieUncheckedUpdateOneWithoutMetadataNestedInput
    episode?: EpisodeUncheckedUpdateOneWithoutMetadataNestedInput
    series?: SeriesUncheckedUpdateOneWithoutMetadataNestedInput
    genres?: VideoGenreUncheckedUpdateManyWithoutVideosNestedInput
    actors?: VideoActorUncheckedUpdateManyWithoutVideoNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoMetadataNestedInput
    languages?: VideoLanguageUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideoMetadataUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    secondaryImage?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    platformDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ageRating?: StringFieldUpdateOperationsInput | string
    productionHouse?: StringFieldUpdateOperationsInput | string
    productionCountry?: StringFieldUpdateOperationsInput | string
    director?: StringFieldUpdateOperationsInput | string
    formatId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MovieTagCreateManyMovieInput = {
    tagId: string
  }

  export type MovieTagUpdateWithoutMovieInput = {
    tag?: TagUpdateOneRequiredWithoutMovieTagsNestedInput
  }

  export type MovieTagUncheckedUpdateWithoutMovieInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieTagUncheckedUpdateManyWithoutMovieInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type SeasonCreateManySeriesInput = {
    id?: string
    number: number
  }

  export type SeriesTagCreateManySeriesInput = {
    tagId: string
  }

  export type SeasonUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    episodes?: EpisodeUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    episodes?: EpisodeUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type SeriesTagUpdateWithoutSeriesInput = {
    tag?: TagUpdateOneRequiredWithoutSeriesTagsNestedInput
  }

  export type SeriesTagUncheckedUpdateWithoutSeriesInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTagUncheckedUpdateManyWithoutSeriesInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type EpisodeCreateManySeasonInput = {
    id?: string
    number: number
    videoFileId: string
    metadataId: string
  }

  export type EpisodeUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    videoFile?: VideoFileUpdateOneRequiredWithoutEpisodeNestedInput
    metadata?: VideoMetadataUpdateOneRequiredWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    videoFileId?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
  }

  export type EpisodeUncheckedUpdateManyWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    videoFileId?: StringFieldUpdateOperationsInput | string
    metadataId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieTagCreateManyTagInput = {
    movieId: string
  }

  export type SeriesTagCreateManyTagInput = {
    seriesId: string
  }

  export type MovieTagUpdateWithoutTagInput = {
    movie?: MovieUpdateOneRequiredWithoutTagsNestedInput
  }

  export type MovieTagUncheckedUpdateWithoutTagInput = {
    movieId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieTagUncheckedUpdateManyWithoutTagInput = {
    movieId?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTagUpdateWithoutTagInput = {
    series?: SeriesUpdateOneRequiredWithoutTagsNestedInput
  }

  export type SeriesTagUncheckedUpdateWithoutTagInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTagUncheckedUpdateManyWithoutTagInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    userId: string
    videoId: string
    text: string
    created_at?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    video?: VideoFileUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdViewCreateManyAdInput = {
    id?: string
    userId?: string | null
    profileId?: string | null
    viewed_at?: Date | string
  }

  export type AdViewUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdViewsNestedInput
    profile?: SharedAccountUserUpdateOneWithoutAdViewsNestedInput
  }

  export type AdViewUncheckedUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdViewUncheckedUpdateManyWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}